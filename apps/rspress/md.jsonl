{"messages":[{"role":"user","content":"vue回车换行自定义指令"},{"role":"assistant","content":"有客户提出需求，希望在输入框输入后能使用回车换行，因为项目表单很多，我想到使用自定义指令来实现这个功能，我书写了两个版本，vue2和vue3\n我会先贴出完整的代码片段和注释，后面再对书写的内容进行详解 ，大家有需要可以直接去使用，第一次写文章，如果有不妥，大家请见谅。如果代码内容有问题，请帮忙提出一下修改意见，谢谢。"}],"metadata":{},"filePath":"docs/guide/vue/other/vue回车换行自定义指令.md"}
{"messages":[{"role":"user","content":"1、Vue2速通版"},{"role":"assistant","content":"```js\n//  ./module/iptLine.js文件\nlet nodes;//以数组形式存放node节点\nlet callBackHandler;//暂存bind值，方便在事件中回调\nexport default {\n  bind: function (el, bind) {\n    nodes = getNode(el, []); //在当前绑定的元素下，获取非disabled的node节点\n    callBackHandler = bind;\n    el.addEventListener(\"keyup\", nextHandler);//绑定keyup事件\n  },\n  unbind: function (el) {\n### //移除副作用\n    el.removeEventListener(\"keyup\", nextHandler);//移除keyup事件\n    nodes = undefined;//\n    callBackHandler = undefined;\n  },\n};\nfunction nextHandler(e) {\n\n  e.preventDefault();//阻止原生事件\n  if (e.key !== \"Enter\") return;//如果不是回车键，则不触发\n  nodes.forEach((item, index) => {//对于nodes节点进行循环，进行事件委托\n    if (e.target === item) {//寻找当前触发的这个事件的node节点\n      if (index === nodes.length - 1)//如果node节点是最后一位，则触发传入回调\n        return callBackHandler.value && callBackHandler.value();//当传入回调存在时则进行触发\n      nodes[index + 1].focus();//将焦点移动至下一个node\n    }\n  });\n}\n/**\n * \n * @param {HTMLElement} el 传入dom实例，获取该实例下的所有input的node节点\n * @param {[]} arr 方便递归时存储已筛选出的node节点，请固定传入[]\n * @returns \n */\nfunction getNode(el, arr) {\n  el.childNodes.forEach((item, index) => {//对于当前元素的子节点进行循环\n    if (item.tagName === \"INPUT\" && item.disabled !== true) {\n      //如果当前的node节点是input,且为可用状态，则添加的数组中\n      arr.push(item);\n    } else {\n      if (item.childNodes === undefined) return;//如果没有子节点则终止该函数\n      getNode(item, arr);//如果有子节点则进行递归\n    }\n  });\n  return arr;\n}\n\n```\n```js\n//vue事件注册\nimport iptLine from './module/iptLine'\nVue.directive(\"iptLine\", iptLine);\n//iptLine是自定义的名字，大家可以根据习惯定义\n```\n总体思路：获取当前绑定自定义指令的元素，递归这个元素中的input标签形成数组，通过事件委托，找到当前元素再数组中的位置，将焦点通过focus移动到下一个元素，接受一个回调函数\n回调函数是在移动到最后一位时触发，如果要传入参数，请以闭包的形式传入  。ps:v-iptLine='()=>callback(\"hello world\")',一般情况下如果不需要传入参数v-iptLine='callback'即可"}],"metadata":{},"filePath":"docs/guide/vue/other/vue回车换行自定义指令.md"}
{"messages":[{"role":"user","content":"2、Vue3速通版"},{"role":"assistant","content":"vue3的只需要修改生命周期即可bind和unbind，修改为created和beforeUnmount\n```js\nlet nodes;\nlet callBackHandler;\nexport default {\n  created: function (el, bind) {\n    nodes = getNode(el, []);\n    callBackHandler = bind;\n    el.addEventListener('keyup', nextHandler);\n  },\n  beforeUnmount: function (el) {\n    el.removeEventListener('keyup', nextHandler);\n    nodes = undefined;\n    callBackHandler = undefined;\n  }\n};\nfunction nextHandler(e) {\n  e.preventDefault();\n  if (e.key !== 'Enter') return;\n  nodes.forEach((item, index) => {\n    if (e.target === item) {\n      if (index === nodes.length - 1)\n        return callBackHandler.value && callBackHandler.value()\n      nodes[index + 1].focus();\n    }\n  });\n}\nfunction getNode(el, arr) {\n  el.childNodes.forEach((item, index) => {\n    if (item.tagName === 'INPUT' && item.disabled !== true) {\n      arr.push(item);\n    } else {\n      if (item.childNodes === undefined) return;\n      getNode(item, arr);\n    }\n  });\n  return arr;\n}\n\n```\nvue3的使用方法和vue2基本一致，不多赘述了。（偷懒，嘿嘿）\n如果不想看具体的想法，已经结束了啦"}],"metadata":{},"filePath":"docs/guide/vue/other/vue回车换行自定义指令.md"}
{"messages":[{"role":"user","content":"3、具体实现"},{"role":"assistant","content":"如何实现回车跳转呢？我的设想是获取我们需要跳转元素的input元素，按回车跳转到下一个元素，那就通过两步走来实现"}],"metadata":{},"filePath":"docs/guide/vue/other/vue回车换行自定义指令.md"}
{"messages":[{"role":"user","content":"3.1、基本知识"},{"role":"assistant","content":"一个指令定义对象可以提供如下几个钩子函数 (均为可选)：\n[]:"}],"metadata":{},"filePath":"docs/guide/vue/other/vue回车换行自定义指令.md"}
{"messages":[{"role":"user","content":"3.2、获取元素"},{"role":"assistant","content":"我们可以在自定义指令的钩子函数中，直接获取当前的dom实例，我书写了一个函数，通过递归，可以找到所有的input子节点\n```js\n/**\n * \n * @param {HTMLElement} el 传入dom实例，获取该实例下的所有input的node节点\n * @param {[]} arr 方便递归时存储已筛选出的node节点，请固定传入[]\n * @returns \n */\nfunction getNode(el, arr) {\n  el.childNodes.forEach((item, index) => {//对于当前元素的子节点进行循环\n    if (item.tagName === \"INPUT\" && item.disabled !== true) {\n      //如果当前的node节点是input,且为可用状态，则添加的数组中\n      arr.push(item);\n    } else {\n      if (item.childNodes === undefined) return;//如果没有子节点则终止该函数\n      getNode(item, arr);//如果有子节点则进行递归\n    }\n  });\n  return arr;\n}\n```\n这个函数传入两个参数，第一个是dom实例，第二个是一个空数组，\n如果当前的node节点是input，并且它的diabled属性不会true，就会添加到我们的数组集合中。如果当前层级的input节点查询完毕，我们需要判断他是否有子节点，如果有子节点则进行递归操作，如果没有子节点则终止当前条件"}],"metadata":{},"filePath":"docs/guide/vue/other/vue回车换行自定义指令.md"}
{"messages":[{"role":"user","content":"3.3、绑定事件"},{"role":"assistant","content":"我们将事件绑定到当前的dom上去，通过事件委托的机制来对我们需要实现的功能进行下发。\n```js\nnodes = getNode(el, []); //在当前绑定的元素下，获取非disabled的node节点\ncallBackHandler = bind;\nel.addEventListener(\"keyup\", nextHandler);//绑定keyup事件\n```"}],"metadata":{},"filePath":"docs/guide/vue/other/vue回车换行自定义指令.md"}
{"messages":[{"role":"user","content":"3.3.1绑定事件函数"},{"role":"assistant","content":"```js\nfunction nextHandler(e) {\n  e.preventDefault();//阻止原生事件\n  if (e.key !== \"Enter\") return;//如果不是回车键，则不触发\n  nodes.forEach((item, index) => {//对于nodes节点进行循环，进行事件委托\n    if (e.target === item) {//寻找当前触发的这个事件的node节点\n      if (index === nodes.length - 1)//如果node节点是最后一位，则触发传入回调\n        return callBackHandler.value && callBackHandler.value();//当传入回调存在时则进行触发\n      nodes[index + 1].focus();//将焦点移动至下一个node\n    }\n  });\n}\n```\n首先先阻止该函数的原生事件，当按键不会'Enter'时，则不进行触发，我们对收集到的node节点进行循环，找到当前触发事件的dom元素，接下来使用focus函数将焦点移动到下一个node节点，如果当前的节点是最后一个，则判断是否存在传入的回调函数，如果存在则调用，上文的if(条件)return这是一种简写方法"}],"metadata":{},"filePath":"docs/guide/vue/other/vue回车换行自定义指令.md"}
{"messages":[{"role":"user","content":"3.3.2为什么要进行事件委托？"},{"role":"assistant","content":"其实在开始的一版，是直接使用el.querySelectorAll(\"input\");获取所有的input标签，然后直接进行绑定的，真的很好用，直接写个函数就干完了，但是它是真的很耗性能，所有的input标签都会绑定这个事件，如果你后续需要对input标签绑定事件，就该掉头发了，我们通过事件委托，就可以只绑定在父元素上，而且就一个，对于后期的副作用也好处理哦"}],"metadata":{},"filePath":"docs/guide/vue/other/vue回车换行自定义指令.md"}
{"messages":[{"role":"user","content":"3.3.3为什么绑定keyup事件？"},{"role":"assistant","content":"主要是因为大多键盘的默认事件都是在keydown上，而且大多数的ui框架也都是绑定一些事件在keydown上，主要就是为了不影响大家的习惯，后续拓展其他事件也方便"}],"metadata":{},"filePath":"docs/guide/vue/other/vue回车换行自定义指令.md"}
{"messages":[{"role":"user","content":"3.3.4为什么使用变量提前进行申明？"},{"role":"assistant","content":"使用变量申明主要是方便在addEventListener绑定事件的函数中进行操作，addEventListener是无法传参进去的，如果你书写成（参数a）=>function（e）{}这种形式想要去获取如el或者bind这些我们需要在函数中使用的一些参数，我们会面临一个问题，在后续的removeEventListener中，我们将无法移除这个事件，道理和vue的data为什么是return一样，它每次都会生成一个具有新地址的函数，我没没法去移除它\n感谢阅读。看到这里帮忙点个攒吧！Thanks♪(･ω･)ﾉ"}],"metadata":{},"filePath":"docs/guide/vue/other/vue回车换行自定义指令.md"}
{"messages":[{"role":"user","content":"浏览器插件"},{"role":"assistant","content":"可以前往极简插件网站下载浏览器插件\n在我们的日常工作中，安装一些浏览器插件可以更方便一些日常工作。这篇经验就来介绍一下怎么在谷歌浏览器里面安装插件。\n1、打开谷歌浏览器。\n\n2、点击右上角的三个点，找到设置。\n\n3、在左侧的菜单中找到“扩展程序”，单击一下。\n\n4、打开右上角的“开发者模式”。\n\n5、把插件直接拖拽到浏览器的空白处。\n\n6、点击“添加扩展程序”。\n\n7、如图所示，这就是添加成功的样子。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/浏览器插件.md"}
{"messages":[{"role":"user","content":"1.1 前端的定义"},{"role":"assistant","content":"在我们访问一个网站时，所有能够直接看到、点击、输入和互动的部分，都是由前端来实现的。前端主要是指用户可视界面的开发，包含页面结构、样式、动态效果和互动功能，最终目标是为用户提供友好且美观的交互界面。"}],"metadata":{},"filePath":"docs/guide/guid/tool/前端是什么.md"}
{"messages":[{"role":"user","content":"1.2 前端的三大核心技术"},{"role":"assistant","content":"前端开发的实现主要依赖以 下三大核心技术：\nHTML（HyperText Markup Language）：前端开发的基础，用于定义网页的结构和内容。HTML 定义了网站的每个元素，如文本、图像、视频、链接等，让网页有“骨架”。\nCSS（Cascading Style Sheets）：用于网页的样式设计，定义 HTML 元素的显示方式，包括颜色、字体、布局等。CSS 让网页更加美观、有层次感。\nJavaScript：赋予网页动态交互功能，使网页可以响应用户操作。比如按钮的点击、表单验证、图片轮播等功能都需要 JavaScript 支持。\n这些技术的结合，让开发者可以构建功能丰富、互动性强的网页。随着前端技术的不断发展，HTML、CSS 和 JavaScript 的应用也越来越广泛和深入。"}],"metadata":{},"filePath":"docs/guide/guid/tool/前端是什么.md"}
{"messages":[{"role":"user","content":"1.3 前端框架和工具"},{"role":"assistant","content":"为了提升开发效率和用户体验，前端开发衍生出了一系列强大的框架和工具：\n框架和库：如 React、Vue.js、Angular 等，它们提供了大量预设的组件和功能，帮助开发者快速构建复杂的界面。\n预处理器和后处理器：如 Sass、Less（CSS 预处理器）、PostCSS 等，用于提升 CSS 的灵活性和可维护性。\n构建工具：如 Webpack、Parcel 等，用于打包、压缩和优化前端代码，提升网页加载速度。"}],"metadata":{},"filePath":"docs/guide/guid/tool/前端是什么.md"}
{"messages":[{"role":"user","content":"2.1 后端的定义"},{"role":"assistant","content":"与前端的用户交互界面不同，后端负责应用的业务逻辑、数据处理和管理。后端如同应用的“后台”，用户无法直接看到，但它负责网站或应用的核心功能和数据流转。后端的职责是确保数据存储安全、业务逻辑运行流畅，并根据请求将数据发送给前端。"}],"metadata":{},"filePath":"docs/guide/guid/tool/前端是什么.md"}
{"messages":[{"role":"user","content":"2.2 后端的组成要素"},{"role":"assistant","content":"后端主要由以下几个部分构成：\n服务器：为用户提供数据和计算资源的设备，托管网站和应用。服务器接收前端发送的请求，并根据业务逻辑返回相应的数据。\n数据库：用于存储和管理应用数据的系统，常见的数据库有 MySQL、MongoDB、PostgreSQL 等。数据库将结构化的或非结构化的数据保存下来，以便随时查询和更新。\n服务器端编程语言：用于编写业务逻辑代码，将应用的需求转化为功能，常见的后端语言有 Java、Python、PHP、Ruby、Node.js 等。"}],"metadata":{},"filePath":"docs/guide/guid/tool/前端是什么.md"}
{"messages":[{"role":"user","content":"2.3 后端框架和工具"},{"role":"assistant","content":"为了提升开发效率和代码的稳定性，后端开发者通常使用各种框架和工具：\n后端框架：如 Express（基于 Node.js）、Django（基于 Python）、Laravel（基于 PHP）等，这些框架提供了丰富的工具和功能，加速开发并提升代码的可维护性。\nAPI：应用程序接口（API）是前后端沟通的桥梁，常见的 API 技术包括 RESTful API 和 GraphQL，通过这些接口，前端可以请求数据，而后端负责返回所需的数据。"}],"metadata":{},"filePath":"docs/guide/guid/tool/前端是什么.md"}
{"messages":[{"role":"user","content":"3.前后端的区别"},{"role":"assistant","content":"了解了前端和后端的概念后，我们再来深入探讨一下两者的区别。前端和后端分别处理不同的任务，它们相辅相成，共同构成了一个完整的应用。"}],"metadata":{},"filePath":"docs/guide/guid/tool/前端是什么.md"}
{"messages":[{"role":"user","content":"4.什么是前后端分离？"},{"role":"assistant","content":"在了解了前后端的区别后，现代 Web 开发中越来越强调的“前后端分离”概念就很容易理解了。前后端分离意味着前端和后端各自独立开发、部署和维护，两者通过 API 进行数据交换。这种开发模式带来了很多好处"}],"metadata":{},"filePath":"docs/guide/guid/tool/前端是什么.md"}
{"messages":[{"role":"user","content":"4.1 前后端耦合与前后端分离"},{"role":"assistant","content":"传统前后端耦合方式：早期的 Web 开发中，前端页面和后端逻辑紧密耦合在一起。每当用户请求一个页面，服务器会先处理业务逻辑，将数据填充到 HTML 模板中生成页面，再返回给浏览器。这种方式虽然简单，但页面每次请求都需要刷新，体验不佳。 浏览器的展示是由后端来决定的 其实就是服务器决定的。"}],"metadata":{},"filePath":"docs/guide/guid/tool/前端是什么.md"}
{"messages":[{"role":"user","content":"4.3 前后端分离的实现方式"},{"role":"assistant","content":"RESTful API：通过 REST 风格的接口，前端可以按需请求资源，如 CRUD（增删查改）操作，非常适合大部分 Web 应用。\nGraphQL：一种灵活的查询语言，让前端可以按需请求数据字段，减少了冗余数据的传输，适合复杂应用的数据请求。\n前端：用户访问一个在线商城，页面的商品展示和购物车动态更新，这些交互由前端处理。用户点击商品、添加到购物车等操作会触发 JavaScript 动作，并通过 Axios 发送请求。\n后端：接收到请求后，后端服务器查询数据库，返回商品数据。后端还负责处理库存管理、支付逻辑等，确保商品库存与订单信息准确无误。\n通过 API，前端可以迅速获取最新的商品信息，局部刷新商品列表，不需要刷新整个页面，提升了购物体验。\n总结\n前端：定义页面结构、样式和交互，让用户看到并与应用互动的部分。\n后端：负责业务逻辑和数据处理，确保应用核心功能的正常运行。\n前后端分离：是一种现代化开发模式，通过 API 将前端与后端分离，提升开发效率和用户体验。\n通过深入了解前端、后端及前后端分离的概念，希望你能对 Web 开发的整体架构有更系统的认识。接下来的学习中，我们将带你进一步了解前端开发的具体技术，实现从零到项目开发的顺利过渡"}],"metadata":{},"filePath":"docs/guide/guid/tool/前端是什么.md"}
{"messages":[{"role":"user","content":"从 koa 到 mini-vite（三）资源处理及模块依赖和热更新"},{"role":"assistant","content":"这个是仓库地址"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(三).mdx"}
{"messages":[{"role":"user","content":"1、处理图片资源的路径"},{"role":"assistant","content":"我们先对资源路径进行处理，不过 和 的资源处理大有不同，我们这里先论证 ，你可以从 文件中看到 是如何处理的；\n```ts\n//..........\nimport koaStatic from \"koa-static\";\n//..........\nconst serverContext: ServerContext = {\n  root: process.cwd(),\n  PluginContainer,\n  app,\n  plugins: plugins,\n  moduleGraph,\n  ws,\n  clientPath,\n  watcher,\n};\nbindingHMREvents(serverContext);\napp.use(koaStatic(path.join(process.cwd(), \"/src/client/\")));\nfor (const plugin of plugins) {\n  if (plugin.configureServer) {\n    await plugin.configureServer(serverContext);\n  }\n}\napp.use(indexHtmlMiddware(serverContext));\napp.use(transformMiddleware(serverContext));\n//..........\n```\n我们这边使用 静态资源包对其客户端文件进行代理 ;\n的资源处理就完成了，但是也是有其局限性的，无法对其 进行处理。我在 中，写了一个简单的 demo，使其 实现了对相对路径的处理，你可以参考一下。\n我简单的介绍一下 vue 我是如何处理的；\n```js\nexport default \"src/cyber/components/171536_380.png\";\n```\n这样我们就能引入图片，并实现引入图片的懒加载了。"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(三).mdx"}
{"messages":[{"role":"user","content":"2、处理 Svg 资源"},{"role":"assistant","content":"对于 svg 资源的处理，我在这里书写了一个 ,在书写一个程序前，确立两点有助于帮助我们快速的实现\n实际上也就是确定 ;\n我们来看看，我们需要怎么去实现一个 svg 的处理,先看需求代码\n```tsx\nimport \"./App.css\";\nimport React from \"react\";\nimport logo from \"./logo.svg\";\n// import logo from \"./logo.svg\";\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <p>dsdsHell ssf sadsf</p>\n        <p></p>\n        <img src=\"/public/OIP-C.jpg\" alt=\"\" />\n        <p>\n          ds<code>sdssdafsssfadsa</code> sans save es tsest.\n        </p>\n        <img className=\"App-logo\" src={logo} alt=\"\" />\n        <p></p>\n      </header>\n    </div>\n  );\n}\n```\n我们可以清晰的看到，我们的 src 值是引入的 ， 接受的是地址，我们需要处理的是将 logo 转化为 ；而 插件中， 钩子是返回 的，我们就在此处做文章\n```ts\nimport { Plugin } from \"./plugin\";\nimport { ServerContext } from \"../../index\";\nimport { cleanUrl, getShortName, normalizePath, removeImportQuery } from \"../utils\";\nimport path from \"path\";\nexport function assetPlugin(): Plugin {\n  let serverContext: ServerContext;\n\n  return {\n    name: \"m-vite:asset\",\n    configureServer(s) {\n      serverContext = s;\n    },\n    async load(id) {\n      const cleanedId = removeImportQuery(cleanUrl(id));\n      const resolvedId = `/${path\n        .relative(path.join(serverContext.root, \"/src/client/\"), cleanedId)\n        .replaceAll(\"\\\\\", \"/\")}`;\n\n      if (cleanedId.endsWith(\".svg\")) {\n        return {\n          code: `export default \"${resolvedId}\"`,\n        };\n      }\n    },\n  };\n}\n```\n我们在 load 中将传入的 ，由经 的处理，我们的 是绝对路径，能读取到位置的绝对路径，后续再使用 ，将路径做相对路径处理，这样我们就能得到相对于当前文件的位置，因为我们在前文 代理的路径是 ,所以我们需要在此处进行一下处理"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(三).mdx"}
{"messages":[{"role":"user","content":"3、css 处理"},{"role":"assistant","content":"我们 的处理用一个 ,我们来确定一下思路，我们的目的是将 转化为浏览器可读的 样式；我们来梳理一下处理思路；\n这里是 plugin 代码，后续会为了热更新我们会进行进一步的改善\n```ts\n// plugins/css.ts\nimport { readFile } from \"fs-extra\";\nimport { Plugin } from \"../plugin\";\n\nexport function cssPlugin(): Plugin {\n  return {\n    name: \"m-vite:css\",\n    load(id) {\n      // 加载\n      if (id.endsWith(\".css\")) {\n        return readFile(id, \"utf-8\");\n      }\n    },\n    // 转换逻辑\n    async transform(code, id) {\n      if (id.endsWith(\".css\")) {\n        // 包装成 JS 模块\n        const jsContent = `\nconst css = \"${code.replace(/\\n/g, \"\")}\";\nconst style = document.createElement(\"style\");\nstyle.setAttribute(\"type\", \"text/css\");\nstyle.innerHTML = css;\ndocument.head.appendChild(style);\nexport default css;\n`.trim();\n        return {\n          code: jsContent,\n        };\n      }\n      return null;\n    },\n  };\n}\n```"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(三).mdx"}
{"messages":[{"role":"user","content":"4、依赖图谱"},{"role":"assistant","content":"依赖图谱主要有以下几个作用\n我们来确定一下，我们的依赖图谱每一个节点需要的是哪些参数，这里提供一个 ，我们来进行参考\n```ts\nexport class ModuleNode {\n  // 资源访问 url\n  url: string;\n  // 资源绝对路径\n  id: string | null = null;\n  importers = new Set<ModuleNode>();\n  importedModules = new Set<ModuleNode>();\n  transformResult: TransformResult | null = null;\n  lastHMRTimestamp = 0;\n  constructor(url: string) {\n    this.url = url;\n  }\n}\n```\n我们可以看到，一个 moduleNode 类，需要的是\n此类，在后续的生成中，我们命名为 节点,我们从 到 中间件，来看看他是如何处理的\n首先，我们从 url 的中间件开始\n<img src=\"/vite/koa_vite/中间件流程图.png\" />\n这里有张流程图，我们的代码处理如下\n```ts\n//src\\node\\middlewares\\transformMiddleware.ts\n//........\nasync function transformRequest(url: string, serverContext: ServerContext) {\n  const { PluginContainer, moduleGraph } = serverContext;\n  let query = url.split(\"?\")[1];\n\n  url = cleanUrl(url);\n\n  let mod = await moduleGraph.getModuleByUrl(url);\n  if (mod && mod.transformResult && !query) {\n    return mod.transformResult;\n  }\n  let res;\n  let resolveId = await PluginContainer.resolveId(url);\n  if (resolveId?.id) {\n    let code = await PluginContainer.load(resolveId?.id);\n    if (typeof code === \"object\" && code !== null) {\n      code = code.code;\n    }\n\n    mod = await moduleGraph.ensureEntryFromUrl(url);\n    if (code) {\n      res = await PluginContainer.transform(code, resolveId?.id);\n    }\n    if (mod) {\n      mod.transformResult = res;\n    }\n  }\n  return res;\n}\n//........\n```\n我们的 对象会一点一点的进行介绍，一下子说完会感觉有点乱，\n我们来看看，他这里调用的 方法是什么\n```ts\n//src\\node\\ModuleGraph.ts\n//moduleGraph.getModuleByUrl(url);\nexport class ModuleGraph {\n  urlToModuleMap = new Map<string, ModuleNode>();\n  idToModuleMap = new Map<string, ModuleNode>();\n  constructor(private resolveId: (url: string) => Promise<PartialResolvedId | null>) {}\n  getModuleById(url: string): ModuleNode | undefined {\n    return this.idToModuleMap.get(url);\n  }\n  async getModuleByUrl(rawUrl: string): Promise<ModuleNode | undefined> {\n    const { url } = await this._resolve(rawUrl);\n    return this.urlToModuleMap.get(cleanUrl(url));\n  }\n  async ensureEntryFromUrl(rawUrl: string): Promise<ModuleNode | undefined> {\n    const { url, resolvedId } = await this._resolve(rawUrl);\n    if (this.urlToModuleMap.has(url)) {\n      return this.urlToModuleMap.get(url) as ModuleNode;\n    }\n    const mod = new ModuleNode(url);\n    mod.id = resolvedId;\n    this.urlToModuleMap.set(url, mod);\n    this.idToModuleMap.set(resolvedId, mod);\n    return mod;\n  }\n}\n\n//src\\index.ts\nconst moduleGraph = new ModuleGraph(url => PluginContainer.resolveId(url));\n```\n这个类的 的参数传入的是插件容器定义的 resolveId 路径解析方法\n他会帮助我们解析路径，返回由插件容器解析的路径；\n我们从流程图上来看：\n预设进行依赖收集\n```ts\n// src\\node\\plugins\\importAnalysis.ts\n\n//.....length\nasync transform(code, id) {\n      const { moduleGraph } = serverContext;\n      const curmod = moduleGraph.getModuleById(id)!;\n      const importedModules = new Set<string>();\n      //....\n        for (const importInfo of imports) {\n        const { s: modStart, e: modEnd, n: modSource } = importInfo;\n        if (!modSource) continue;\n        //....\n        if (BARE_IMPORT_RE.test(modSource as string)) {\n          const bundlePath = normalizePath(\n            path.join('/', PRE_BUNDLE_DIR, `${modSource}.js`)\n          );\n          importedModules.add(bundlePath);\n\n          ms.overwrite(modStart, modEnd, bundlePath as string)\n        } else if (modSource.startsWith(\".\") || modSource.startsWith(\"/\")) {\n        //....\n          if (resolved) {\n            ms.overwrite(modStart, modEnd, resolved);\n            importedModules.add(resolved);\n          }\n        }\n      };\n      //....\n      moduleGraph.updataModuleInfo(curmod, importedModules);\n        return {\n        code: ms.toString(),\n        map: ms.generateMap()\n      }\n}\n\n\n```\n<img src=\"/vite/koa_vite/importAnalysis依赖分析.png\" />\n我们跟着流程图看\n```ts\nexport class ModuleGraph {\n  urlToModuleMap = new Map<string, ModuleNode>();\n  idToModuleMap = new Map<string, ModuleNode>();\n  //....\n\n  async updateModuleInfo(mod: ModuleNode, importedModules: Set<string | ModuleNode>) {\n    const prevImports = mod.importedModules;\n    for (const curImports of importedModules) {\n      const dep =\n        typeof curImports === \"string\"\n          ? await this.ensureEntryFromUrl(cleanUrl(curImports))\n          : curImports;\n      if (dep) {\n        mod.importedModules.add(dep);\n        dep.importers.add(mod);\n      }\n    }\n    // 清除已经不再被引用的依赖\n    for (const prevImport of prevImports) {\n      if (!importedModules.has(prevImport.url)) {\n        prevImport.importers.delete(mod);\n      }\n    }\n  }\n}\n//....\n```\n这里是完整的ModuleGraph代码，可以参考一下，具体更改的文件过多，请于仓库中查看\n```ts\nimport { PartialResolvedId, TransformResult } from \"rollup\";\nimport { cleanUrl } from \"./utils\";\nimport { debug } from \"console\";\nimport { getboundaries } from \"./plugins/hmr/boundaries\"\nexport class ModuleNode {\n  url: string = \"\";\n  id: string = \"\";\n  importers = new Set<ModuleNode>();\n  importedModules = new Set<ModuleNode>();\n  transformResult: TransformResult | null = null;\n  lastHMRTimetamp = 0;\n  constructor(url: string) {\n    this.url = url\n  }\n};\nexport class ModuleGraph {\n  urlToModuleMap = new Map<string, ModuleNode>();\n  idToModuleMap = new Map<string, ModuleNode>();\n  constructor(private resolveId: (url: string) => Promise<PartialResolvedId | null>) { };\n  getModuleById(url: string): ModuleNode | undefined {\n    return this.idToModuleMap.get(url)\n  }\n  async getModuleByUrl(rawUrl: string): Promise<ModuleNode | undefined> {\n    const { url } = await this._resolve(rawUrl);\n    return this.urlToModuleMap.get(cleanUrl(url))\n  }\n  async ensureEntryFromUrl(rawUrl: string): Promise<ModuleNode | undefined> {\n\n    const { url, resolvedId } = await this._resolve(rawUrl);\n    if (this.urlToModuleMap.has(url)) {\n      return this.urlToModuleMap.get(url) as ModuleNode\n    }\n    const mod = new ModuleNode(url);\n    mod.id = resolvedId;\n    this.urlToModuleMap.set(url, mod);\n    this.idToModuleMap.set(resolvedId, mod)\n    return mod;\n  };\n  async updataModuleInfo(mod: ModuleNode, importedModules: Set<string | ModuleNode>) {\n    const prevImports = mod.importedModules;\n\n    for (const curImports of importedModules) {\n\n\n      const dep = typeof curImports === \"string\" ? await this.ensureEntryFromUrl(cleanUrl(curImports)) : curImports;\n      if (dep) {\n\n        mod.importedModules.add(dep);\n        dep.importers.add(mod);\n      }\n    }\n    for (const preImport of prevImports) {\n      // console.log(importedModules.has(preImport.url as string))\n      if (!importedModules.has(preImport.url as string)) {\n        preImport.importers.delete(mod)\n      }\n    }\n  };\n  invalidateModule(file: string) {\n    const mod = this.idToModuleMap.get(file);\n    if (mod) {\n      mod.lastHMRTimetamp = Date.now();\n      mod.transformResult = null;\n      mod.importers.forEach((importer) => {\n        this.invalidateModule(importer.id!)\n      })\n    }\n  }\n  private async _resolve(url: string): Promise<{ url: string, resolvedId: string }> {\n    const resolved = await this.resolveId(url);\n    const resolvedId = resolved?.id as string;\n    return { url, resolvedId }\n  }\n  getboundaries(url: string) {\n    let curmod = this.urlToModuleMap.get(url)!;\n\n    return Array.from(getboundaries(curmod, new Set()))\n  }\n}\n\n```"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(三).mdx"}
{"messages":[{"role":"user","content":"5、热更新"},{"role":"assistant","content":"热更新这里还有一些问题值得思考，我会带大家实现一个无状态保留的热更新，具体的热更新政策，我们还是需要去读react或者vue的热更新源码，这里就不做详细介绍。\n我们来确定，热更新需要的一些物料\n热更新整体流程图如下\n<img src=\"/vite/koa_vite/hmr大纲.png\" />\n```ts\n//src\\index.ts\nconst watcher = chokidar.watch(clientPath, {\n  ignored: [/node_modules/, /\\.git/],\n  ignoreInitial: true\n});\nconst ws = createWebSocketServer(app);\nconst serverContext: ServerContext = {\n  root: process.cwd(),\n  PluginContainer,\n  app,\n  plugins: plugins,\n  moduleGraph,\n  ws,\n  clientPath,\n  watcher\n};\nbindingHMREvents(serverContext)\n```\n我们先来看看\n```ts\n//src\\node\\ModuleGraph.ts\nimport { WebSocketServer, WebSocket } from \"ws\";\nimport { HMR_PORT } from \"./contants\";\nimport color from \"picocolors\";\nexport function createWebSocketServer(server: any): { send: (msg: string) => void; close: () => void } {\n  let wss: WebSocketServer;\n  wss = new WebSocketServer({ port: HMR_PORT });\n  wss.on(\"connection\", (socket) => {\n    socket.send(JSON.stringify({ type: \"connected\" }))\n  });\n  wss.on(\"error\", (e: Error & { code: string }) => {\n    if (e.code !== \"EADDRINUSE\") {\n      console.error(color.red(`WebSocket server error:\\n${e.stack || e.message}`))\n    }\n  })\n  return {\n    send(payload: Object) {\n      const stringified = JSON.stringify(payload);\n      wss.clients.forEach((client) => {\n        if (client.readyState === WebSocket.OPEN) {\n          client.send(stringified)\n        }\n      })\n    },\n    close() { \n      wss.close()\n    }\n  }\n}\n\n```\n这是封装的一个websocket服务,他会返回一个对象，这个对象可以向我们的服务端广播更新的信息，我们只需要调用这个对象的send方法即可\n再来看看 的代码\n```ts\nimport { ServerContext } from './../index';\nimport picocolors from \"picocolors\";\nimport { getShortName } from \"./utils\";\nexport function bindingHMREvents(serverContext: ServerContext) {\n  const { watcher, ws, root } = serverContext;\n  watcher.on(\"change\", async (file) => {\n    console.log(`✨${picocolors.blue(\"[hmr]\")} ${picocolors.green(file)} changed`);\n    const { moduleGraph } = serverContext;\n    await moduleGraph.invalidateModule(file);\n    let arr = moduleGraph.getboundaries(\"/\" + getShortName(file, root)).map(item => ({\n      type: \"js-update\",\n      timeStamp: Date.now(),\n      path: item,\n      acceptedPath: item\n    }))\n    ws.send({\n      type: \"update\",\n      updates: arr,\n    })\n  })\n}\n```\n这里是监听文件变化，如果文件发送变化，则使用 发动更新信息，通知客户端，这里有个边界寻找方法 这个方法会帮助我们找到所有的依赖此文件的父级。\n这是一个虚拟模块，它会将 中的代码注入到客户端中\n```ts\n//src\\node\\plugins\\clientInject.ts\nimport { CLIENT_PUBLIC_PATH, HMR_PORT } from \"../contants\";\nimport { Plugin } from \"./plugin\";\nimport fs from \"fs-extra\";\nimport esbuild from \"esbuild\"\nimport path from \"path\";\nimport { ServerContext } from \"../../index\";\nfunction clientInjectPlugin(): Plugin {\n  let serverContext: ServerContext;\n  return {\n    name: \"m-vite:client-inject\",\n    configureServer(s) {\n      serverContext = s\n    },\n    resolveId(id) {\n      if (id === CLIENT_PUBLIC_PATH) {\n        return { id }\n      }\n      return null\n    },\n    async load(id) {\n      if (id === CLIENT_PUBLIC_PATH) {\n\n        let realpath = path.join(import.meta.dirname, \"hmr\", \"client.ts\");\n        let { code } = await esbuild.transform(await fs.readFile(realpath, \"utf-8\"), {\n          loader: \"ts\",\n          target: \"esnext\"\n        })\n        code = code.replace(\"__HMR_PORT__\", JSON.stringify(HMR_PORT));\n        return code\n      }\n\n    },\n    transformIndexHtml(raw) {\n      return raw.replace(/(<head[^>]*>)/i, `$1<script type=\"module\" src=\"${CLIENT_PUBLIC_PATH}\"></script>`)\n    }\n  }\n}\nexport { clientInjectPlugin }\n\n```\n与此同时， 中也要修改一下 ，方便客户端使用。\n```ts\n      if (!id.includes(\"node_modules\")) {\n        let res = Array.from(getboundaries(curmod, new Set()));\n        ms.prepend(`import { createHotContext as __vite__createHotContext } from \"${CLIENT_PUBLIC_PATH}\";` + `import.meta.hot = __vite__createHotContext(${JSON.stringify(cleanUrl(curmod.url))},${JSON.stringify(res)});`)\n      }\n\n\n```\n这里我们建立websocket的链接，一旦我们接受到服务器的信息，就会执行 方法；\n```ts\nconst socket = new WebSocket(`ws://localhost:__HMR_PORT__`, \"vite-hmr\");\nlet boundaries: any;\nsocket.addEventListener(\"message\", async ({ data }) => {\n\n  handleMessage(JSON.parse(data)).catch(console.error)\n});\n```\n```ts\nasync function handleMessage(payload: any) {\n  switch (payload.type) {\n    case \"connection\":\n      console.log(`[vite] connected.`);\n      setInterval(() => socket.send(\"ping\"), 1000);\n      break;\n    case \"update\":\n      console.log(payload.updates)\n      payload.updates.forEach((update: any) => {\n        if (update.type === \"js-update\") {\n          fetchUpdate(update)\n        }\n      })\n      break;\n  }\n}\n\n```\n我们会使用心跳检测，去判断是否能链接上服务器，如果能链接上，则会发送一个心跳包\n如果是服务端发送的更新请求，则会调用 方法对依赖进行重新拉取\n```ts\nasync function fetchUpdate({ path, timeStamp }: any) {\n  // console.log(path)\n  const mod = hotModulesMap.get(path);\n  console.log(boundaries, \"mod---------------------\", path)\n  if (!mod) return;\n  const moduleMap = new Map();\n  const modulesToUpdate = new Set<string>();\n  modulesToUpdate.add(path);\n  // boundaries.forEach((item:string) => {\n  //   modulesToUpdate.add(item);\n  // })\n  await Promise.all(Array.from(modulesToUpdate).map(async (dep) => {\n    const [path, query] = dep.split(\"?\");\n\n    try {\n      const newMod = await import(path + `?t=${timeStamp}${query ? `&${query}` : \"\"}`);\n      moduleMap.set(dep, newMod)\n    } catch (e) {\n      console.error(e)\n    }\n  }))\n  return () => {\n    for (const { deps, fn } of mod.callbacks) {\n      fn(deps.map(dep => moduleMap.get(dep)));\n      console.log(`[vite] hot updated: ${path}`);\n    }\n  }\n}\n\n```\n这里我们就将更新过的 信息，通过 方法，重新加载模块，然后执行回调函数，实现热更新。\n我们css的热更新也是这个方式，只不过我们是在更新的时候重新读取css文件，将文件写入style标签中，每一次更新 则是委托客户端重新引入新的css 文件；\n我们的热更新也就初步实现了\n但我们还有以下几个问题\n我在这里抛砖引玉，这也就是剩下的一部分工作了，我先提几个点，日后有时间会续写上去的。"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(三).mdx"}
{"messages":[{"role":"user","content":"5.1、探讨如何写入import.meta.hot方法和其作用"},{"role":"assistant","content":"```ts\n      if (!id.includes(\"node_modules\")) {\n        let res = Array.from(getboundaries(curmod, new Set()));\n        ms.prepend(`import { createHotContext as __vite__createHotContext } from \"${CLIENT_PUBLIC_PATH}\";` + `import.meta.hot = __vite__createHotContext(${JSON.stringify(cleanUrl(curmod.url))},${JSON.stringify(res)});`)\n      }\n\n```\n这里个方法主要目的是接受服务端的 信息，构建热更新环境\n```ts\nexport const createHotContext = (ownerPath: string, arr: any) => {\n\n  boundaries = arr;\n  const mod: HotModule = hotModulesMap.get(ownerPath) || {\n    id: ownerPath,\n    callbacks: []\n  };\n  hotModulesMap.set(ownerPath, mod)\n\n  if (mod) {\n    mod.callbacks = []\n  }\n  function acceptDeps(deps: string[], callback: any) {\n\n    const mod: HotModule = hotModulesMap.get(ownerPath) || {\n      id: ownerPath,\n      callbacks: []\n    };\n    mod.callbacks.push({ deps, fn: callback });\n    hotModulesMap.set(ownerPath, mod)\n  }\n  return {\n    accept(deps: any, callback?: any) {\n\n      if (typeof deps === \"function\" || !deps) {\n        //@ts-ignore\n        acceptDeps([ownerPath], ([mod]) => deps && deps(mod))\n      }\n    },\n    prune(cb: (data: any) => void) {\n      pruneMap.set(ownerPath, cb)\n    }\n  }\n}\n\n```\n我们这里会对依赖进行收集，但这个代码并不能使用来实现毫秒级的保留状态的热更新，我们在acceptDeps方法中，并没有实现提取该依赖更新的 ，我们提取 后，需要重新的根据 引入新的代码块，来实现重新渲染，之前使用的方法则是不管其他，我们将所有相关的文件重新拉去，这里则是需要进行细化的地方，比如寻找热更新的边界，如何确定 最大影响的区域。确定后我们需要重新的对 进行拉去，需要由一定的 和 插件的支持，我们要将发送过来的 文本，进行重新的渲染；"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(三).mdx"}
{"messages":[{"role":"user","content":"5.2、探讨如何寻找热更新边界"},{"role":"assistant","content":"第二个难点是如何去进行热更新边界的判断，在 源码中，是通过 这个方法递归往上查找的，如果往上查找到了热更新边界则会退出，如果没查到则会一直查下去，直到没有为止，这个代码改写难度太大了，希望各位有更好的方法融入\n```ts\n// 热更新边界收集\nfunction propagateUpdate(\n  node: ModuleNode,\n  boundaries: Set<{\n    boundary: ModuleNode\n    acceptedVia: ModuleNode\n  }>,\n  currentChain: ModuleNode[] = [node]\n): boolean {\n   // 接受自身模块更新\n   if (node.isSelfAccepting) {\n    boundaries.add({\n      boundary: node,\n      acceptedVia: node\n    })\n    return false\n  }\n  // 入口模块\n  if (!node.importers.size) {\n    return true\n  }\n  // 遍历引用方\n  for (const importer of node.importers) {\n    const subChain = currentChain.concat(importer)\n    // 如果某个引用方模块接受了当前模块的更新\n    // 那么将这个引用方模块作为热更新的边界\n    if (importer.acceptedHmrDeps.has(node)) {\n      boundaries.add({\n        boundary: importer,\n        acceptedVia: node\n      })\n      continue\n    }\n\n    if (currentChain.includes(importer)) {\n      // 出现循环依赖，需要强制刷新页面\n      return true\n    }\n    // 递归向更上层的引用方寻找热更新边界\n    if (propagateUpdate(importer, boundaries, subChain)) {\n      return true\n    }\n  }\n  return false\n}\n\n```"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(三).mdx"}
{"messages":[{"role":"user","content":"浏览器插件"},{"role":"assistant","content":"可以前往极简插件网站下载浏览器插件\n在我们的日常工作中，安装一些浏览器插件可以更方便一些日常工作。这篇经验就来介绍一下怎么在谷歌浏览器里面安装插件。\n1、打开谷歌浏览器。\n\n2、点击右上角的三个点，找到设置。\n\n3、在左侧的菜单中找到“扩展程序”，单击一下。\n\n4、打开右上角的“开发者模式”。\n\n5、把插件直接拖拽到浏览器的空白处。\n\n6、点击“添加扩展程序”。\n\n7、如图所示，这就是添加成功的样子。"}],"metadata":{},"filePath":"docs/guide/guid/tool/浏览器插件.md"}
{"messages":[{"role":"user","content":"首先 我们先下载谷歌"},{"role":"assistant","content":"谷歌浏览器官网下载地址"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/谷歌浏览器.md"}
{"messages":[{"role":"user","content":"常见的浏览器"},{"role":"assistant","content":"浏览器是网页运行的平台，常见的浏览器有谷歌（Chrome）、Safari、火狐（Firefox）、IE、Edge、Opera 等。如下图所示：\n\n我们重点需要学习的是 Chrome 浏览器。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/谷歌浏览器.md"}
{"messages":[{"role":"user","content":"浏览器的市场占有份额"},{"role":"assistant","content":"浏览器的市场占有份额：\n\n上面这张图的统计时间是 2020 年 2 月。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/谷歌浏览器.md"}
{"messages":[{"role":"user","content":"浏览器的组成"},{"role":"assistant","content":"浏览器分成两部分："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/谷歌浏览器.md"}
{"messages":[{"role":"user","content":"1、渲染引擎（浏览器内核）"},{"role":"assistant","content":"浏览器所采用的「渲染引擎」也称之为「浏览器内核」，用于解析 HTML 和 CSS、布局、渲染等工作。渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。\n\n渲染引擎的英文叫做 Rendering Engine。通俗来说，它的作用就是：读取网页内容，计算网页的显示方式并显示在页面上。\n常见浏览器的内核如下：\n备注：360 的浏览器，以前使用的 IE 浏览器的 Trident 内核，但是现在已经改为使用 chrome 浏览器的 Blink 内核。\n另外，移动端的浏览器内核是什么？大家可以自行查阅资料。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/谷歌浏览器.md"}
{"messages":[{"role":"user","content":"2、JS 引擎"},{"role":"assistant","content":"也称为 JS 解释器。 用来解析和执行网页中的 JavaScript 代码。\n浏览器本身并不会执行 JS 代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时会逐行解释每一句源码，转换为机器语言，然后由计算机去执行。\n常见浏览器的 JS 引擎如下：\n补充说明：\n1、SpiderMonkey 是第一款 JavaScript 引擎，由 JS 语言的作者 Brendan Eich 开发。\n2、先以 WebKit 为例，WebKit 上由两部分组成：\n参考链接："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/谷歌浏览器.md"}
{"messages":[{"role":"user","content":"浏览器工作原理"},{"role":"assistant","content":"浏览器主要由下面这个七个部分组成：\n\n1、User Interface（UI 界面）：包括地址栏、前进/后退按钮、书签菜单等。也就是浏览器主窗口之外的其他部分。\n2、Browser engine （浏览器引擎）：用来查询和操作渲染引擎。是 UI 界面和渲染引擎之间的 。\n3、Rendering engine（渲染引擎）：用于解析 HTML 和 CSS，并将解析后的内容显示在浏览器上。\n4、Networking （网络模块）：用于发送网络请求。\n5、JavaScript Interpreter（JavaScript 解析器）：用于解析和执行 JavaScript 代码。\n6、UI Backend（UI 后端）：用于绘制组合框、弹窗等窗口小组件。它会调用操作系统的 UI 方法。\n7、Data Persistence（数据存储模块）：比如数据存储 cookie、HTML5 中的 localStorage、sessionStorage。\n参考链接：（关于浏览器的工作管理，下面这篇文章，是精品中的精品，是必须要知道的）"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/谷歌浏览器.md"}
{"messages":[{"role":"user","content":"为什么选择谷歌浏览器(浏览器内核详解)"},{"role":"assistant","content":"首先给出答案，因为大多浏览器使用的都是 webkit 内核，我们为了代码能兼容更多的平台，所以有限选择谷歌浏览器"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/谷歌浏览器.md"}
{"messages":[{"role":"user","content":"总结国内厂商内核来看，一般为三类："},{"role":"assistant","content":"一、使用的 Trident 单核，如：2345、 ；\n二、使用 Trident+Webkit/Blink 双核，如：qq、UC、猎豹、360、百度；\n三、使用 Webkit/Blink 单核，如：搜狗、 。\n双核浏览器通过 WebKit 内核来访问一些不需要进行网上交易的网站，使用起来速度更快更方便; 在进行支付系统或者是网上银行的访问时，则使用的是 Trident 内核。这就是双核浏览器的高速模式和兼容模式。双核浏览器是一个不仅仅具有 ie 浏览器内核同时兼容非 ie 浏览器内核的浏览器，可以让用户在浏览器当中体验不同的需求"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/谷歌浏览器.md"}
{"messages":[{"role":"user","content":"浏览器内核技术"},{"role":"assistant","content":"浏览器内核主要包括以下三个技术分支：排版渲染引擎、 JavaScript 引擎，以及其他。\n微软对排版渲染引擎相关专利的申请最多，达到浏览器内核相关专利申请总量的 93.3%。这与排版渲染引擎的功能密不可分。其主要负责取得网页的内容(HTML、XML、图像等)、整理信息，以及计算网页的显示方式，然后输出至显示器。所有的网页浏览器、 以及其他需要编辑、显示网络内容的应用程序都需要排版渲染引擎，特别是排版渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。由于在网页显示中所起的重要作用，微软一直侧重于涉及排版渲染引擎的专利申请。在 2006 年和 2009 年，配新版本的研发带来了排版渲染引擎专利申请量的顶峰这充分显示了微软在新版本的改进中对浏览器排版渲染引擎技术的重视。\nJavaScript 引擎是用来渲染 JavaScript 的，JavaScript 的渲染速度越快，动态网页的展示也越快。众所周知，微软的 IE 浏览器实现完全支持客户端 JavaScript 语言标准的时间晚于其他浏览器。因此，在这一技术分支下，相较其他浏览器企业而言，微软公司并不具有优势。在 2001~2004 年，在浏览器内核技术分支下，微软的中国专利申请量并不多，方面是由于内核为开放内核，另一方面则是由于 IE 本身一直与 Windows 捆绑销售，使得 Trident 内核长期一家独大，微软很长时间都没有更新 Trident 内核，从而导致 Trident 内核几乎与 W3C 标准脱节。\n2005 年至今，由于 IE 浏览器存在缺陷，从而使得很多用户转向其他浏览器。微软公司显然注意到了这一点，逐步重视浏览器内核的改进升级，并将由此带来的相关专利在中国进行了布局。最明显的是，2006 年和 2009 年的专利申请量大幅上升，其中关于浏览器内核中排版渲染引擎的专利申请均达到了 17 件；在 2008 年还有一件关于 JavaScript 引擎的专利申请，以上均表明 I 内核在 2005 年之后有了明显改进"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/谷歌浏览器.md"}
{"messages":[{"role":"user","content":"Web 存储"},{"role":"assistant","content":"随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，传统方式我们以document.cookie来进行存储的，但是由于其存储大小只有4k左右，并且解析也相当的复杂，给开发带来诸多不便，HTML5规范则提出解决方案。"}],"metadata":{"title":"11-HTML5详解（三）","publish":true},"filePath":"docs/guide/guid/html/10-HTML5详解（三）.md"}
{"messages":[{"role":"user","content":"H5 中有两种存储的方式"},{"role":"assistant","content":"1、\n2、 ："}],"metadata":{"title":"11-HTML5详解（三）","publish":true},"filePath":"docs/guide/guid/html/10-HTML5详解（三）.md"}
{"messages":[{"role":"user","content":"Web 存储的特性"},{"role":"assistant","content":"（1）设置、读取方便。\n（2）容量较大，sessionStorage 约5M、localStorage 约20M。\n（3）只能存储字符串，可以将对象 JSON.stringify() 编码后存储。"}],"metadata":{"title":"11-HTML5详解（三）","publish":true},"filePath":"docs/guide/guid/html/10-HTML5详解（三）.md"}
{"messages":[{"role":"user","content":"常见 API"},{"role":"assistant","content":"设置存储内容：\n```javascript\n\tsetItem(key, value);\n```\nPS：可以新增一个 item，也可以更新一个 item。\n读取存储内容：\n```javascript\n\tgetItem(key);\n```\n根据键，删除存储内容：\n```javascript\n\tremoveItem(key);\n```\n清空所有存储内容：\n```javascript\n\tclear();\n```\n根据索引值来获取存储内容：\n```javascript\n\tkey(n);\n```\nsessionStorage 的 API 举例：\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n<input type=\"text\"/>\n<button>sesssionStorage存储</button>\n<button>sesssionStorage获取</button>\n<button>sesssionStorage更新</button>\n<button>sesssionStorage删除</button>\n<button>sesssionStorage清除</button>\n<script>\n\n    //在h5中提供两种web存储方式\n\n    // sessionStorage  session（会话，会议） 5M  当窗口关闭是数据销毁  内存\n    // localStorage    20M 永久生效 ，除非手动删除  清理垃圾  硬盘上\n\n    var txt = document.querySelector('input');\n\n    var btns = document.querySelectorAll('button');\n    //        sessionStorage存储数据\n    btns[0].onclick = function () {\n        window.sessionStorage.setItem('userName', txt.value);\n        window.sessionStorage.setItem('pwd', '123456');\n        window.sessionStorage.setItem('age', 18);\n    }\n\n    //        sessionStorage获取数据\n    btns[1].onclick = function () {\n        txt.value = window.sessionStorage.getItem('userName');\n    }\n\n    //        sessionStorage更新数据\n    btns[2].onclick = function () {\n        window.sessionStorage.setItem('userName', txt.value);\n    }\n\n    //        sessionStorage删除数据\n    btns[3].onclick = function () {\n        window.sessionStorage.removeItem('userName');\n    }\n\n    //        sessionStorage清空数据\n    btns[4].onclick = function () {\n        window.sessionStorage.clear();\n    }\n</script>\n</body>\n</html>\n```\n效果如下：\n\n如上图所示，我们可以在 Storage 选项卡中查看 Session Storage 和Local Storage。\n\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n<input type=\"text\"/>\n<button>localStorage存储</button>\n<button>localStorage获取</button>\n<button>localStorage更新</button>\n<button>localStorage删除</button>\n<button>localStorage清除</button>\n\n<script>\n\n    /*\n    *  localStorage\n    *  数据存在硬盘上\n    *  永久生效\n    *  20M\n    * */\n\n    var txt = document.querySelector('input');\n    var btns = document.querySelectorAll('button');\n\n    // localStorage存储数据\n    btns[0].onclick = function () {\n        window.localStorage.setItem('userName', txt.value);\n    }\n\n    // localStorage获取数据\n    btns[1].onclick = function () {\n        txt.value = window.localStorage.getItem('userName');\n    }\n\n    // localStorage删除数据\n    btns[3].onclick = function () {\n        window.localStorage.removeItem('userName');\n    }\n\n</script>\n</body>\n</html>\n```"}],"metadata":{"title":"11-HTML5详解（三）","publish":true},"filePath":"docs/guide/guid/html/10-HTML5详解（三）.md"}
{"messages":[{"role":"user","content":"案例：记住用户名和密码"},{"role":"assistant","content":"代码：\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n<label for=\"\">\n    用户名：<input type=\"text\" class=\"userName\"/>\n</label>\n<br/><br/>\n<label for=\"\">\n    密 码：<input type=\"text\" class=\"pwd\"/>\n</label>\n<br/><br/>\n<label for=\"\">\n    <input type=\"checkbox\" class=\"check\" id=\"\"/>记住密码\n</label>\n<br/><br/>\n<button>登录</button>\n\n<script>\n    var userName = document.querySelector('.userName');\n    var pwd = document.querySelector('.pwd');\n    var chk = document.querySelector('.check');\n    var btn = document.querySelector('button');\n\n    //        当点击登录的时候 如果勾选“记住密码”，就存储密码；否则就清除密码\n    btn.onclick = function () {\n        if (chk.checked) {\n//                记住数据\n            window.localStorage.setItem('userName', userName.value);\n            window.localStorage.setItem('pwd', pwd.value);\n        } else {\n//                清除数据\n            window.localStorage.removeItem('userName');\n            window.localStorage.removeItem('pwd');\n        }\n    }\n    //        下次登录时，如果记录的有数据，就直接填充\n    window.onload = function () {\n        userName.value = window.localStorage.getItem('userName');\n        pwd.value = window.localStorage.getItem('pwd');\n\n    }\n</script>\n</body>\n</html>\n```"}],"metadata":{"title":"11-HTML5详解（三）","publish":true},"filePath":"docs/guide/guid/html/10-HTML5详解（三）.md"}
{"messages":[{"role":"user","content":"网络状态"},{"role":"assistant","content":"我们可以通过 来检测用户当前的网络状况，返回一个布尔值。另外：\n网络状态监听的代码举例：\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n<script>\n    window.addEventListener('online', function () {\n        alert('网络连接建立！');\n    });\n\n    window.addEventListener('offline', function () {\n        alert('网络连接断开！');\n    })\n</script>\n</body>\n</html>\n```"}],"metadata":{"title":"11-HTML5详解（三）","publish":true},"filePath":"docs/guide/guid/html/10-HTML5详解（三）.md"}
{"messages":[{"role":"user","content":"应用缓存"},{"role":"assistant","content":"HTML5中我们可以轻松的构建一个离线（无网络状态）应用，只需要创建一个 缓存清单文件。"}],"metadata":{"title":"11-HTML5详解（三）","publish":true},"filePath":"docs/guide/guid/html/10-HTML5详解（三）.md"}
{"messages":[{"role":"user","content":"优势"},{"role":"assistant","content":"1、可配置需要缓存的资源；\n2、网络无连接应用仍可用；\n3、本地读取缓存资源，提升访问速度，增强用户体验；\n4、减少请求，缓解服务器负担。"}],"metadata":{"title":"11-HTML5详解（三）","publish":true},"filePath":"docs/guide/guid/html/10-HTML5详解（三）.md"}
{"messages":[{"role":"user","content":" 缓存清单文件"},{"role":"assistant","content":"缓存清单文件中列出了浏览器应缓存，以供离线访问的资源。推荐使用 作为后缀名，另外还要添加MIME类型。\n\n（1）顶行写CACHE MANIFEST。\n（2）CACHE: 换行 指定我们需要缓存的静态资源，如.css、image、js等。\n（3）NETWORK: 换行 指定需要在线访问的资源，可使用通配符（也就是：不需要缓存的、必须在网络下面才能访问的资源）。\n（4）FALLBACK: 换行 当被缓存的文件找不到时的备用资源（当访问不到某个资源时，自动由另外一个资源替换）。\n格式举例1：\n\n格式举例2：\n```bash\nCACHE MANIFEST\n\n#要缓存的文件\nCACHE:\n    images/img1.jpg\n    images/img2.jpg\n\n\n#指定必须联网才能访问的文件\nNETWORK:\n     images/img3.jpg\n     images/img4.jpg\n\n\n#当前页面无法访问是回退的页面\nFALLBACK:\n    404.html\n\n```\n\n（1）例如我们创建一个名为 的文件。例如：\ndemo.appcache：\n```bash\nCACHE MANIFEST\n\n# 注释以#开头\n#下面是要缓存的文件\nCACHE:\n    http://img.smyhvae.com/2016040101.jpg\n```\n（2）在需要应用缓存在页面的根元素(html)里，添加属性manifest=\"demo.appcache\"。路径要保证正确。例如：\n```html\n<!DOCTYPE html>\n<html manifest=\"demo.appcache\">\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n<img src=\"http://img.smyhvae.com/2016040101.jpg\" alt=\"\"/>\n</body>\n</html>\n```"}],"metadata":{"title":"11-HTML5详解（三）","publish":true},"filePath":"docs/guide/guid/html/10-HTML5详解（三）.md"}
{"messages":[{"role":"user","content":"css图表"},{"role":"assistant","content":"import Chart2d from \"@/page/css/chart/2dChart\";\nimport Pie from \"@/page/css/chart/pie\";\nimport PointChart from \"@/page/css/chart/dataPoint\";\nimport ThreeDChart from \"@/page/css/chart/threeDChart\";\nCSS 实现柱状图\n<Chart2d  />"}],"metadata":{},"filePath":"docs/guide/vr/chart.mdx"}
{"messages":[{"role":"user","content":"css饼图"},{"role":"assistant","content":"<Pie  />"}],"metadata":{},"filePath":"docs/guide/vr/chart.mdx"}
{"messages":[{"role":"user","content":"pointChart"},{"role":"assistant","content":"<PointChart  />"}],"metadata":{},"filePath":"docs/guide/vr/chart.mdx"}
{"messages":[{"role":"user","content":"折线图"},{"role":"assistant","content":"点与点的连接，实际上是斜边，我们使用三角函数进行处理"}],"metadata":{},"filePath":"docs/guide/vr/chart.mdx"}
{"messages":[{"role":"user","content":"3d柱状图"},{"role":"assistant","content":"<ThreeDChart  />"}],"metadata":{},"filePath":"docs/guide/vr/chart.mdx"}
{"messages":[{"role":"user","content":"css的高级技巧"},{"role":"assistant","content":"import Css3d from \"@page/css/css3d/matrix3d\";\nimport Animation from \"@page/css/css3d/animation\";\nimport Animation3d from \"@page/css/css3d/3dAnimation\";\nimport Gradient from \"@page/css/css3d/Gradient\""}],"metadata":{},"filePath":"docs/guide/vr/css.mdx"}
{"messages":[{"role":"user","content":"Transform 字体模糊问题"},{"role":"assistant","content":"transform2D 我们一般用于 2D 场景的变换，transform3D 用于 3D 场景的变换，但是在一些特殊场景 transform2D 会字体模糊问题，比如使用transform: translate(-50%, -50%)。\n导致字体模糊的原因是：这个变换会触发浏览器对元素进行硬件加速。在某些浏览器中，硬件加速可能会导致更简化的文本渲染方法，从而出现字体模糊的情况。\n解决这个问题的方法之一是使用 transform: translate3d(-50%, -50%, 0)，将元素的变换转换为 3D 变换。这样可以强制浏览器使用更高质量的文本渲染，从而避免字体模糊的问题。\n另外，还可以尝试使用 backface-visibility: hidden 属性，将元素的背面隐藏起来，这有助于提高字体的清晰度。"}],"metadata":{},"filePath":"docs/guide/vr/css.mdx"}
{"messages":[{"role":"user","content":"matrix3d"},{"role":"assistant","content":"可以发现，matrix3d() API 中，有16个参数，但是他的参数的顺序和我们上面给出的顺序并不相同，上面给出的是数学中的矩阵的正常格式：\n行（row）是横向的，列（column）是纵先的。但是Web当中矩阵是刚好相反，即列是横向的，行是纵向的。类似下面这样：\n<img src=\"https://i-blog.csdnimg.cn/blog_migrate/81f887f9443d7a238c906238650545d9.png#pic_center\" alt=\"在这里插入图片描述\" referrerPolicy=\"no-referrer\" />\n所以大家应该注意，前文所有的推导结果，放到matrix3d中，顺序应该是下面这样：\nmatrix3d(a00,a10,a20,a30,a01,a11,a21,a31,a02,a12,a22,a32,a03,a13,a23,a33)。\n<img src=\"https://i-blog.csdnimg.cn/blog_migrate/f0ac87c4896267ff2fa0e004bd62b15b.png#pic_centernpm install antd --save\" alt=\"在这里插入图片描述\" referrerPolicy=\"no-referrer\" />\n\n<Css3d  />"}],"metadata":{},"filePath":"docs/guide/vr/css.mdx"}
{"messages":[{"role":"user","content":"Animation 动画"},{"role":"assistant","content":"<Animation  />\n```tsx\nimport styles, { keyframes, css } from \"styled-components\";\nexport default () => {\n  let a1 = (props: { i: number }) => {\n    let { i } = props;\n    return keyframes`0% {\n    transform: translate(${30 * (i - 1)}px, 0);\n  }\n\n  30% {\n    transform: translate(10px, ${10 * i}px) rotate(60deg) scale(${i * 0.009});\n  }\n\n  60% {\n    transform: translate(${10 * i}px, 10px) rotate(120deg) scale(${i * 0.009});\n  }\n\n  80% {\n    transform: translate(0,${30 * (i - 1)}px) scale(${i * 0.009});\n  }\n\n  100% {\n    transform: translate(${30 * (i - 1)}px, 0);\n  }`;\n  };\n\n  // animation: ${a1} 4s infinite;\n  let BoxItem = styles.div<{ i: number; intI: number }>`width: 60px;\n  height: 60px;\n  border-radius: 12px;\n  position: absolute;\n \n  ${props => css`\n    &:nth-child(${props.i}) {\n      background-color: hsl(${40 + 3 * props.i}, 55%, 50%);\n      transform: translate(${30 * (props.i - 1)}px, 0);\n\n      animation: ${a1(props)} 4s infinite;\n      animation-delay: ${props.i * 0.02}s;\n    }\n  `}\n  `;\n  return (\n    <div className=\"mt-10 h-[400px] scale-[20%]  hover:scale-100\">\n      {Array.from({ length: 4 }).map((_, intI) => {\n        return (\n          <div key={intI} style={{ transform: `rotate(${intI * 90}deg)` }}>\n            {Array.from({ length: 40 }, (_, index) => (\n              <BoxItem key={index} i={index + 1} intI={intI + 1}></BoxItem>\n            ))}\n          </div>\n        );\n      })}\n    </div>\n  );\n};\n\n```"}],"metadata":{},"filePath":"docs/guide/vr/css.mdx"}
{"messages":[{"role":"user","content":"3d动画"},{"role":"assistant","content":"<Animation3d  />\n我画了一个简单的流程图讲述其核心概念\n<img src=\"https://ik.imagekit.io/Manshawar/ferris_8PiNzixa3\" />\n这里是代码:\n```tsx\n\nimport styles, { keyframes, css } from \"styled-components\";\nlet colorList = [\"#222\", \"#401a2a\", \"#741a38\", \"#9b123c\", \"#c10a40\"].reverse();\nexport default () => {\n  let Container = styles.div`overflow: hidden;height:700px; perspective: 1000px; position: relative;transform-style: preserve-3d;`;\n  let Assembly = styles.div` transform-style: preserve-3d; transform:rotateX(-35deg) rotateY(-45deg);padding-top: 20px;`;\n  let Cube = styles.div<{ color: string; index: number; rect: number }>`\n  width: ${props => props.rect}px;\n  height: ${props => props.rect}px;\n  background:${props => props.color};\n  position: relative;\n  transform-style: preserve-3d; \n &:before,\n&:after {\n  width: inherit;\n  height: inherit;\n  content:\"\";\n    background:${props => props.color};\n    width: ${props => props.rect}px;\n  height: ${props => props.rect}px;\n    position: absolute;\n    left:0;\n    top:0; \n    display:block;\n    filter: brightness(1.15);\n}\n&:after{\ntransform:rotateX(-90deg);\ntransform-origin: center top;\n}\n&:before{\ntransform:rotateY(-90deg);\ntransform-origin: center right\n\n}\n  `;\n  let t = 2;\n  let T3d = styles.div`transform-style: preserve-3d;`;\n  let move = keyframes`from{\ntransform:translate(0em) scale3d(1, 1, 1);\n  }\n  to{\ntransform:translate(7em) scale3d(0, 0, 0);\n  }\n  `;\n  let switchAnimation = keyframes`\n    to {\n    transform: rotateY(1turn); // 在最后一帧的时候将做360旋转\n  }\n  `;\n  let Switch_in = styles(T3d)`\n  animation: ${switchAnimation} ${4 * t}s steps(4) infinite;\n  `;\n  let Move = styles(T3d)`\n animation: ${move} ${t}s ease-in-out infinite;;\n  `;\n  let Move_out = styles(Switch_in)`\n   animation-direction: reverse;\n   animation-timing-function: steps(4, start);\n  `;\n  return (\n    <Container>\n      <Assembly className=\"flex flex-col justify-start w-full h-full items-center gap-10 absolute top-0 left-0\">\n        {colorList.map((item, index) => {\n          return <Cube color={item} index={index} rect={30}></Cube>;\n        })}\n      </Assembly>\n      <Assembly className=\"flex flex-col justify-start w-full h-full items-center gap-10 absolute top-0 left-0\">\n        {colorList.map((item, index) => {\n          return (\n            <Move_out>\n              <Move>\n                <Switch_in>\n                  <Cube color={item} index={index} rect={30}></Cube>\n                </Switch_in>\n              </Move>\n            </Move_out>\n          );\n        })}\n      </Assembly>\n    </Container>\n  );\n};\n\n```"}],"metadata":{},"filePath":"docs/guide/vr/css.mdx"}
{"messages":[{"role":"user","content":"渐变"},{"role":"assistant","content":"<Gradient  />"}],"metadata":{},"filePath":"docs/guide/vr/css.mdx"}
{"messages":[{"role":"user","content":"伪类 :is 和 :where的逻辑函数和条件函数"},{"role":"assistant","content":":is() 和 :where() 是 CSS 中的伪类选择器，它们允许我们以一种高效的方式对一系列选择器进行分组和定位。\n我们看下下面代码演示，仔细体会简化代码：\n```css\nbutton.foces, button:focus {  } \n->\nbutton:is(.focus, :focus) {}\n\ncontent > h1, content > h2, content > h3, content > h4 {}\n->\ncontent > :is(h1, h2, h3, h4)\n\n```\n两者唯一区别在于权重，:where 的权重为 0，:is 作为伪类选择器的权重为 10。"}],"metadata":{},"filePath":"docs/guide/vr/css.mdx"}
{"messages":[{"role":"user","content":"用 100 行代码，用 koa 写一个支持 vue 和 react 的赛博脚手架 😼"},{"role":"assistant","content":"如何有效的保证不挂科，当然是背知识点啦；😏\n同理，如何去理解脚手架呢，我的理解是以最低限度的可用性，去搭建一个脚手架，让我们放弃哪些反复的钩子，plugin，以及一些其他的配置。我会在一个中间件中，来完成最低限度的解析代码的工作，希望能帮助大家去理解脚手架，此项目参考于 mini-vite 和 vite-plugin-vue；\n我们 vite 也有自己的垃圾佬\n这个项目是我在写 miniVite 的时候产生的想法，所以用的是同一个库，认准 ,就好了;\n这个是仓库地址，既然来都来了，给个 star 吧\n<img src=\"https://memeprod.ap-south-1.linodeobjects.com/user-template/a1e08e595e29eef80af9737fefd90d21.png\" />\n\n这里是目录结构,以下是和当前项目相关的，专注于这些文件就好\n```json\n|-- koaMinivite,\n      |-- .gitignore,\n      |-- cyber.html,\n      |-- ...,\n      |-- src,\n          |-- cyber.ts,\n          |-- cyber,\n          |   |-- a.ts,\n          |   |-- App.vue,\n          |   |-- help.js,\n          |   |-- react.tsx,\n          |   |-- vue.ts,\n          |-- ...,\n          |-- node,\n              |-- ...,\n              |-- optimizer,\n              |   |-- index.ts,\n              |   |-- preBundlePlugin.ts,\n              |   |-- scanplugin.ts,\n\n\n```"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/koa中间件搭建脚手架(支持tsx,vue).mdx"}
{"messages":[{"role":"user","content":"一、koa 搭建"},{"role":"assistant","content":"首先来看我们的入口文件 ;这个文件是核心文件，我们来看看他做了什么；\n```ts\nimport Koa from \"koa\";\nimport { optimize } from \"./node/optimizer\";\nconst app = new Koa();\napp.use(async (ctx, next) => {\n  //中间件区域\n  return next();\n});\napp.listen(8954, async () => {\n  await optimize(root, \"src/cyber/react.tsx\");\n  await optimize(root, \"src/cyber/vue.ts\");\n  console.log(\"http://localhost:8954 \");\n});\n```"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/koa中间件搭建脚手架(支持tsx,vue).mdx"}
{"messages":[{"role":"user","content":"二、预构建"},{"role":"assistant","content":"我们看到 开启服务的时候为什么会在回调中处理一个 optimize 的函数呢；\n我们对代码会进行一个预构建；详细的解释请移步 ;\n我现在对其进行一个通俗的解释\n这里是 react 包的 index.js\n```js\n\"use strict\";\nif (process.env.NODE_ENV === \"production\") {\n  module.exports = require(\"./cjs/react.production.min.js\");\n} else {\n  module.exports = require(\"./cjs/react.development.js\");\n}\n```\n这是两种模块类型，一个是esm，一个是cjs；就像天堂的白鸽不会亲吻田野的乌鸦，es模块也不会引入cjs模块； 你拿前朝的🗡，怎么能斩本朝的官\n<img src=\"https://th.bing.com/th/id/OIP.99MBNn0mDCjAAELdfV29fAHaEL?rs=1&pid=ImgDetMain\" />\n那我们要解决以下几个问题\nesbuild 可以通过打包来解决这些问题，朋克风的解释： 不打灰怎么浇筑混凝土；\n我们的目的是想要将所有要用的包，可以理解成后面砌砖需要多少水泥，都拖到工地上来；找个地方，把他们放哪里让我们好使用，\n这个文件是 nodemodule 包中的.vite 文件，你可以去任何一个 vite 项目中去寻找他，我们这里改一下名字,就叫\".m-vite\"；\n这里是 optimizer 的代码\n```ts\nimport path from \"path\";\nimport { build } from \"esbuild\";\nimport { scanPlugin } from \"./scanplugin\";\nimport { preBundlePlugin } from \"./preBundlePlugin\";\nimport { PRE_BUNDLE_DIR } from \"../contants\";\nexport async function optimize(root: string, other?: string) {\n  // 1. 确定入口\n  // 2. 从入口处扫描依赖\n  // 3. 预构建依赖;\n  const deps = new Set<string>();\n  const entry = path.resolve(root, other ? other : \"src/client/main.tsx\");\n  await build({\n    entryPoints: [entry],\n    bundle: true,\n    write: false,\n    plugins: [scanPlugin(deps)]\n  });\n  await build({\n    entryPoints: [...deps],\n    write: true,\n    bundle: true,\n    format: \"esm\",\n    splitting: true,\n    outdir: path.resolve(root, PRE_BUNDLE_DIR)//PRE_BUNDLE_DIR = \".m-vite\",\n    plugins: [preBundlePlugin(deps)]\n  });\n  console.log(\"需要构建的依赖项\", deps)\n}\n\n```\n他经历了两次 build，第一次是扫描依赖不生成文件，第二次是预构建依赖构建依赖，输出至 node_modules/.m-vite，\n至于插件的详解 请移步\n;\n我们这里经历了两次预构建\n```ts\nawait optimize(root, \"src/cyber/react.tsx\");\nawait optimize(root, \"src/cyber/vue.ts\");\n```\n因为这个项目会同时执行 react 和 vue，所以需要预构建两次，当然你可以自己选择，只需要在入口处写上对应的文件名即可;\n这个是我们预构建后的目录\n<img src=\"/vite/cyber/.m-vite.png\" />\n打包后的他们支持 es 模块语法了，我们接下来就会去其中提取相应的依赖"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/koa中间件搭建脚手架(支持tsx,vue).mdx"}
{"messages":[{"role":"user","content":"transformHtml 渲染初始页面"},{"role":"assistant","content":"开始我们中间件的第一步，让我们获取到了 req.url 后该做什么，当页面没有任何路径的时候，我们会获取到 ，我们就在初始路径下，给他返回一个 html 文件，让页面去加载他\n```ts\napp.use(async (ctx, next) => {\n  const { req, res } = ctx;\n  if (req.url === \"/\") {\n    const realPath = path.join(process.cwd(), \"/cyber.html\");\n    //transformHtml\n    if (await fs.pathExists(realPath)) {\n      let code = await fs.readFile(realPath, \"utf-8\");\n      res.setHeader(\"Content-Type\", \"text/html\");\n      res.end(code);\n    }\n  }\n});\n```\n我们这里去读取了我们根目录下的 cyber.html 文件，我们使用了 库;这个库的 api 基本和 fs 原生的一致，但又更好的性能，和更加丰富的 api，我们检测是否存在该路径，如果存在则使用 的格式去读取，并设置 的请求头返回给我们的服务器；不出意外的话，你应该可以看到一个 页面了\n这里是 文件的内容\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n\n  <body>\n    <div id=\"react\"></div>\n    <script type=\"module\" src=\"src/cyber/react.tsx\"></script>\n\n    <div id=\"vue\"></div>\n    <script type=\"module\" src=\"src/cyber/vue.ts\"></script>\n  </body>\n</html>\n```\n我们可以看到，他会引入一个 react.tsx 文件，可是我们的服务器还没又办法去处理他，别慌，我们来进行下一步中间件的书写\n```ts\napp.use(async (ctx, next) => {\n  const { req, res } = ctx;\n  if (req.url === \"/\") {\n    const realPath = path.join(process.cwd(), \"/cyber.html\");\n    //transformHtml\n    if (await fs.pathExists(realPath)) {\n      let code = await fs.readFile(realPath, \"utf-8\");\n      res.setHeader(\"Content-Type\", \"text/html\");\n      res.end(code);\n    }\n  } else if (req.method === \"GET\" || /\\.(?:j|t)sx?$|\\.mjs$|\\.vue$/.test(req.url as string)) {\n    //resolve\n    const realPath = path.join(process.cwd(), req.url + \"\");\n    //loader\n    if (await fs.pathExists(realPath)) {\n      let code = await fs.readFile(realPath, \"utf-8\");\n      let exname =\n        path.extname(req.url as string).slice(1) === \"vue\"\n          ? \"js\"\n          : path.extname(req.url as string).slice(1);\n      let { code: transformedCode, map } = await esbuild.transform(code, {\n        target: \"esnext\",\n        format: \"esm\",\n        sourcemap: true,\n        loader: exname as \"js\" | \"ts\" | \"jsx\" | \"tsx\",\n      });\n      //  transform\n      const ms = new MagicString(transformedCode);\n      await init;\n      const [imports, exports] = parse(transformedCode);\n      for (const importInfo of imports) {\n        const { n: importedId, s: start, e: end } = importInfo;\n        if (!importedId) continue;\n        if (/^[\\w@][^:]/.test(importedId)) {\n          let realPath = path.join(\"/\", \"node_modules\", \".m-vite\", `${importedId}.js`);\n          realPath = realPath.replace(/\\\\/g, \"/\");\n          ms.overwrite(start, end, realPath);\n          code = ms.toString();\n        }\n      }\n\n      res.setHeader(\"Content-Type\", \"application/javascript\");\n\n      res.statusCode = 200;\n      res.end(code);\n    }\n  }\n  return next();\n});\n```\n我们来进行下一步的处理，这个是 vite 的 load 阶段,去读取相应的文件"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/koa中间件搭建脚手架(支持tsx,vue).mdx"}
{"messages":[{"role":"user","content":"resolve 和 loader 解析文件路径并读取他"},{"role":"assistant","content":"```ts\nif (req.method === \"GET\" || /\\.(?:j|t)sx?$|\\.mjs$|\\.vue$/.test(req.url as string)) {\n  const realPath = path.join(process.cwd(), req.url + \"\");\n}\n```\n这个阶段我们主要做的是筛选和拼接路径，我们只允许 js,ts,jsx,tsx,vue,mjs 文件传入，我们使用正则对其过滤\n然后再拼接出他的真正路径出来；我们 vite 的 resolve 阶段 就是做的这么一项工作\n既然知道地址了，我们就可以和上文中的一样，去读取他\n```ts\nif (await fs.pathExists(realPath)) {\n  let code = await fs.readFile(realPath, \"utf-8\");\n  let { code: transformedCode, map } = await esbuild.transform(code, {\n    target: \"esnext\",\n    format: \"esm\",\n    sourcemap: true,\n    loader: path.extname(req.url as string).slice(1) as \"js\" | \"ts\" | \"jsx\" | \"tsx\",\n  });\n}\n```\n我们可以看到，我们读取他后，使用 esbuild 对其进行了转换，我们这一步是将 ts 文件或者 tsx 文件转换为 esm 模块；其中 loader 是我们目前文件的后缀， 的优势就是可以直接被 esbuild 解析，可以帮我们节省很多功夫， 则需要花费大量的精力进行书写了\n我们得到的 就是我们处理好的 文件了，这时候他是一个原生的 es6 模块；但问题随之而来"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/koa中间件搭建脚手架(支持tsx,vue).mdx"}
{"messages":[{"role":"user","content":"transform 转换"},{"role":"assistant","content":"<img src=\"/vite/cyber/bare.png\" />\n我们的浏览器可不认识 引入的包；这时候我们需要对其进行改写，上面的预构建的文件就有了用武之地；\n```ts\nconst ms = new MagicString(transformedCode);\nawait init;\nconst [imports, exports] = parse(transformedCode);\nfor (const importInfo of imports) {\n  const { n: importedId, s: start, e: end } = importInfo;\n\n  if (!importedId) continue;\n  if (/^[\\w@][^:]/.test(importedId)) {\n    let realPath = path.join(\"/\", \"node_modules\", \".m-vite\", `${importedId}.js`);\n    realPath = realPath.replace(/\\\\/g, \"/\");\n    // ms.overwrite(start, end, realPath);\n    code = ms.toString();\n  }\n}\n```\n我们使用 这个库 ， 一个 ;出来，他的功能是去修改我们的代码；这个库是 官方使用的\n然后使用 创建引入和导出的分析环境; 这个工具库可以帮助我们分析一个模块的导入导出，并返回相应的 ;\n```ts\n{ n: 'react', t: 1, s: 43, e: 48, ss: 24, se: 49, d: -1, a: -1 }\n{\n  n: 'react-dom/client',\n  t: 1,\n  s: 79,\n  e: 95,\n  ss: 51,\n  se: 96,\n  d: -1,\n  a: -1\n}\n```\n这个是我们分析出的 imports 的值，我们只需要关注三点； 和 和 ； 是包名 是开始位置 是结束位置;知道这几个值我们就能改写原来的代码；\n```ts\nlet realPath = path.join(\"/\", \"node_modules\", \".m-vite\", `${importedId}.js`);\n```\n将代码改为我们想要的路径，然后返回即可；这是包的位置就指向的了 文件中了\n```js\nimport a from \"./a.ts\";\nimport React from \"/node_modules/.m-vite/react.js\";\nimport { createRoot } from \"/node_modules/.m-vite/react-dom/client.js\";\nconsole.log(React, a);\nconst App = () => /* @__PURE__ */ React.createElement(\"div\", null, \"react\");\nconst root = createRoot(document.getElementById(\"react\"));\nroot.render(/* @__PURE__ */ React.createElement(App, null));\n```\n这个就是最终返回的文件;esbuild 原生支持 ； 与之相比又很反人类了;\n```ts\nres.setHeader(\"Content-Type\", \"application/javascript\");\nres.statusCode = 200;\nres.end(code);\n```\n最后将其作为 js 文件返回，你的 react 就成了，但是我们是否还遗忘了一个东西, 该怎么处理?"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/koa中间件搭建脚手架(支持tsx,vue).mdx"}
{"messages":[{"role":"user","content":"vue-loader"},{"role":"assistant","content":"的处理是一把心酸，一把泪，为了处理 ；跑去读了 的源码；\n\n其中难点就在于 sfc 怎么处理；怎么讲单文件拆分成三块进行处理，当然，我只拆了两块，华生，你发现了盲点。整个项目没有处理 的东西，哈哈 😄；当然我们先学会处理 js，css 会好处理很多\n先叠个甲，这个 的风格也是垃圾佬风格 😏\n第一步，我们需要拆分 sfc 单文件组件\n该怎么拆分呢，从 load 开始读\n<a href=\"https://github.com/vitejs/vite-plugin-vue/blob/main/packages/plugin-vue/src/index.ts\" />\n```js\nload(id, opt) {\n//...\n      if (query.vue) {\n        if (query.src) {\n          return fs.readFileSync(filename, 'utf-8')\n        }\n        const descriptor = getDescriptor(filename, options.value)!\n        let block: SFCBlock | null | undefined\n        if (query.type === 'script') {\n          // handle <script> + <script setup> merge via compileScript()\n          block = resolveScript(\n            descriptor,\n            options.value,\n            ssr,\n            customElementFilter.value(filename),\n          )\n        } else if (query.type === 'template') {\n          block = descriptor.template!\n        } else if (query.type === 'style') {\n          block = descriptor.styles[query.index!]\n        } else if (query.index != null) {\n          block = descriptor.customBlocks[query.index]\n        }\n        if (block) {\n          return {\n            code: block.content,\n            map: block.map as any,\n          }\n        }\n      }\n    },\n\n```\n从 我找到了以下两个位置\n代码位置:\n<img src=\"/vite/cyber/parse.png\" />\n注意这个 ;为了寻找 的位置，我寻找到了这个位置\n代码位置:\n<img src=\"/vite/cyber/compiler.png\" />\n我们拿到了两个信息 一个是 一个是 ;\n既然如此 我们就 引入 parse 对其进行解析\n```js\nconst vueAst = vueParse(code);\n```\n我们得到了 vue 的 ast 语法树，代码成功的被我们拆分了;以下的代码块都经过简化\n```js\n{\n  descriptor: {\n    filename: 'anonymous.vue',\n    source: `...`\n    template: {\n      type: 'template',\n      content:  `...`,\n      loc: [Object],\n      attrs: {},\n      ast: [Object],\n      map: [Object]\n    },\n    script: {\n      type: 'script',\n      content:  `...`,\n      loc: [Object],\n      attrs: [Object],\n      lang: 'ts',\n      map: [Object]\n    },\n    scriptSetup: {\n      type: 'script',\n      content:  `...`,\n      loc: [Object],\n      attrs: [Object],\n      setup: true,\n      lang: 'ts'\n    },\n    styles: [],\n    customBlocks: [],\n    cssVars: [],\n    slotted: false,\n    shouldForceReload: [Function: shouldForceReload]\n  },\n  errors: []\n}\n\n```\n接下来就是转换代码了；我们接着 load 钩子开始读\n从 我又找到了以下位置\n；\n我们引入 对 script 标签进行处理;\n得到结果\n```js\n{\n  type: 'script',\n  content: ...,\n  loc: {\n  ....\n  },\n  attrs: { setup: true, lang: 'ts' },\n  setup: true,\n  lang: 'ts',\n  bindings: {\n    defineComponent: 'setup-const',\n    ref: 'setup-const',\n    count: 'setup-let',\n    add: 'setup-const'\n  },\n  imports: [Object: null prototype] {\n    defineComponent: {\n      isType: false,\n      imported: 'defineComponent',\n      local: 'defineComponent',\n      source: 'vue',\n      isFromSetup: false,\n      isUsedInTemplate: false\n    },\n    ref: {\n      isType: false,\n      imported: 'ref',\n      local: 'ref',\n      source: 'vue',\n      isFromSetup: true,\n      isUsedInTemplate: false\n    }\n  },\n  map: []\n    ,\n    names: [],\n    mappings: '...'\n  },\n  scriptAst: [\n    Node {\n      type: 'ImportDeclaration',\n      start: 2,\n      end: 40,\n      loc: [SourceLocation],\n      importKind: 'value',\n      specifiers: [Array],\n      source: [Node],\n      attributes: []\n    },\n    Node {\n      type: 'ExportDefaultDeclaration',\n      start: 44,\n      end: 222,\n      loc: [SourceLocation],\n      exportKind: 'value',\n      declaration: [Node]\n    }\n  ],\n  scriptSetupAst: [\n    Node {\n      type: 'ImportDeclaration',\n      start: 2,\n      end: 28,\n      loc: [SourceLocation],\n      importKind: 'value',\n      specifiers: [Array],\n      source: [Node],\n      attributes: []\n    },\n    Node {\n      type: 'VariableDeclaration',\n      start: 30,\n      end: 49,\n      loc: [SourceLocation],\n      declarations: [Array],\n      kind: 'let'\n    },\n    Node {\n      type: 'VariableDeclaration',\n      start: 51,\n      end: 92,\n      loc: [SourceLocation],\n      declarations: [Array],\n      kind: 'const'\n    }\n  ],\n  dep\n\n```\n如法炮制 找到 函数，对模板代码进行处理\n```js\n   let temp = compileTemplate({ source: vueAst.descriptor.template?.content as string, filename: realPath, id: req.url,  });\n```\n<img src=\"/vite/cyber/tempSfc.png\" />\n这里是template 的编译结果\n```js\n{\n  code: 'import { toDisplayString as _toDisplayString, createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\"\\n' +\n    '\\n' +\n    'export function render(_ctx, _cache) {\\n' +\n    '  return (_openBlock(), _createElementBlock(\"div\", null, [\\n' +\n    '    _createElementVNode(\"div\", null, \"hello Vue \" + _toDisplayString(_ctx.count), 1 /* TEXT */),\\n' +\n    '    _createElementVNode(\"button\", {\\n' +\n    '      onClick: _cache[0] || (_cache[0] = (...args) => (_ctx.add && _ctx.add(...args)))\\n' +\n    '    }, \"add\")\\n' +\n    '  ]))\\n' +\n    '}',\n  ast: {\n    type: 0,\n    source: '\\r\\n' +\n      '  <div>\\r\\n' +\n      '    <div>hello Vue {{ count }}</div>\\r\\n' +\n      '    <button  @click=\"add\">add</button>\\r\\n' +\n      '  </div>\\r\\n',\n    children: [ [Object] ],\n    helpers: Set(4) {\n      Symbol(toDisplayString),\n      Symbol(createElementVNode),\n      Symbol(openBlock),\n      Symbol(createElementBlock)\n    },\n    components: [],\n    directives: [],\n    hoists: [],\n    imports: [],\n    cached: [ [Object] ],\n    temps: 0,\n    codegenNode: {\n      type: 13,\n      tag: '\"div\"',\n      props: undefined,\n      children: [Array],\n      patchFlag: undefined,\n      dynamicProps: undefined,\n      directives: undefined,\n      isBlock: true,\n      disableTracking: false,\n      isComponent: false,\n      loc: [Object]\n    },\n    loc: {\n      start: [Object],\n      end: [Object],\n      source: '\\r\\n' +\n        '  <div>\\r\\n' +\n        '    <div>hello Vue {{ count }}</div>\\r\\n' +\n        '    <button  @click=\"add\">add</button>\\r\\n' +\n        '  </div>\\r\\n'\n    },\n    transformed: true,\n    filters: []\n  },\n  preamble: '',\n  source: '\\r\\n' +\n    '  <div>\\r\\n' +\n    '    <div>hello Vue {{ count }}</div>\\r\\n' +\n    '    <button  @click=\"add\">add</button>\\r\\n' +\n    '  </div>\\r\\n',\n  errors: [],\n  tips: [],\n  map: {\n    version: 3,\n    sources: [ 'D:\\\\code\\\\study\\\\vite\\\\minivite\\\\koaVite\\\\src\\\\cyber\\\\App.vue' ],\n    names: [ 'count' ],\n    mappings: ';;;wBACE,oBAGM;IAFJ,oBAAgC,aAA3B,YAAU,oBAAGA,UAAK;IACvB,oBAAkC;MAAxB,OAAK,0CAAE,6BAAG;OAAE,KAAG',\n    sourcesContent: [\n      '\\r\\n' +\n        '  <div>\\r\\n' +\n        '    <div>hello Vue {{ count }}</div>\\r\\n' +\n        '    <button  @click=\"add\">add</button>\\r\\n' +\n        '  </div>\\r\\n'\n    ]\n  }\n}\n\n```\n我们分割了其sfc的代码后，我们该怎么做呢；我们来看看一个vue3的项目,服务器返回的vue文件是什么样子\n```js\nimport { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/src/views/index.vue\");import { defineComponent as _defineComponent } from \"/node_modules/.vite/deps/vue.js?v=eaf793ab\";\nimport { ElButton } from \"/node_modules/.vite/deps/element-plus.js?v=eaf793ab\";\nimport { testApi } from \"/src/api/index.js\";\nimport { defineComponent } from \"/node_modules/.vite/deps/vue.js?v=eaf793ab\";\nconst __default__ = defineComponent({\n  name: \"\"\n});\nconst _sfc_main = /* @__PURE__ */ _defineComponent({\n  ...__default__,\n  setup(__props, { expose: __expose }) {\n    __expose();\n    const sendTEst = async () => {\n      let res = await testApi();\n      console.log(\"ok\", res);\n    };\n    const __returned__ = { sendTEst, get ElButton() {\n      return ElButton;\n    } };\n    Object.defineProperty(__returned__, \"__isScriptSetup\", { enumerable: false, value: true });\n    return __returned__;\n  }\n});\nimport { createTextVNode as _createTextVNode, withCtx as _withCtx, createVNode as _createVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"/node_modules/.vite/deps/vue.js?v=eaf793ab\";\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", null, [\n    _createVNode($setup[\"ElButton\"], { onClick: $setup.sendTEst }, {\n      default: _withCtx(() => _cache[0] || (_cache[0] = [\n        _createTextVNode(\"hello world\")\n      ])),\n      _: 1\n      /* STABLE */\n    }),\n    _cache[1] || (_cache[1] = _createTextVNode(\" 1111111 \"))\n  ]);\n}\n_sfc_main.__hmrId = \"b301384e\";\ntypeof __VUE_HMR_RUNTIME__ !== \"undefined\" && __VUE_HMR_RUNTIME__.createRecord(_sfc_main.__hmrId, _sfc_main);\nimport.meta.hot.on(\"file-changed\", ({ file }) => {\n  __VUE_HMR_RUNTIME__.CHANGED_FILE = file;\n});\nimport.meta.hot.accept((mod) => {\n  if (!mod) return;\n  const { default: updated, _rerender_only } = mod;\n  if (_rerender_only) {\n    __VUE_HMR_RUNTIME__.rerender(updated.__hmrId, updated.render);\n  } else {\n    __VUE_HMR_RUNTIME__.reload(updated.__hmrId, updated);\n  }\n});\nimport _export_sfc from \"/@id/__x00__plugin-vue:export-helper\";\nexport default /* @__PURE__ */ _export_sfc(_sfc_main, [[\"render\", _sfc_render], [\"__file\", \"D:/code/work/project/vite-project/src/views/index.vue\"]]);\n\n```\n```js\nexport default (sfc, props) => {\n    const target = sfc.__vccOpts || sfc;\n    for (const [key,val] of props) {\n        target[key] = val;\n    }\n    return target;\n}\n```\n我在阅读源码的时候，发现vue3实际上是通过默认暴露一个vue对象，这个vue对象就是其组件；我从上面源码获取到的信息就是vue文件时暴露一个 ,这个default会根据改写其render和__file属性；将其视为vue组件，我们做的第一步就是将 的 替换为 处理过后的 方法；要想将其合并，我们先将其拼接\n```js\n     let arr = [scriptRes.content, temp.code]\n        code = arr.join(\"\\n\");\n\n```\n最终我们得到混合的代码块；我们的vue-loader算是初步完成了，接下来我们去处理他的code"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/koa中间件搭建脚手架(支持tsx,vue).mdx"}
{"messages":[{"role":"user","content":"vue-plugin transform"},{"role":"assistant","content":"因为我们主要处理的是导出模块，我们可以通过 对他的export进行改写\n```js\n\n if (req.url?.endsWith(\".vue\")) {\n        for (const exportInfo of exports) {\n          const { n: exportId, s: start, e: end } = exportInfo;\n          if (!exportInfo) continue;\n\n          if (exportId === \"default\") ms.overwrite(start, end, \"other\");\n          // console.log(realPath)\n          code = ms.toString() + `let sfc_main =stdin_default.__vccOpts || stdin_default;sfc_main.render =render};\\n sfc_main.__file = \"${realPath}\";\\nexport default /* @__PURE__ */sfc_main`\n        }\n      }\n```\n我们可以看到，我将 进行了处理;这是为什么呢；因为他解析出来的代码默认就是一个 导出；我将其改写为非 导出，这个位置需要留给vue实例;然后我们对其进行改写，将 （这个是script解析的结果）的属性改写，并提供新的名字 ; 将基本信息改写完我们将其导出 ;\n这是App.vue的代码\n```vue\n<template>\n  <div>\n    <div>hello Vue {{ count }}</div>\n    <button  @click=\"add\">add</button>\n  </div>\n</template>\n<script lang=\"ts\">\nimport { defineComponent } from \"vue\";\n\nexport default defineComponent({\n  name: \"App\",\n});\n</script>\n<script setup lang=\"ts\">\nimport { ref } from \"vue\";\nlet count = ref(0);\nconst add = () => {\n  count.value++;\n};\n</script>\n\n```\n我们来看看页面\n<img src=\"/vite/cyber/noref.png\" />\n🥜，你又发现了忙点，怎么响应式数据没有\n我对其 的render参数进行打印\n<img src=\"/vite/cyber/render_arg.png\" />\n我发现其是有值的，排除法得到应该是我的render有问题；我在重新去检查 的参数，并去查询其源码\n<img src=\"/vite/cyber/tempOptions.png\" />\n我发现其 ；在vue3的源码的阅读中， 我们一般知道含有这个词的一般为传递参数；我刚好发现在script返回值的ts类型中刚好有这个值\n```ts\nexport interface SFCScriptBlock extends SFCBlock {\n    type: 'script';\n    setup?: string | boolean;\n    bindings?: BindingMetadata$1;\n    imports?: Record<string, ImportBinding>;\n    scriptAst?: _babel_types.Statement[];\n    scriptSetupAst?: _babel_types.Statement[];\n    warnings?: string[];\n    /**\n     * Fully resolved dependency file paths (unix slashes) with imported types\n     * used in macros, used for HMR cache busting in @vitejs/plugin-vue and\n     * vue-loader.\n     */\n    deps?: string[];\n}\n```\n那我们把他加进去\n```ts\n       let temp = compileTemplate({ source: vueAst.descriptor.template?.content as string, filename: realPath, id: req.url, slotted: vueAst.descriptor.slotted, compilerOptions: { bindingMetadata: scriptRes.bindings } });\n    \n\n```\n我们的代码就能正常工作了，甚至可以使用vue的开发者工具;\n<img src=\"/vite/cyber/res.gif\" />\n这里是完整的代码\n```ts\nimport Koa from \"koa\";\nimport { optimize } from \"./node/optimizer\";\nimport { init, parse } from \"es-module-lexer\";\nimport MagicString from \"magic-string\";\nimport fs from \"fs-extra\";\nimport esbuild from \"esbuild\"\nimport path from \"path\";\nimport {\n  parse as vueParse,\n  compileTemplate,\n  compileScript,\n} from \"vue/compiler-sfc\"\nconst root = process.cwd();\n\n\nconst app = new Koa();\n\napp.use(async (ctx, next) => {\n  const { req, res } = ctx;\n  if (req.url === \"/\") {\n    const realPath = path.join(process.cwd(), \"/cyber.html\");\n    //transformHtml\n    if (await fs.pathExists(realPath)) {\n      let code = await fs.readFile(realPath, \"utf-8\");\n      res.setHeader(\"Content-Type\", \"text/html\");\n      res.end(code)\n    }\n  } else if ((req.method === \"GET\" || /\\.(?:j|t)sx?$|\\.mjs$|\\.vue$/.test(req.url as string))) {\n    //resolve\n    const realPath = path.join(process.cwd(), req.url + \"\");\n    //loader\n    if (await fs.pathExists(realPath)) {\n\n      let code = await fs.readFile(realPath, \"utf-8\");\n      //vue-plugin loader\n      if (req.url?.endsWith(\".vue\")) {\n        const vueAst = vueParse(code);\n        let scriptRes = compileScript(vueAst.descriptor, { id: req.url });\n        let temp = compileTemplate({ source: vueAst.descriptor.template?.content as string, filename: realPath, id: req.url, slotted: vueAst.descriptor.slotted, compilerOptions: { bindingMetadata: scriptRes.bindings } });\n    \n \n        let arr = [scriptRes.content, temp.code]\n        code = arr.join(\"\\n\");\n\n      }\n      let exname = path.extname(req.url as string).slice(1) === \"vue\" ? \"js\" :path.extname(req.url as string).slice(1)\n      let { code: transformedCode, map } = await esbuild.transform(code, {\n        target: \"esnext\",\n        format: \"esm\",\n        sourcemap: true,\n        loader: exname as \"js\" | \"ts\" | \"jsx\" | \"tsx\",\n      });\n  \n      //  transform\n      const ms = new MagicString(transformedCode);\n      await init;\n      const [imports, exports] = parse(transformedCode);\n\n      for (const importInfo of imports) {\n        const { n: importedId, s: start, e: end } = importInfo;\n\n        if (!importedId) continue;\n        if (/^[\\w@][^:]/.test(importedId)) {\n\n          let realPath = path.join('/', \"node_modules\", \".m-vite\", `${importedId}.js`);\n          realPath = realPath.replace(/\\\\/g, \"/\");\n         \n          ms.overwrite(start, end, realPath);\n          code = ms.toString();\n        }\n\n      }\n      // vue-plugin transform\n      if (req.url?.endsWith(\".vue\")) {\n        for (const exportInfo of exports) {\n          const { n: exportId, s: start, e: end } = exportInfo;\n          if (!exportInfo) continue;\n\n          if (exportId === \"default\") ms.overwrite(start, end, \"other\");\n          // console.log(realPath)\n          code = ms.toString() + `let sfc_main =stdin_default.__vccOpts || stdin_default;sfc_main.render = function(...arg){console.log(arg);return render(...arg)};\\n sfc_main.__file = \"${realPath}\";\\nexport default /* @__PURE__ */sfc_main`\n        }\n      }\n      res.setHeader(\"Content-Type\", \"application/javascript\");\n\n\n      res.statusCode = 200;\n      res.end(code)\n    }\n  }\n  return next()\n})\n\n\napp.listen(8954, async () => {\n  await optimize(root, \"src/cyber/react.tsx\")\n  await optimize(root, \"src/cyber/vue.ts\")\n  console.log(\"http://localhost:8954 \")\n})\n\n```\n什么叫做赛博朋克？这就叫赛博朋克；垃圾佬的哲学观，又不是不能跑😎；\n靓仔；都看到这里了，点个赞再走呗"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/koa中间件搭建脚手架(支持tsx,vue).mdx"}
{"messages":[{"role":"user","content":"为什么要拆包"},{"role":"assistant","content":"将第三方库（vendors）单独打包为一个或多个文件。这样做不仅有利于浏览器缓存这些不常变动的库文件，还能避免每次应用程序代码更新后都需要重新下载整个依赖库的问题。"}],"metadata":{},"filePath":"docs/guide/project/vite工程化/产物优化---拆包.md"}
{"messages":[{"role":"user","content":"如何拆包"},{"role":"assistant","content":"在vite的4，5版本，vite拆包仅需在rollup的output中，使用manualChunks方法进行拆包，\nmanualChunks他的值有两种形式\n我们只需要通过 过滤出需要拆包的模块即可，我们可以通过正则或者js提供的原生方法，通过if判断，满足拆包条件的返回字符串即可"}],"metadata":{},"filePath":"docs/guide/project/vite工程化/产物优化---拆包.md"}
{"messages":[{"role":"user","content":"拆包的BUG"},{"role":"assistant","content":"但是在vite3版本及以下，manualChunks拆包会产生一个bug\n包之间的循环引用，manualChunks打包仅仅只根据路径id决定打包哪个chunk中（仅仅将路径包含 的模块打包到 中，殊不知，像 这种 react 本身的依赖并没有打包进 中），漏掉了间接依赖的情况，对于一些间接依赖，它并没打包至正确的chunk中"}],"metadata":{},"filePath":"docs/guide/project/vite工程化/产物优化---拆包.md"}
{"messages":[{"role":"user","content":"解决方案"},{"role":"assistant","content":"在manualChunks的判断条件中，我们对判断条件进行处理\n我们在manualChunks中可以获取到getModuleInfo方法，我们拿到这个方法就可以获取vite依赖图谱中的依赖信息\n依赖图谱:\n我们开发一个方法，对其依赖进行溯源\n```ts\n// 缓存对象\nconst cache = new Map();\n\nfunction isDepInclude (id: string, depPaths: string[], importChain: string[], getModuleInfo): boolean | undefined  {\n  const key = `${id}-${depPaths.join('|')}`;\n  // 出现循环依赖，不考虑\n  if (importChain.includes(id)) {\n    cache.set(key, false);\n    return false;\n  }\n  // 验证缓存\n  if (cache.has(key)) {\n    return cache.get(key);\n  }\n  // 命中依赖列表\n  if (depPaths.includes(id)) {\n    // 引用链中的文件都记录到缓存中\n    importChain.forEach(item => cache.set(`${item}-${depPaths.join('|')}`, true));\n    return true;\n  }\n  const moduleInfo = getModuleInfo(id);\n  if (!moduleInfo || !moduleInfo.importers) {\n    cache.set(key, false);\n    return false;\n  }\n  // 核心逻辑，递归查找上层引用者\n  const isInclude = moduleInfo.importers.some(\n    importer => isDepInclude(importer, depPaths, importChain.concat(id), getModuleInfo)\n  );\n  // 设置缓存\n  cache.set(key, isInclude);\n  return isInclude;\n};\n\n```\n目的：将该模块的相关依赖都打包至一个chunk中\n书写一个方法，接收id 过滤模组 添加缓存 返回true和false 决定该模块是否加入\n有缓存"}],"metadata":{},"filePath":"docs/guide/project/vite工程化/产物优化---拆包.md"}
{"messages":[{"role":"user","content":"介绍"},{"role":"assistant","content":"Git 的三个区域：\n在文件夹的体现如下：\n在代码中的体现如下："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"Git配置"},{"role":"assistant","content":"安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 因为每一个 Git 提交都会使用这些信息\n命令格式如下：\ngit config --global user.name 你的用户名\ngit config --global user.email 你的邮箱地址\n运行命令效果如下：\n\n配置后, 可以运行如下命令查看是否成功\n```bash\ngit config --list\n#如果信息太多，可以输入 q 退出\n```\n运行命令效果如下："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"文件右侧标记"},{"role":"assistant","content":"右侧没有标记的时候为 或 此文件/文件夹，被git忽略不跟踪变化"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"初始化空的Git仓库"},{"role":"assistant","content":"新建一个文件夹或现有的文件夹并不是 git 仓库，因为文件夹内不包含 .git 文件夹，没有被 git 管理\n可以在新文件夹或现有文件夹，运行如下命令得到 .git 文件夹，初始化成功则可让 git 开始准备管理\n```bash\n# 初始化 git 仓库, 产物: .git 文件夹 (所在文件夹\"内\"被管理)\ngit init\n\n```\n例如，在新文件夹中输入git init命令用于初始化空的git版本库\n\n初始化空的 git 仓库成功后，在项目文件夹中，开启显示隐藏文件，即可查看 .git 文件夹"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"记录更新到Git仓库"},{"role":"assistant","content":"每当完成了一个阶段的目标，想要记录下它时，就将它提交到仓库\n核心操作： ---> --->\n```bash\n# 将 index.html 添加到暂存区\ngit add index.html\n\n# 将css目录下一切添加到暂存区\ngit add css\n```\n```bash\ngit add .\n```\n```bash\ngit commit -m '提交的内容说明'\n\n```\n过程图示："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"Git日志及状态查看"},{"role":"assistant","content":"```bash\ngit log\n```\n运行命令效果如下：\n\n```bash\ngit log --oneline\n```\n运行命令效果如下：\n\n```bash\ngit status\n```\n运行命令效果如下：\n\n```bash\ngit status\n\n```\n过程图示："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"Git版本回退"},{"role":"assistant","content":"时光机，回到过去~\n```bash\ngit reset --hard 版本号\n```\n```bash\ngit log --oneline\n```\n\n```bash\ngit reset --hard 477321b\n```\n\n```bash\ngit reflog\n\n```\n运行命令效果如下："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"Git忽略文件"},{"role":"assistant","content":"有的时候，我们某些文件或文件夹不想让 git 进行跟踪管理。这时候可以在 .git 文件夹同级目录下新增 的忽略文件并写入忽略规则（此处的文件名就是 .gitignore ，不是后缀）\n项目文件夹结构如下：\n\n```bash\n# .gitignore内容：\npassword.txt\n\n其余用法：\n# 忽略文件夹\ncss\n# 忽略文件夹下的某个文件\ncss/index.js\n# 忽略文件夹下某类文件\ncss/*.js\n\n```\n根目录新建 password.txt，查看 git 追踪到了哪些变化\n```bash\ngit status\n```\n运行命令效果如下：\n\n文件在项目中可以根据脚手架自动生成，无需自己编写，当然如果你非要写，以下是Vue官方自动生成的 文件代码，可供复制使用\n```bash\n# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\npnpm-debug.log*\nlerna-debug.log*\n\nnode_modules\ndist\ndist-ssr\n*.local\n\n# Editor directories and files\n.vscode/*\n!.vscode/extensions.json\n.idea\n.DS_Store\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw?\n\n```"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"分支本质"},{"role":"assistant","content":"分支其实就是一个叫 的指针标记，每次代码提交，此 指针都会往后移动一次，保证指向的 (并且工作区里的) 都是最后一次提交\n例如：当我们输入命令： ， 指针会移动，而且 移动后，会影响工作区里的代码"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"创建分支"},{"role":"assistant","content":"```bash\n# 创建分支\ngit branch 分支名\n\n```\n该命令创建分支后不会自动切换分支，我们可以运行命令查看现在这个 .git 版本库里所有分支"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"查看当前版本库所有分支，绿色带*代表现在所处的分支"},{"role":"assistant","content":"git branch\n运行命令效果如下："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"切换分支命令"},{"role":"assistant","content":"git checkout 分支名\n运行命令效果如下：\n\n过程图示："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"分支下开发流程"},{"role":"assistant","content":"我们现在就可以在当前 reg 分支下来编写注册页面的逻辑代码，例如新建 文件，并随便写点内容。随后暂存并提交一次，这次提交的记录会出现在这里，如图\n\n以后在当前 reg 分支下开发，就会在 reg 范围内，每次提交产生一次版本记录，不会影响到别的分支"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"分支合并"},{"role":"assistant","content":"我们可以把分支里写好的代码，合并到主分支或其他分支上，步骤如下："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"切换分支"},{"role":"assistant","content":"git checkout master\n切换分支后， 指针位置如下：\n\n\ngit branch -d 分支名\n这里我们执行命令 ，执行后效果如图：\n\n可见，reg 代码提交记录已经复制到了 master (主分支) 中"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"分支删除"},{"role":"assistant","content":"假如注册功能开发完毕，代码已经合并到 master 分支上，我们已经不需要 reg 分支\n```bash\ngit branch -d 分支名\n\n```\n如果分支的修改没有被合并到其他分支上，Git 会提示一个类似以下的错误信息：\n\n在这种情况下，Git 建议你确认是否要删除这个分支。如果你确定要删除该分支并且不在乎丢失该分支的修改，你可以使用 命令来 该分支。但请注意，这样会丢失掉分支上的未合并修改"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"分支合并时的冲突问题"},{"role":"assistant","content":"在两个分支修改了同一个文件并提交过，在合并的时候，就会产生冲突\n这里模拟一次简单的冲突：\n\n\n\n发生冲突后，VSCode界面\n\n选择保留方式后，需要再次暂存提交一次"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"介绍"},{"role":"assistant","content":"远程仓库是指托管在因特网或其他网络上的 Git 仓库，可以存储我们版本库的所有记录和存档记录\n远程仓库在团队协作中发挥着重要的作用。它不仅可以充当备份存储，保护你的代码免受数据丢失的风险，还可以让团队成员之间轻松地共享代码、查看代码变更、进行代码审查等\n\n主流的远程仓库有 GitHub (gay hub)全球最大的同行交友社区，以及服务器在国内的 gitee（码云）。由于 GitHub 服务器在国外，需要科学上网或者使用其他加速工具，方便起见，这里以码云为例，供初学者参考，GitHub 流程与 gitee 类似"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"注册"},{"role":"assistant","content":"注册登录 gitee.com 网站以后，添加主邮箱为自己本地 git 仓库设置的邮箱，注意一定要相同，否则无法正确提交\n如果忘记了本地设置的邮箱地址："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"仓库新建"},{"role":"assistant","content":"可以选择创建一个远程仓库的项目 (可以多个)，创建界面如下\n\n勾选完成后选择创建，创建后, 会得到一个远程仓库的地址链接, 一般是以 结尾的地址\n地址分为两种最常用的两种传输协议：\n选择SSH路径，界面如下"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"SSH配置"},{"role":"assistant","content":"我们可以在本机一次性配置 SSH 以后免密登录，SSH 密钥组成和作用如下：\nSSH 密钥创建与使用步骤："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"初始化空仓库"},{"role":"assistant","content":"先给本地仓库配置个远程仓库的地址, 建立仓库之间的链接\n由于每次 push 操作都需要带上远程仓库的地址，十分麻烦，我们可以给仓库设置一个别名\n```bash\n# 给远程仓库设置一个别名\ngit remote add 仓库别名 仓库地址\ngit remote add origin git@gitee.com:(username)/repository.git\n\n# 删除 origin 这个别名\ngit remote remove origin\n\n# 使用 -u 记录 push 到远端分支的默认值，将来直接 git push 即可\ngit push -u 仓库别名 分支名\n\n\n```\n\n下面为实际操作举例：\n空仓库创建成功后可以在管理页面将仓库开源，当然也可以不设置开源（默认私有）"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"克隆项目"},{"role":"assistant","content":"如果你想要从远程仓库克隆一份项目代码到本地进行开发，可以使用 命令\n```bash\ngit clone [options] <repository-url> [directory]\n# directory（可选）克隆后的本地仓库所处的目录名称（默认创建与远程仓库名字相同的目录）\n\n```\n\n如果项目只有一个分支，那么以上代码执行完毕就已经克隆结束了（git clone 默认拉取 master 分支），\n```bash\ngit checkout -b 对应远程分支名\n```\n```bash\n# 每次拉取都需要指定远程仓库名和分支名\ngit pull 远程仓库名 分支名\n\n```\n```bash\ngit checkout -b 分支名 origin/分支名\n\n```\n```bash\ngit branch --set-upstream-to=origin/远程分支名 本地分支名\n\n```"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"Web 技术发展时间线"},{"role":"assistant","content":"2002年的表格布局逐渐被淘汰，是因为：表格是用来承载数据的，并不是用来划分网页结构的。\n2009年就已经推出了HTML5的草案，但直到2014年才有定稿，是因为有移动端的推动。\nH5草案的前身是叫：Web Application，最早是由 这个组织在2004年提出的。\n2007年被 W3C 组织接纳，并在 2008-01-22 发布 HTML5 的第一个草案。"}],"metadata":{"title":"08-HTML5详解","publish":true},"filePath":"docs/guide/guid/html/07-HTML5详解.md"}
{"messages":[{"role":"user","content":"什么是 HTML5"},{"role":"assistant","content":"HTML5并不仅仅只是做为HTML标记语言的一个最新版本，更重要的是它 ，成为第一个将Web做为应用开发平台的HTML语言。\nHTML5定义了一系列新元素，如新语义标签、智能表单、多媒体标签等，可以帮助开发者创建富互联网应用，还提供了一些Javascript API，如地理定位、重力感应、硬件访问等，可以在浏览器内实现类原生应用。我们甚至可以结合 Canvas 开发网页版游戏。\n：HTML5代表浏览器端技术的一个发展阶段。在这个阶段，浏览器的呈现技术得到了飞跃发展和广泛支持，它包括：HTML5、CSS3、Javascript API在内的一套技术组合。\n不等于 。 包含： 的升级版、 的升级版、 的升级版。\n： 是新一代开发 应用程序整体 。包括：HTML5，CSS3，Javascript API在内的一套 。\n：具有很强的 和体验的客户端程序。比如说，浏览博客，是比较简单的客户端；一个在线听歌的网站、即时聊天网站就是富客户端。\n\n单纯地从技术的角度讲，兼容性问题只会让开发者徒增烦恼。\n如果网页端的程序能做到PC客户端的体验，就会对后者构成威胁。"}],"metadata":{"title":"08-HTML5详解","publish":true},"filePath":"docs/guide/guid/html/07-HTML5详解.md"}
{"messages":[{"role":"user","content":"HTML5 的应用场景"},{"role":"assistant","content":"列举几个HTML5 的应用场景：\n（1）极具表现力的网页：内容简约而不简单。\n（2）网页应用程序：\n（3）混合式本地应用。\n（4）简单的游戏。"}],"metadata":{"title":"08-HTML5详解","publish":true},"filePath":"docs/guide/guid/html/07-HTML5详解.md"}
{"messages":[{"role":"user","content":"语义化的作用"},{"role":"assistant","content":"语义标签对于我们并不陌生，如 表示一个段落、 表示一个无序列表。\n总结：HTML的职责是描述一块内容是什么（或其意义），而不是它长什么样子；它的外观应该由CSS来决定。"}],"metadata":{"title":"08-HTML5详解","publish":true},"filePath":"docs/guide/guid/html/07-HTML5详解.md"}
{"messages":[{"role":"user","content":"H5在语义上的改进"},{"role":"assistant","content":"在此基础上，HTML5 增加了大量有意义的语义标签，更有利于搜索引擎或辅助设备理解 HTML 页面内容。HTML5会让HTML代码的内容更结构化、标签更语义化。\n我们常见的 css+div 布局是：\n\n在html5中，我们可以这样写：\n\n传统的做法中，我们通过增加类名如 、 ，使HTML页面具有语义性，但是不具有通用性。\nHTML5 则是通过新增语义标签的形式来解决这个问题，例如 、 等，这样就可以使其具有通用性。\n\n```html\n<!-- 头部 -->\n<div class=\"header\">\n    <ul class=\"nav\"></ul>\n</div>\n\n<!-- 主体部分 -->\n<div class=\"main\">\n    <!-- 文章 -->\n    <div class=\"article\"></div>\n    <!-- 侧边栏 -->\n    <div class=\"aside\"></div>\n</div>\n\n<!-- 底部 -->\n<div class=\"footer\">\n\n</div>\n```\n\n```html\n<!-- 头部 -->\n<header>\n    <ul class=\"nav\"></ul>\n</header>\n\n<!-- 主体部分 -->\n<div class=\"main\">\n    <!-- 文章 -->\n    <article></article>\n    <!-- 侧边栏 -->\n    <aside></aside>\n</div>\n\n<!-- 底部 -->\n<footer>\n\n</footer>\n```"}],"metadata":{"title":"08-HTML5详解","publish":true},"filePath":"docs/guide/guid/html/07-HTML5详解.md"}
{"messages":[{"role":"user","content":"H5中新增的语义标签"},{"role":"assistant","content":"本质上新语义标签与 、 没有区别，只是其具有表意性，使用时除了在HTML结构上需要注意外，其它和普通标签的使用无任何差别，可以理解成 相当于 。\nPS：单标签不用写关闭符号。"}],"metadata":{"title":"08-HTML5详解","publish":true},"filePath":"docs/guide/guid/html/07-HTML5详解.md"}
{"messages":[{"role":"user","content":"新语义标签的兼容性处理"},{"role":"assistant","content":"IE8 及以下版本的浏览器不支持 H5 和 CSS3。解决办法：引入 文件。\n引入时，需要做if判断，具体代码如下：\n```html\n    <!--  条件注释 只有ie能够识别-->\n\n    <!--[if lte ie 8]>\n        <script src=\"html5shiv.min.js\"></script>\n    <![endif]-->\n```\n上方代码是 ：虽然是注释，但是IE浏览器可以识别出来。解释一下：\nPS:我们在测试 IE 浏览器的兼容的时候，可以使用软件 ietest，模拟IE6-IE11。\n在不支持HTML5新标签的浏览器，会将这些新的标签解析成行内元素(inline)对待，所以我们只需要将其转换成块元素(block)即可使用。\n但是在IE9版本以下，并不能正常解析这些新标签，但是可以识别通过document.createElement('tagName')创建的自定义标签。于是我们的解决方案就是：将HTML5的新标签全部通过document.createElement('tagName')来创建一遍，这样IE低版本也能正常解析HTML5新标签了。\n当然，在实际开发中我们更多采用的办法是：检测IE浏览器的版本，来加载第三方的JS库来解决兼容问题（如上方代码所示）。"}],"metadata":{"title":"08-HTML5详解","publish":true},"filePath":"docs/guide/guid/html/07-HTML5详解.md"}
{"messages":[{"role":"user","content":"H5中的表单"},{"role":"assistant","content":"传统的Web表单已经越来越不能满足开发的需求，HTML5 在 Web 表单方向做了很大的改进，如拾色器、日期/时间组件等，使表单处理更加高效。"}],"metadata":{"title":"08-HTML5详解","publish":true},"filePath":"docs/guide/guid/html/07-HTML5详解.md"}
{"messages":[{"role":"user","content":"H5中新增的表单类型"},{"role":"assistant","content":"上面的部分类型是针对移动设备生效的，且具有一定的兼容性，在实际应用当中可选择性的使用。\n代码举例：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no\">\n    <title>表单类型</title>\n    <style>\n        body {\n            margin: 0;\n            padding: 0;\n            background-color: #F7F7F7;\n        }\n\n        form {\n            max-width: 500px;\n            width: 100%;\n            margin: 32px auto 0;\n            font-size: 16px;\n        }\n\n        label {\n            display: block;\n            margin: 10px 0;\n        }\n\n        input {\n            width: 100%;\n            height: 25px;\n            margin-top: 2px;\n            display: block;\n        }\n\n    </style>\n</head>\n<body>\n<form action=\"\">\n    <fieldset>\n        <legend>表单类型</legend>\n        <label for=\"\">\n            email: <input type=\"email\" name=\"email\" required>\n        </label>\n        <label for=\"\">\n            color: <input type=\"color\" name=\"color\">\n        </label>\n        <label for=\"\">\n            url: <input type=\"url\" name='url'>\n        </label>\n        <label for=\"\">\n            number: <input type=\"number\" step=\"3\" name=\"number\">\n        </label>\n        <label for=\"\">\n            range: <input type=\"range\" name=\"range\" value=\"100\">\n        </label>\n        <label for=\"\">\n            search: <input type=\"search\" name=\"search\">\n        </label>\n        <label for=\"\">\n            tel: <input type=\"tel\" name=\"tel\">\n        </label>\n        <label for=\"\">\n            time: <input type=\"time\" name=\"time\">\n        </label>\n        <label for=\"\">\n            date: <input type=\"date\" name=\"date\">\n        </label>\n        <label for=\"\">\n            datetime: <input type=\"datetime\">\n        </label>\n        <label for=\"\">\n            week: <input type=\"week\" name=\"week\">\n        </label>\n        <label for=\"\">\n            month: <input type=\"month\" name=\"month\">\n        </label>\n        <label for=\"\">\n            datetime-local: <input type=\"datetime-local\" name=\"datetime-local\">\n        </label>\n        <input type=\"submit\">\n    </fieldset>\n</form>\n</body>\n</html>\n```\n代码解释：\n标签将表单里的内容进行打包，代表一组；而 标签的则是 fieldset 里的元素定义标题。"}],"metadata":{"title":"08-HTML5详解","publish":true},"filePath":"docs/guide/guid/html/07-HTML5详解.md"}
{"messages":[{"role":"user","content":"表单元素（标签）"},{"role":"assistant","content":"这里讲两个表单元素。\n\n```html\n<input type=\"text\" list=\"myData\">\n<datalist id=\"myData\">\n    <option>本科</option>\n    <option>研究生</option>\n    <option>不明</option>\n</datalist>\n```\n上方代码中，input里的list属性和 datalist 进行了绑定。\n效果：\n\n上图可以看出，数据列表可以自动提示。\n2、 元素：\nkeygen 元素的作用是提供一种验证用户的可靠方法。\nkeygen 元素是密钥对生成器（key-pair generator）。当提交表单时，会生成两个键：一个公钥，一个私钥。\n私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。\n3、 元素：度量器\n举例：\n```javascript\n\t<meter  value=\"81\"    min=\"0\" max=\"100\"  low=\"60\"  high=\"80\"/>\n```"}],"metadata":{"title":"08-HTML5详解","publish":true},"filePath":"docs/guide/guid/html/07-HTML5详解.md"}
{"messages":[{"role":"user","content":"表单属性"},{"role":"assistant","content":"代码举例：\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n    <style>\n        form {\n            width: 100%;\n            /* 最大宽度*/\n            max-width: 640px;\n            /* 最小宽度*/\n            min-width: 320px;\n            margin: 0 auto;\n            font-family: \"Microsoft Yahei\";\n            font-size: 20px;\n        }\n\n        input {\n            display: block;\n            width: 100%;\n            height: 30px;\n            margin: 10px 0;\n        }\n    </style>\n</head>\n<body>\n\n<form action=\"\">\n    <fieldset>\n        <legend>表单属性</legend>\n        <label for=\"\">\n            用户名：<input type=\"text\" placeholder=\"例如：smyhvae\" autofocus name=\"userName\" autocomplete=\"on\" required/>\n        </label>\n\n        <label for=\"\">\n            电话：<input type=\"tel\" pattern=\"1\\d{10}\"/>\n        </label>\n\n        <label for=\"\">\n            multiple的表单: <input type=\"file\" multiple>\n        </label>\n\n        <!-- 上传文件-->\n        <input type=\"file\" name=\"file\" multiple/>\n\n        <input type=\"submit\"/>\n    </fieldset>\n</form>\n\n</body>\n</html>\n```"}],"metadata":{"title":"08-HTML5详解","publish":true},"filePath":"docs/guide/guid/html/07-HTML5详解.md"}
{"messages":[{"role":"user","content":"表单事件"},{"role":"assistant","content":"举例：\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n    <style>\n        form {\n            width: 100%;\n            /* 最大宽度*/\n            max-width: 400px;\n            /* 最小宽度*/\n            min-width: 200px;\n            margin: 0 auto;\n            font-family: \"Microsoft Yahei\";\n            font-size: 20px;\n        }\n\n        input {\n            display: block;\n            width: 100%;\n            height: 30px;\n            margin: 10px 0;\n        }\n    </style>\n</head>\n<body>\n<form action=\"\">\n    <fieldset>\n        <legend>表单事件</legend>\n        <label for=\"\">\n            邮箱：<input type=\"email\" name=\"\" id=\"txt1\"/>\n        </label>\n        <label for=\"\">\n            输入的次数统计：<input type=\"text\" name=\"\" id=\"txt2\"/>\n        </label>\n\n        <input type=\"submit\"/>\n    </fieldset>\n</form>\n<script>\n\n    var txt1 = document.getElementById('txt1');\n    var txt2 = document.getElementById('txt2');\n    var num = 0;\n\n    txt1.oninput = function () {  //用户输入时触发\n\n        num++;  //用户每输入一次，num自动加 1\n        //将统计数显示在txt2中\n        txt2.value = num;\n    }\n    txt1.oninvalid = function () {  //验证不通过时触发\n        this.setCustomValidity('亲，请输入正确哦');  //设置验证不通过时的提示文字\n    }\n\n</script>\n</body>\n</html>\n```\n效果："}],"metadata":{"title":"08-HTML5详解","publish":true},"filePath":"docs/guide/guid/html/07-HTML5详解.md"}
{"messages":[{"role":"user","content":"多媒体"},{"role":"assistant","content":"在HTML5之前，在网页上播放音频/视频的通用方法是利用Flash来播放。但是大多情况下，并非所有用户的浏览器都安装了Flash插件，由此使得音频、视频播放的处理变得非常复杂；并且移动设备的浏览器并不支持Flash插件。\nH5里面提供了视频和音频的标签。"}],"metadata":{"title":"08-HTML5详解","publish":true},"filePath":"docs/guide/guid/html/07-HTML5详解.md"}
{"messages":[{"role":"user","content":"音频"},{"role":"assistant","content":"HTML5通过 标签来解决音频播放的问题。\n使用举例：\n```html\n\t<audio src=\"music/yinyue.mp3\" autoplay controls> </audio>\n```\n效果如下：\n\n我们可以通过附加属性，来更友好地控制音频的播放，如：\n\n由于版权等原因，不同的浏览器可支持播放的格式是不一样的：\n\n为了做到多浏览器支持，可以采取以下兼容性写法：\n```html\n<!--推荐的兼容写法：-->\n<audio controls loop>\n    <source src=\"music/yinyue.mp3\"/>\n    <source src=\"music/yinyue.ogg\"/>\n    <source src=\"music/yinyue.wav\"/>\n    抱歉，你的浏览器暂不支持此音频格式\n</audio>\n```\n代码解释：如果识别不出音频格式，就弹出那句“抱歉”。"}],"metadata":{"title":"08-HTML5详解","publish":true},"filePath":"docs/guide/guid/html/07-HTML5详解.md"}
{"messages":[{"role":"user","content":"视频"},{"role":"assistant","content":"HTML5通过 标签来解决视频播放的问题。\n使用举例：\n```html\n\t<video src=\"video/movie.mp4\" controls autoplay></video>\n```\n我们可以通过附加属性，来更友好地控制视频的播放，如：\n由于版权等原因，不同的浏览器可支持播放的格式是不一样的：\n\n兼容性写法：\n```html\n    <!--<video src=\"video/movie.mp4\" controls  autoplay ></video>-->\n    <!--  行内块 display:inline-block -->\n    <video controls autoplay>\n        <source src=\"video/movie.mp4\"/>\n        <source src=\"video/movie.ogg\"/>\n        <source src=\"video/movie.webm\"/>\n        抱歉，不支持此视频\n    </video>\n```"}],"metadata":{"title":"08-HTML5详解","publish":true},"filePath":"docs/guide/guid/html/07-HTML5详解.md"}
{"messages":[{"role":"user","content":"自定义属性"},{"role":"assistant","content":"js 里可以通过  来自定义属性和获取属性。\nH5可以直接在标签里添加自定义属性， 。\n举例：\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n<!-- 给标签添加自定义属性 必须以data-开头 -->\n<div class=\"box\" title=\"盒子\" data-my-name=\"smyhvae\" data-content=\"我是一个div\">div</div>\n<script>\n    var box = document.querySelector('.box');\n\n    //自定义的属性 需要通过 dateset[]方式来获取\n    console.log(box.dataset[\"content\"]);  //打印结果：我是一个div\n    console.log(box.dataset[\"myName\"]);    //打印结果：smyhvae\n\n    //设置自定义属性的值\n    var num = 100;\n    num.index = 10;\n    box.index = 100;\n    box.dataset[\"content\"] = \"aaaa\";\n\n</script>\n</body>\n</html>\n```"}],"metadata":{"title":"08-HTML5详解","publish":true},"filePath":"docs/guide/guid/html/07-HTML5详解.md"}
{"messages":[{"role":"user","content":"举例：鼠标点击时，tab栏切换"},{"role":"assistant","content":"```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Tab 标签</title>\n    <style>\n        body {\n            margin: 0;\n            padding: 0;\n            background-color: #F7F7F7;\n        }\n\n        .tabs {\n            width: 400px;\n            margin: 30px auto;\n            background-color: #FFF;\n            border: 1px solid #C0DCC0;\n            box-sizing: border-box;\n        }\n\n        .tabs nav {\n            height: 40px;\n            text-align: center;\n            line-height: 40px;\n            overflow: hidden;\n            background-color: #C0DCC0;\n            display: flex;\n        }\n\n        nav a {\n            display: block;\n            width: 100px;\n            border-right: 1px solid #FFF;\n            color: #000;\n            text-decoration: none;\n        }\n\n        nav a:last-child {\n            border-right: 0 none;\n        }\n\n        nav a.active {\n            background-color: #9BAF9B;\n        }\n\n        .cont {\n            overflow: hidden;\n            display: none;\n        }\n\n        .cont ol {\n            line-height: 30px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"tabs\">\n        <nav>\n            <a href=\"javascript:;\" data-cont=\"local\">国内新闻</a>\n            <a href=\"javascript:;\" data-cont=\"global\">国际新闻</a>\n            <a href=\"javascript:;\" data-cont=\"sports\">体育新闻</a>\n            <a href=\"javascript:;\" data-cont=\"funny\">娱乐新闻</a>\n        </nav>\n        <section class=\"cont\" id=\"local\">\n            <ol>\n                <li>国内新闻1</li>\n                <li>国内新闻2</li>\n                <li>国内新闻3</li>\n                <li>国内新闻4</li>\n                <li>国内新闻5</li>\n                <li>国内新闻6</li>\n                <li>国内新闻7</li>\n            </ol>\n        </section>\n        <section class=\"cont\" id=\"global\">\n            <ol>\n                <li>国内新闻1</li>\n                <li>国际新闻2</li>\n                <li>国际新闻3</li>\n                <li>国际新闻4</li>\n                <li>国际新闻5</li>\n                <li>国际新闻6</li>\n            </ol>\n        </section>\n        <section class=\"cont\" id=\"sports\">\n            <ol>\n                <li>体育新闻1</li>\n                <li>体育新闻2</li>\n                <li>体育新闻3</li>\n                <li>体育新闻4</li>\n                <li>体育新闻5</li>\n                <li>体育新闻6</li>\n                <li>体育新闻7</li>\n            </ol>\n        </section>\n        <section class=\"cont\" id=\"funny\">\n            <ol>\n                <li>娱乐新闻1</li>\n                <li>娱乐新闻2</li>\n                <li>娱乐新闻3</li>\n                <li>娱乐新闻4</li>\n                <li>娱乐新闻5</li>\n                <li>娱乐新闻6</li>\n                <li>娱乐新闻7</li>\n            </ol>\n        </section>\n    </div>\n    <script>\n        // 目标： 默认显示一个 当前的样式\n        // 点击导航，实现切换\n        // key 表示的当前显示的是第几个\n\n        (function (key) {\n            // 获取所有的导航\n            var navs = document.querySelectorAll('nav a');\n            // 遍历 给导航 绑定事件，并且添加当前样式\n            for (var i = 0; i < navs.length; i++) {\n                // 如果是用户指定的当前样式\n                if (key == i) {\n                    navs[i].classList.add('active');\n                    // 拿到要显示内容section的id\n                    var secId = navs[i].dataset['cont'];\n                    // 获取对应的section标签\n                    document.querySelector('#' + secId).style.display = 'block';\n                }\n\n                // 给每一个导航绑定点击事件\n                navs[i].onclick = function () {\n                    // 排他\n                    // 之前有active样式的清除, 之前显示的section 隐藏\n                    var currentNav = document.querySelector('.active');\n                    // 获取对应的内容区域 ，让其隐藏\n                    var currentId = currentNav.dataset['cont'];\n                    // 去掉导航的active 样式\n                    currentNav.classList.remove('active');\n                    // 对应的内容区域\n                    document.querySelector('#' + currentId).style.display = 'none';\n\n                    // 突出显示自己 导航添加样式  对应的section 显示\n                    // 给自己添加active样式\n                    this.classList.add('active');\n                    // 对应的section模块显示出来\n                    var myId = this.dataset['cont'];\n                    document.querySelector('#' + myId).style.display = 'block';\n                }\n            }\n\n        })(0);\n\n\n    </script>\n</body>\n\n</html>\n```"}],"metadata":{"title":"08-HTML5详解","publish":true},"filePath":"docs/guide/guid/html/07-HTML5详解.md"}
{"messages":[{"role":"user","content":"1.1 参数回调"},{"role":"assistant","content":"emits('事件名'，参数)\n```js\nconst switchHandler=(val:number)=>{\n  isSwitch.value=val;\n  emits('switchHandlerEmit',val)\n}\n```"}],"metadata":{},"filePath":"docs/guide/vue/uniapp/uniapp.md"}
{"messages":[{"role":"user","content":"1.2 dataset参数"},{"role":"assistant","content":"```html\n      <view\n        class=\"scroll-view-item\"\n        v-for=\"(item, index) in navList\"\n        :key=\"item.id\"\n        :class=\"{ active: index == sliderData.sliderIndex }\"\n        :data-index=\"index\"\n      >\n        {{ item.name }}\n      </view>\n\n```\n可以在e.target中的dataset属性中获取设置的属性值"}],"metadata":{},"filePath":"docs/guide/vue/uniapp/uniapp.md"}
{"messages":[{"role":"user","content":"1.4 easycom规范"},{"role":"assistant","content":"传统vue组件，需要安装、引用、注册，三个步骤后才能使用组件。 将其精简为一步。\n只要组件路径符合规范\n指："}],"metadata":{},"filePath":"docs/guide/vue/uniapp/uniapp.md"}
{"messages":[{"role":"user","content":"1.6常用组件"},{"role":"assistant","content":"scroll-view\n```html\n\t<view class=\"navbar\">\n\t\t<!-- 这里是标题栏 -->\n\t</view>\n\t<scroll-view scroll-y=\"true\" class=\"page-content\">\n\t\t这里是内容区\n\t</scroll-view>\n.navbar{\n\tposition: fixed;\n\ttop:0;\n\twidth:100%;\n\theight:44px;\n}\n.page-content {\n\tposition: fixed;\n\ttop: 44px;   // 距离标题栏高度\n\tleft: 0;\n\tright: 0;\n\tbottom: 0px;\n}\n注释：父元素设置子元素不换行 white-space: nowrap;，设置最小宽度，可以实现滑动栏的效果\n负责用户上下浏览设置 `scroll-y`，而导航栏负责左右浏览设置 `scroll-x`\n```\nNavBar 导航栏 支持左右插槽 （下载 非内置组件）\n```html\n\t<uni-nav-bar fixed :status-bar=\"true\" title=\"我的音乐\" @clickLeft=\"goCloud\" @clickRight=\"goCloud\">\n\t\t<block slot=\"left\"><image class=\"top-img left\" src=\"/static/image/mine/l.png\"></image></block>\n\t\t<!-- #ifdef APP-PLUS -->\n\t\t<block slot=\"right\"><image class=\"top-img\" src=\"/static/image/mine/r.png\"></image></block>\n\t\t<!-- #endif -->\n\t</uni-nav-bar>\n```\n使用uniapp组件库，不走弯路了\nimage的图片可以使用 mode=\"widthFix\"实现自适应高度\n```\n`<image :src=\"item.image\" mode=\"widthFix\" style=\"width: 100%\"></image>`\n```"}],"metadata":{},"filePath":"docs/guide/vue/uniapp/uniapp.md"}
{"messages":[{"role":"user","content":"1.7pinia"},{"role":"assistant","content":"```ts\nimport { createPinia } from \"pinia\";\nimport { createPersistedState } from \"pinia-plugin-persistedstate\";\n\nconst store = createPinia();\n// 状态持久化\nstore.use(\n    createPersistedState({\n        storage: {\n            getItem: (key: string) => uni.getStorageSync(key),\n            setItem: (key: string, value: string) => uni.setStorageSync(key, value)\n        }\n    })\n);\n\nexport default store;\n\n```\n小程序中，使用插件实现数据持久化\n```js\n  persist: {\n        key: \"模块名\",\n        paths: ['state中需要存储的值']\n    }\n```\nPinia在ts中使用，需要注入store\n```js\nimport store from \"@/store/index\"\nimport {setBarStore} from \"@/store/setTabBar\"\n//设置标签\nconst useSetBar = setBarStore(store);\n```"}],"metadata":{},"filePath":"docs/guide/vue/uniapp/uniapp.md"}
{"messages":[{"role":"user","content":"1.8app扫码api"},{"role":"assistant","content":"```html\n<!-- components/scan/scan.vue -->\n<template>\n    <view></view>\n</template>\n\n<script>\n    export default {\n        data() {\n            return {\n                typeList: [ // 码类型 参考地址 https://www.dcloud.io/docs/api/zh_cn/barcode.html\n                    plus.barcode.QR,\n                    // plus.barcode.EAN13,\n                    // plus.barcode.EAN8,\n                    // plus.barcode.UPCA,\n                    // plus.barcode.UPCE,\n                    // plus.barcode.CODABAR,\n                    // plus.barcode.CODE39,\n                    // plus.barcode.CODE93,\n                    // plus.barcode.CODE128,\n                    // plus.barcode.ITF,\n                ],\n            };\n        },\n        methods: {\n            open() {\n                // 创建上层webview\n                let pages = getCurrentPages();\n                let currentWebview = pages[pages.length - 1].$getAppWebview();\n                // 创建一个扫码框\n                this.barcode = plus.barcode.create('barcode', this.typeList, {\n                    position: 'fixed',  // fixed 固定在页面\n                    top: '64px',\n                    left: '0px',\n                    width: '100%',\n                    height: '100%',\n                });\n                // 扫码成功回调\n                this.barcode.onmarked = this.onmarked;\n                // 添加到当前 Webview\n                currentWebview.append(this.barcode);\n                // 打开扫码\n                this.barcode.start();\n            },\n            // 关闭扫码\n            close () {\n                this.barcode.close();\n            },\n            // 扫码成功\n            onmarked (type, result) {\n                this.openStartRecognize(result)\n                this.$emit('success', result);\n                this.close()\n            }\n        }\n    }\n</script>\n<style lang=\"scss\"></style>\n```"}],"metadata":{},"filePath":"docs/guide/vue/uniapp/uniapp.md"}
{"messages":[{"role":"user","content":"1.9字体px"},{"role":"assistant","content":"一般设计稿750px，手机像素点缩放2rpx=1px,如果遇到0.5px无法渲染，可以使用伪元素配合scale属性进行缩放\n```css\n transform: scale(0.84);\n```"}],"metadata":{},"filePath":"docs/guide/vue/uniapp/uniapp.md"}
{"messages":[{"role":"user","content":"2.0使用vue3ref组件"},{"role":"assistant","content":"```js\ndefineExpose({ openSearch, closeSearch })\n```\n需要使用defineExpose函数对实例的值进行暴露"}],"metadata":{},"filePath":"docs/guide/vue/uniapp/uniapp.md"}
{"messages":[{"role":"user","content":"2.1storage"},{"role":"assistant","content":"```js\nuni.setStorageSync() ，uni.getStorageSync() 同步\n```"}],"metadata":{},"filePath":"docs/guide/vue/uniapp/uniapp.md"}
{"messages":[{"role":"user","content":"uni.setStorageSync(KEY,DATA)"},{"role":"assistant","content":"将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个同步接口。"}],"metadata":{},"filePath":"docs/guide/vue/uniapp/uniapp.md"}
{"messages":[{"role":"user","content":"uni.getStorageSync(KEY)"},{"role":"assistant","content":"从本地缓存中同步获取指定 key 对应的内容。"}],"metadata":{},"filePath":"docs/guide/vue/uniapp/uniapp.md"}
{"messages":[{"role":"user","content":"2.2防抖"},{"role":"assistant","content":"```html\nfunction debounce(fn, wait = 300) {  \n    var timeout = null;  \n    return function() {    \n        if(timeout !== null) clearTimeout(timeout);    \n        timeout = setTimeout(fn, wait);  \n    }\n}\n```"}],"metadata":{},"filePath":"docs/guide/vue/uniapp/uniapp.md"}
{"messages":[{"role":"user","content":"2.3分包"},{"role":"assistant","content":"```html\n// pages.json\n\"pages\": [],\n\"subPackages\": [\n\t{\n\t\t\"root\": \"pages/subpages\",   // 分包根目录\n\t\t\"pages\": [{\n\t\t\t\"path\": \"album\",              // 配置页面路径，此为subpages下的路径\n\t\t\t\"style\": {\n\t\t\t\t\"navigationBarTitleText\": \"歌单\",\n\t\t\t\t\"app-plus\": {\n\t\t\t\t\t\"titleNView\": false\n\t\t\t\t}\n\t\t\t}\n\t\t}]\n\t}\n],\n```\n每次打开小程序会发现有的小程序打开的很快，有些很慢，甚至白屏时间很长。原因是包代码量大小的问题。第一次进入小程序的时候，小程序会下载主包代码，如果我们的主包业务代码越多，那么白屏的时间也会越长。理解成懒加载就好"}],"metadata":{},"filePath":"docs/guide/vue/uniapp/uniapp.md"}
{"messages":[{"role":"user","content":"2.4 transform"},{"role":"assistant","content":"```css\ntransform:translateX(-50%)不会生效\ntransform:translate(-50%,-50%)生效\n```"}],"metadata":{},"filePath":"docs/guide/vue/uniapp/uniapp.md"}
{"messages":[{"role":"user","content":"2.5跳转"},{"role":"assistant","content":"switchTab才能跳转到tab页面"}],"metadata":{},"filePath":"docs/guide/vue/uniapp/uniapp.md"}
{"messages":[{"role":"user","content":"2.6固定定位产生的布局问题"},{"role":"assistant","content":"因为fixed元素脱离了正常文档流，所以relative元素的原本位置向上提了，产生了覆盖的行为。\n需要添加 or 属性到下层内容组件上，使其发生向下偏移，不再被覆盖。"}],"metadata":{},"filePath":"docs/guide/vue/uniapp/uniapp.md"}
{"messages":[{"role":"user","content":"2.7scroll-view事件问题"},{"role":"assistant","content":"```html\n   <scroll-view scroll-y=\"true\" class=\"detailBody\" style=\"height: 100%\" @scroll=\"scrollHandler\">\n       <view>高度要高于scroll-view高度</view>\n      </scroll-view>\n```\n需要内部高度超出整个scroll-view高度 ，关于scroll事件是否生效"}],"metadata":{},"filePath":"docs/guide/vue/uniapp/uniapp.md"}
{"messages":[{"role":"user","content":"2.8uView组件"},{"role":"assistant","content":"这次使用的uView-plus组件，组件内部设置border是!important，得将border关闭后再设置border,它的u-input自带flex:1 flex 1 1 0%  flex-grow，flex-shrink，flex-basis 得将grow设置为0 并且flex-basis设置为auto 既代表项目原来大小"}],"metadata":{},"filePath":"docs/guide/vue/uniapp/uniapp.md"}
{"messages":[{"role":"user","content":"2.9登陆获取头像问题"},{"role":"assistant","content":"简而言之，就是getUserProfile和getUserInfo 都无法获取头像了，最开始从getUserInfo 改到getUserProfile，现在都不能用了，只能通过button组件来实现\n```html\n头像选择\n需要将 button 组件 open-type 的值设置为 chooseAvatar，当用户选择需要使用的头像之后，可以通过 bindchooseavatar 事件回调获取到头像信息的临时路径。\n\n从基础库2.24.4版本起，若用户上传的图片未通过安全监测，不触发bindchooseavatar 事件。\n```\n```html\n昵称填写\n需要将 input 组件 type 的值设置为 nickname，当用户在此input进行输入时，键盘上方会展示微信昵称。\n\n从基础库2.24.4版本起，在onBlur 事件触发时，微信将异步对用户输入的内容进行安全监测，若未通过安全监测，微信将清空用户输入的内容，建议开发者通过 form 中form-type 为submit 的button 组件收集用户输入的内容。\n```"}],"metadata":{},"filePath":"docs/guide/vue/uniapp/uniapp.md"}
{"messages":[{"role":"user","content":"3.1音频接口"},{"role":"assistant","content":"```js\nconst changePlayTime = (e: any) => {\n \n  playState.value.current = e.detail.value;\n bgAudioManager.seek(e.detail.value);\n};\n```\nseek方法不能使用响应式数据"}],"metadata":{},"filePath":"docs/guide/vue/uniapp/uniapp.md"}
{"messages":[{"role":"user","content":"1、提交事件"},{"role":"assistant","content":"使用 submit()函数进行提交\n绑定在提交按钮和键盘的ENTER键位上"}],"metadata":{},"filePath":"docs/guide/js/todolist.md"}
{"messages":[{"role":"user","content":"1-1 submit做了什么"},{"role":"assistant","content":"submit事件\n```javascript\n    function submit (e) {\n      if (!commentStr.trim()) return\n      let id = new Date().getTime()\n      let item = commentsObject(commentStr, getData(), id)//生成一个对象，构造函数\n \n      let domObj = render(item, id)//渲染dom,返回一个对像，包含所有我们以后需要操作的dom\n      commentsArr.push(item);//评论添加到数据数组中，这个数组的作用 可以发给后端\n      bindEvent(domObj)//绑定事件\n      domArr.push(domObj)//添加一个数组，这个数组收集的是，我们所有的需要操作dom\n      clearHandler()//清除副作用，每一个我们完成操作后，需要将输入框数据清空，并且我们收集的commentStr也需要重置。\n    }\n```"}],"metadata":{},"filePath":"docs/guide/js/todolist.md"}
{"messages":[{"role":"user","content":"2-1commentsObject 构造函数"},{"role":"assistant","content":"```javascript\n  function commentsObject (text, time, id, name = \"张三\",) {\n      let obj = {};\n      obj.name = name;\n      obj.text = text;\n      obj.time = time;\n      obj.id = id\n      return obj;\n    }\nname=\"张三\"是一个默认值，他的作用，是在于每一次我们不传入name，自动生成\n```\n这个函数的本质，是一个构造函数，说通俗点，就是根据参数生成一个对象，免去每一次，我们都要重新的书写对象。减少重复书写对象的大量文本，有兴趣同学，可以看一下new 运算符"}],"metadata":{},"filePath":"docs/guide/js/todolist.md"}
{"messages":[{"role":"user","content":"2-2 createEle生成dom的工具函数"},{"role":"assistant","content":"他的作用：生成一个dom对象，并且返回一个它，他接受三个参数，都是string类型，\n```javascript\n   function createEle (tag, className = \"\", text = \"\") {\n      let ele = document.createElement(tag);\n\n      ele.className = className;\n      if (text) ele.innerHTML = text;\n      return ele\n    }\n```"}],"metadata":{},"filePath":"docs/guide/js/todolist.md"}
{"messages":[{"role":"user","content":"2-3 render dom生成函数"},{"role":"assistant","content":"arr数组，他的目的是在一个循环中，生成我们想要的dom对象\n```javascript\n    function render (obj, id) {\n        //建议可以看一下Object.keys 和Object.value 然后尝试改写下面这个循环\n      let arr = [\n        \"name\", \"text\", \"time\"\n      ] //3个对象的属性名称\n      let info = createEle(\"div\", 'info');//创建info标签和类名\n      let commentDomObj = {}//收集我们创建评论的dom，放在一个对象中，方便进行管理\n      //循环创建重复dom,需要的展示文本\n      arr.forEach((item) => {\n        let ele = createEle(\"p\", item, obj[item])//创建dom函数，返回值是当前创建的dom\n        if (item === \"text\") {\n          let input = createEle(\"input\", \"hidden\");\n          info.appendChild(input)\n          commentDomObj[\"input\"] = input\n        }\n        commentDomObj[item] = ele;\n        info.appendChild(ele);\n      })\n\n      let item = createEle(\"div\", 'item');\n      let menu = createEle(\"div\", \"menu\");\n      let leftTool = createEle(\"div\", \"leftTool\");\n      let checkbox = createEle(\"input\", \"listCheckbox\");//选择框\n      checkbox.type = \"checkbox\";//选择框\n      let del = createEle('div', \"del\", \"删除\");\n      //删除按钮\n      leftTool.appendChild(checkbox)\n      menu.appendChild(del)\n      item.appendChild(leftTool);\n      item.appendChild(info);\n      item.appendChild(menu);\n\n      document.querySelector(\".list\").appendChild(item)//将我们生成的dom添加到list类下面\n      return {\n        ...commentDomObj, del: del, checkbox, id: id\n      }\n    }\n```"}],"metadata":{},"filePath":"docs/guide/js/todolist.md"}
{"messages":[{"role":"user","content":"3-1绑定事件"},{"role":"assistant","content":"bindEvent(dom对象)专门用于绑定所有的事件\n```javascript\n    function bindEvent (domObj) {\n      //双击打开文本框事件\n      domObj.text.ondblclick = function (e) {\n        let textDom = domObj.text;\n        //input框\n        let inputDom = domObj.input;\n        //toggle,如果有class就删除，没有就添加\n        textDom.classList.toggle('hidden');\n        inputDom.classList.toggle(\"hidden\");\n        //让input文本框的值，等于当前评论的文本\n        inputDom.value = textDom.innerHTML\n        //input显示出来后，自动聚焦\n        inputDom.focus();\n      }\n      //失去焦点保存事件\n      domObj.input.onblur = function (e) {\n        let textDom = domObj.text;\n        let inputDom = domObj.input;\n        let timeDom = domObj.time;\n        textDom.classList.toggle('hidden');\n        inputDom.classList.toggle(\"hidden\");\n        let time = getData()//获取时间\n        //修改收集数据数组的值\n        let index = commentsArr.findIndex(item => item.id === domObj.id);\n        commentsArr[index].text = inputDom.value\n        commentsArr[index].time = time;\n        // 修改当前innerHTML文本\n        textDom.innerHTML = inputDom.value;\n        timeDom.innerHTML = time;\n      }\n      //删除dom事件\n      domObj.del.onclick = function (e) {\n        let index = commentsArr.findIndex(item => item.id === domObj.id);\n        let domIndex = domArr.findIndex(item => item.id === domObj.id);\n        commentsArr.splice(index, 1);\n        domArr.splice(index, 1);\n        e.target.parentElement.parentElement.remove()\n      }\n      domObj.checkbox.onchange = function (e) {\n        let checkLength = 0\n        for (let i = 0; i < domArr.length; i++) {\n          const ele = domArr[i];\n          if (ele.checkbox.checked) {\n            checkLength++\n          }\n        }\n        if (checkLength === domArr.length) {\n          allCheckDom.checked = true\n        } else {\n          allCheckDom.checked = false\n        }\n\n      }\n    }\n```"}],"metadata":{},"filePath":"docs/guide/js/todolist.md"}
{"messages":[{"role":"user","content":"3-2双击出现和隐藏修改文本框"},{"role":"assistant","content":"ondblclick是鼠标左键双击事件\n```javascript\n   domObj.text.ondblclick = function (e) {\n        let textDom = domObj.text;\n        //input框\n        let inputDom = domObj.input;\n        //toggle,如果有class就删除，没有就添加\n        textDom.classList.toggle('hidden');\n        inputDom.classList.toggle(\"hidden\");\n        //让input文本框的值，等于当前评论的文本\n        inputDom.value = textDom.innerHTML\n        //input显示出来后，自动聚焦\n        inputDom.focus();\n      }\n```"}],"metadata":{},"filePath":"docs/guide/js/todolist.md"}
{"messages":[{"role":"user","content":"3-3失去焦点后的事件"},{"role":"assistant","content":"失去焦点事件，更新事件，切换显示的dom，更新文本，更新收集数据的数组\n```javascript\n   domObj.input.onblur = function (e) {\n        let textDom = domObj.text;\n        let inputDom = domObj.input;\n        let timeDom = domObj.time;\n        textDom.classList.toggle('hidden');\n        inputDom.classList.toggle(\"hidden\");\n        let time = getData()//获取时间\n        //修改收集数据数组的值\n        let index = commentsArr.findIndex(item => item.id === domObj.id);\n        commentsArr[index].text = inputDom.value\n        commentsArr[index].time = time;\n        // 修改当前innerHTML文本\n        textDom.innerHTML = inputDom.value;\n        timeDom.innerHTML = time;\n      }\n```"}],"metadata":{},"filePath":"docs/guide/js/todolist.md"}
{"messages":[{"role":"user","content":"3-4删除dom事件"},{"role":"assistant","content":"通过id找到对应的收集数据的数组和dom对象的数组\n```javascript\n      domObj.del.onclick = function (e) {\n        let index = commentsArr.findIndex(item => item.id === domObj.id);\n        let domIndex = domArr.findIndex(item => item.id === domObj.id);\n        commentsArr.splice(index, 1);\n        domArr.splice(index, 1);\n        e.target.parentElement.parentElement.remove()\n      }\n```"}],"metadata":{},"filePath":"docs/guide/js/todolist.md"}
{"messages":[{"role":"user","content":"3-4全选事件"},{"role":"assistant","content":"通过计数的手段，判断选择中的checked值的多少，是否和全部dom数组的长度相等，如果相等，则将全选框dom的checked状态改为true，如果不相等，则将全选框的状态变更为false\n外部的全选框事件\n```javascript\n//每个dom的选择框事件\ndomObj.checkbox.onchange = function (e) {\n        let checkLength = 0\n        for (let i = 0; i < domArr.length; i++) {\n          const ele = domArr[i];\n          if (ele.checkbox.checked) {\n            checkLength++\n          }\n        }\n    //或者checkLength >= domArr.length\n        if (checkLength === domArr.length) {\n          allCheckDom.checked = true\n        } else {\n          allCheckDom.checked = false\n        }\n\n      }\n\n//外部全选框事件\n allCheckDom.onchange = function (e) {\n      for (let i = 0; i < domArr.length; i++) {\n        domArr[i].checkbox.checked = e.target.checked;\n\n      }\n    }\n```"}],"metadata":{},"filePath":"docs/guide/js/todolist.md"}
{"messages":[{"role":"user","content":"1、mySQL基础"},{"role":"assistant","content":"mysql -h主机名  -u用户名 - 密码\n```js\nmysql --host=localhost --user=root --password=123456\nmysql -hlocalhost -uroot -p123456\nmysql -hlocalhost -uroot -p 推荐使用，不会报错，加密输入\n```\n```html\n退出语句\nquit\nexit\n\\q\n```\n你可以通过设置环境变量 来添加一个默认用户名。\n书写注意点"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"4、列"},{"role":"assistant","content":"候选键：通过某个列或者某些列确定唯一的一条记录，我们就可以把这个列或者这些列称为\n主键：选择一个候选键作为表的 ，一个表最多只能有一个主键，主键的值不能重复，通过主键可以找到唯一的一条记录。如果我们的表中有定义主键的需求可以选用下边这两种方式之一来指定主键\n注：主键是唯一识别，如果有唯一属性可以选择它当主键，如果没有，可以让多个候选键组合成为主键\n我们向一个包含唯一性约束的列插入或更新数据时，如果已存在相同的键值，MySQL 会抛出1062错误。\n主键列默认是有 属性"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"UNIQUE 和 PRIMARY KEY 的区别"},{"role":"assistant","content":"AUTO_INCREMENT递增"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"SQL WHERE 语法"},{"role":"assistant","content":"```\n SELECT column_name,column_name\n FROM table_name\n WHERE column_name operator value;\n```"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"匹配值"},{"role":"assistant","content":"不能直接使用普通的操作符来与 值进行比较，必须使用 或者"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"AND操作符"},{"role":"assistant","content":"在给定多个搜索条件的时候，我们有时需要某条记录只在符合所有搜索条件的时候才将其加入结果集，这种情况我们可以使用 操作符来连接多个搜索条件。"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"OR操作符"},{"role":"assistant","content":"在给定多个搜索条件的时候，我们有时需要某条记录在符合某一个搜索条件的时候就将其加入结果集中，这种情况我们可以使用 操作符来连接多个搜索条件。\n多个操作符进行联合查询时，遵循操作符权重规范"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"通配符"},{"role":"assistant","content":"通配符模板\n转义"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"7 表达式"},{"role":"assistant","content":"中 可以是下边这几种类型："}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"逻辑操作符"},{"role":"assistant","content":"逻辑操作符是用来将多个 连接起来，我们需要了解这几个 ："}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"聚集函数"},{"role":"assistant","content":"函数使用来统计行数的，它有下边两种使用方式："}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"9、查询"},{"role":"assistant","content":"分组字句\n```sq\nmysql> SELECT subject, AVG(score) FROM student_score GROUP BY subject;\n```\n条件子句\n语句中可以书写条件表达式"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"10、使用分组注意事项"},{"role":"assistant","content":"使用分组来统计数据给我们带来了非常大的便利，但是要随时提防有坑的地方：\n子句的顺序"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"12、链接查询"},{"role":"assistant","content":"同时查询会链接两张表，生成笛卡尔积  num*num 的表，我们可以使用where限制范围，来减少查询结果，优化性能\nWHERE子句和ON子句是等价的。 子句是专门为外连接驱动表中的记录在被驱动表找不到匹配记录时应不应该把该记录加入结果集这个场景下提出的\n* t1 [ ] t2 连接条件 [ 普通过滤条件];\n内连接\n外连接\n* t1 [ ] t2 连接条件 [ 普通过滤条件];\n* t1 [ ] t2 连接条件 [ 普通过滤条件];\n```js\nfor each row in t1 {\n\n    for each row in t2 which satisfies t1.m1 = t2.m2 {\n        \n        for each row in t3 which satisfies t1.m1 = t3.m3 {\n            send to client;\n        }\n    }\n}\n查询过程 \n```\n自连接\n可以使用AS别名 将一张表变为两张 再进行链接"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"13、UNION联合查询"},{"role":"assistant","content":"因为使用 来合并多个查询的记录会默认过滤掉重复的记录\n如果我们想要保留重复记录，可以使用 来连接多个查询\n末尾加上 和 子句"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"14、数据"},{"role":"assistant","content":"first_table MODIFY first_column  ; 添加唯一约束\n进行约束后 不覆盖原来的值 INSERT IGNORE INTO\n进行约束后 覆盖原来的值 INSERT VALUE(作为后续修改值读取的VALUE) ON DUPLICATE KEY UPDATE 修改值\n删除数据\n```sql\nDELETE FROM 表名 [WHERE 表达式];\n```\n更新数据\n```sql\nUPDATE 表名 SET 列1=值1, 列2=值2, ...,  列n=值n [WHERE 布尔表达式];\n```\n子句来限制想要更新的记录数量，使用 子句来指定符合条件的记录的更新顺序"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"15、视图"},{"role":"assistant","content":"也可以被称为 ，因为我们可以对 进行一些类似表的增删改查操作，只不过我们对视图的相关操作都会被映射到那个又臭又长的查询语句对应的底层的表上。那一串又臭又长的查询语句的查询列表可以被当作 的虚拟列"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"16、自定义变量和语句结束"},{"role":"assistant","content":"语句来自定义一些我们自己的变量，自定义变量前边必须加一个 符号\n后面接sql语句时记得添加();\n可以使用 INTO 在查询结束时赋值\n$ 修改返回符号为; 默认结束为; 我们进行多行操作时可以进行修改 修改为其他符号，确保不冲突"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"17、函数"},{"role":"assistant","content":"```sql\n1418 - This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable)\n```\n解决报错set global log_bin_trust_function_creators=TRUE;\nset global log_bin_trust_function_creators=1;\n```sql\nCREATE FUNCTION 存储函数名称([参数列表])\nRETURNS 返回值类型\nBEGIN\n    函数体内容\nEND\n```\n  函数名 查看某个函数的具体是怎么定义\n 函数名 删除某个存储函数\n语句来自定义变量的方式，可以不用声明就为变量赋值。而在存储函数的函数体中使用变量前必须先声明这个变量\nDECLARE 变量名1, 变量名2, ... 数据类型\nDECLARE后 再使用set 设置值"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"判断语句的编写"},{"role":"assistant","content":"```sql\nIF 表达式 THEN\n    处理语句列表\n[ELSEIF 表达式 THEN\n    处理语句列表]\n... # 这里可以有多个ELSEIF语句\n[ELSE\n    处理语句列表]\nEND IF;\n```"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"循环语句的编写"},{"role":"assistant","content":"```sql\nWHILE 表达式 DO\n    处理语句列表\nEND WHILE;\n```\n```sql\nREPEAT\n    处理语句列表\nUNTIL 表达式 END REPEAT;\n```\n```sql\nLOOP\n    处理语句列表\nEND LOOP;\n循环终止的条件写到处理语句列表中然后使用RETURN语句直接让函数结束就可以达到停止循环的效果\n可以使用LEAVE语句。不过使用LEAVE时需要在LOOP语句前边放置一个所谓的标记\n  flag:LOOP\n        IF i > n THEN\n            LEAVE flag;\n        END IF;\n        SET result = result + i;\n        SET i = i + 1;\n    END LOOP flag;\n    没分号跑不了\n```\n和 都属于 ，都是对某些语句的一个封装。 侧重于执行这些语句并返回一个值，而 更侧重于单纯的去执行这些语句。先看一下 的定义"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"18、过程"},{"role":"assistant","content":"和 都属于 ，都是对某些语句的一个封装。 侧重于执行这些语句并返回一个值，而 更侧重于单纯的去执行这些语句。\n```sql\nCREATE PROCEDURE 存储过程名称([参数列表])\nBEGIN\n    需要执行的语句\nEND\n```\n与 最直观的不同点就是， 的定义不需要声明\n存储过程的调用\n```sql\nCALL 存储过程([参数列表]);\nIN arg INT\nOUT arg INT\nINOUT arg INT\n\nSHOW PROCEDURE STATUS [LIKE 需要匹配的存储过程名称] \nSHOW CREATE PROCEDURE 存储过程名称\nDROP PROCEDURE 存储过程名称\n```\n和 非常类似，我们列举几个它们的不同点以加深大家的对这两者区别的印象："}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"创建游标"},{"role":"assistant","content":"```sql\nDECLARE 游标名称 CURSOR FOR 查询语句;\n```"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"使用游标获取记录"},{"role":"assistant","content":"```sql\nFETCH 游标名 INTO 变量1, 变量2, ... 变量n\n```\nfetch获取不到时触发的时间\n HANDLER NOT FOUND 处理语句;\nCONTINUE HANDLER  FOUND not_done = 0;\n每调用一次 FETCH 语句，游标就移动到下一条记录的位置"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"20、触发器和事件"},{"role":"assistant","content":"触发器\n```SQL\nCREATE TRIGGER 触发器名\n{BEFORE|AFTER}\n{INSERT|DELETE|UPDATE}\nON 表名\nFOR EACH ROW\nBEGIN\n    触发器内容\nEND\n```\n  触发器名;\n 触发器名;\n触发器内容中不能有输出结果集的语句。\n触发器内容中NEW代表记录的列的值可以被更改，OLD代表记录的列的值无法更改。\n在BEFORE触发器中，我们可以使用 的形式来更改待插入记录或者待更新记录的某个列的值，但是这种操作不能在AFTER触发器中使用，因为在执行AFTER触发器的内容时记录已经被插入完成或者更新完成了。\n如果我们的 触发器内容执行过程中遇到了错误，那这个触发器对应的具体语句将无法执行；如果具体的操作语句执行过程中遇到了错误，那与它对应的 触发器的内容将无法执行。"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"事件"},{"role":"assistant","content":"有时候我们想让 服务器在某个时间点或者每隔一段时间自动地执行一些语句，这时候就需要去创建一个 。\n```SQL\nCREATE EVENT 事件名\nON SCHEDULE\n{\n    AT 某个确定的时间点 AT DATE_ADD(NOW(), INTERVAL 2 DAY)表达式| \n    EVERY 期望的时间间隔 [STARTS datetime][END datetime]\n}\nDO\nBEGIN\n    具体的语句\nEND\n```"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"查看和删除事件"},{"role":"assistant","content":"```SQL\nSHOW EVENTS;\nSHOW CREATE EVENT 事件名;\nDROP EVENT 事件名;\n默认情况下，MySQL服务器并不会帮助我们执行事件，除非我们使用下边的语句手动开启\nSET GLOBAL event_scheduler = ON;\n```"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"21、索引"},{"role":"assistant","content":"的语法：\n```\nCREATE INDEX index_name\nON table_name (column1 [ASC|DESC], column2 [ASC|DESC], ...);\n```"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"修改表结构(添加索引)"},{"role":"assistant","content":"```\nALTER TABLE table_name\nADD INDEX index_name (column1 [ASC|DESC], column2 [ASC|DESC], ...);\n```"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"创建表的时候直接指定"},{"role":"assistant","content":"```\nCREATE TABLE table_name (\n  column1 data_type,\n  column2 data_type,\n  ...,\n  INDEX index_name (column1 [ASC|DESC], column2 [ASC|DESC], ...)\n);\n```"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"删除索引的语法"},{"role":"assistant","content":"```\nDROP INDEX index_name ON table_name;\nALTER TABLE employees\nDROP INDEX idx_age;\n```"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"使用ALTER 命令添加和删除索引"},{"role":"assistant","content":"```\nmysql> ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;\nmysql> ALTER TABLE testalter_tbl ADD PRIMARY KEY (i);\nmysql> ALTER TABLE testalter_tbl DROP PRIMARY KEY;\n```"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"显示索引信息"},{"role":"assistant","content":"```\nmysql> SHOW INDEX FROM table_name\\G\n①Table：当前索引属于那张表。\n②Non_unique：目前索引是否属于唯一索引，0代表是的，1代表不是。\n③Key_name：当前索引的名字。\n④Seq_in_index：如果当前是联合索引，目前字段在联合索引中排第几个。\n⑤Column_name：当前索引是位于哪个字段上建立的。\n⑥Collation：字段值以什么方式存储在索引中，A表示有序存储，NULL表无序。\n⑦Cardinality：当前索引的散列程度，也就是索引中存储了多少个不同的值。\n⑧Sub_part：当前索引使用了字段值的多少个字符建立，NULL表示全部。\n⑨Packed：表示索引在存储字段值时，以什么方式压缩，NULL表示未压缩，\n⑩Null：当前作为索引字段的值中，是否存在NULL值，YES表示存在。\n⑪Index_type：当前索引的结构（BTREE, FULLTEXT, HASH, RTREE）。\n⑫Comment：创建索引时，是否对索引有备注信息。\n\n```\n唯一索引在创建时，需要通过 关键字创建\n唯一索引数据不能重复\n主键索引其实是一种特殊的唯一索引，但主键索引却并不是通过 关键字创建的，而是通过 关键字创建\n```\nALTER TABLE tableName ADD PRIMARY KEY indexName(columnName);\n\n-- 方式②\nCREATE TABLE tableName(  \n  columnName1 INT(8) NOT NULL,   \n  columnName2 ....,\n  .....,\n  PRIMARY KEY [indexName] (columnName(length))  \n);\n\n```\n全文索引\n```\n-- 方式①\nALTER TABLE tableName ADD FULLTEXT INDEX indexName(columnName);\n\n-- 方式②\nCREATE FULLTEXT INDEX indexName ON tableName(columnName);\n用来查询最小搜索长度和最大搜索长度\nshow variables like '%ft%';\nft_min_word_len：使用MyISAM引擎的表中，全文索引最小搜索长度。\nft_max_word_len：使用MyISAM引擎的表中，全文索引最大搜索长度。\nft_query_expansion_limit：MyISAM中使用with query expansion搜索的最大匹配数。\ninnodb_ft_min_token_size：InnoDB引擎的表中，全文索引最小搜索长度。\ninnodb_ft_max_token_size：InnoDB引擎的表中，全文索引最大搜索长度。\n```"}],"metadata":{},"filePath":"docs/guide/serve/sql/sql.md"}
{"messages":[{"role":"user","content":"svg"},{"role":"assistant","content":"import Base from '@/page/svg/base'\nimport AnimationSvg from '@/page/svg/animationSvg'"}],"metadata":{},"filePath":"docs/guide/css/svg.mdx"}
{"messages":[{"role":"user","content":"基础"},{"role":"assistant","content":"```tsx\n<svg width=\"500\" height=\"500\" viewBox=\"0 0 500 500\">\n  <filter id=\"blur\">\n    <feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"5\" />\n  </filter>\n  <circle cx=\"170\" cy=\"60\" r=\"50\" fill=\"green\" filter=\"url(#blur)\" />\n</svg>\n```\n<Base  />\n```tsx\n<svg width=\"500\" height=\"500\" viewBox=\"0 0 500 500\" xmlns=\"http://www.w3.org/2000/svg\"\n  xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n  <defs>\n    <mask id=\"mask\">\n      <image width=\"500\" height=\"500\" xlink:href=\"/images/mask.png\" />\n    </mask>\n  </defs>\n  <image mask=\"url(#mask)\" width=\"500\" height=\"500\" xlink:href=\"/images/wolp1.png\" />\n</svg>\n```"}],"metadata":{},"filePath":"docs/guide/css/svg.mdx"}
{"messages":[{"role":"user","content":"xmlns、xmlns:xlink、xlink:href。"},{"role":"assistant","content":"xmlns 和 xmlns:xlink 是 XML 命名空间的属性，而 xlink:href 是 XLink 规范中的属性。它们之间的区别如下：\n20 xlink:href 是 XLink 规范中的属性，用于指定链接的目标。它是在具有 XLink 命名空间的 XML 文档中使用的属性，通过该属性可以指定链接的目标资源。\n综上所述，xmlns 属性用于定义默认命名空间，xmlns:xlink 属性用于定义 XLink 命名空间，而 xlink:href 属性用于指定 XLink 链接的目标资源。"}],"metadata":{},"filePath":"docs/guide/css/svg.mdx"}
{"messages":[{"role":"user","content":"动画"},{"role":"assistant","content":"<AnimationSvg  />"}],"metadata":{},"filePath":"docs/guide/css/svg.mdx"}
{"messages":[{"role":"user","content":"路由组件"},{"role":"assistant","content":"```js\n    pages/\n    --- detail/\n    ------[id].vue\n    --- detail.vue\n    --- index.vue\n===   \n      {\n      path: '/detail',\n      component: '~/pages/detail.vue',\n      children: [\n        {\n          path: '/:id',\n          component: '~/pages/detail/[id].vue'\n        }\n      ]\n    }\n```"}],"metadata":{},"filePath":"docs/guide/vue/nuxt/nuxt.md"}
{"messages":[{"role":"user","content":"全局样式"},{"role":"assistant","content":"```js\nexport default defineNuxtConfig({\n  css: [\n    'assets/global.css'\n  ]\n})\n```\n```js\n变量文件\n// https://nuxt.com/docs/api/configuration/nuxt-config\nexport default defineNuxtConfig({\n  css: [\"assets/global.scss\"],\n  vite: {\n    css: {\n      preprocessorOptions: {\n        scss: {\n          additionalData: '@import \"~/assets/_variables.scss\";',\n        },\n      },\n    },\n  },\n});\n```"}],"metadata":{},"filePath":"docs/guide/vue/nuxt/nuxt.md"}
{"messages":[{"role":"user","content":"服务端api"},{"role":"assistant","content":"```javasc\nserver/api/hello.ts \nexport default defineEventHandler((event) => {\n  return {\n    message: 'hello，nuxt3！'\n  }\n})\n```"}],"metadata":{},"filePath":"docs/guide/vue/nuxt/nuxt.md"}
{"messages":[{"role":"user","content":"gray-matter"},{"role":"assistant","content":"```javascript\nconst fs = require('fs');\nconst matter = require('gray-matter');\nconst str = fs.readFileSync('example.html', 'utf8');\nconsole.log(matter(str));\n作用 读取数据形成对象\n---\ntitle: Hello\nslug: home\n---\n<h1>Hello world!</h1>\n\n{\n  content: '<h1>Hello world!</h1>',\n  data: {\n    title: 'Hello',\n    slug: 'home'\n  }\n}\n\n可以转化为html\n    import { remark } from \"remark\";\n    import html from \"remark-html\";\n```"}],"metadata":{},"filePath":"docs/guide/vue/nuxt/nuxt.md"}
{"messages":[{"role":"user","content":"刷新数据和缓存"},{"role":"assistant","content":"传入返回值可以刷新"}],"metadata":{},"filePath":"docs/guide/vue/nuxt/nuxt.md"}
{"messages":[{"role":"user","content":"useState 服务端共享状态"},{"role":"assistant","content":"```typescript\nuseState<T>(init?: () => T | Ref<T>): Ref<T>\nuseState<T>(key: string, init?: () => T | Ref<T>): Ref<T>\n```\n可以使用pinia，具体见"}],"metadata":{},"filePath":"docs/guide/vue/nuxt/nuxt.md"}
{"messages":[{"role":"user","content":"错误处理"},{"role":"assistant","content":"```\nthrow createError({\n  statusCode: 404,\n  statusMessage: \"文章不存在\"\n});\n```"}],"metadata":{},"filePath":"docs/guide/vue/nuxt/nuxt.md"}
{"messages":[{"role":"user","content":"1、全局配置页头信息"},{"role":"assistant","content":"```javascript\nexport default defineNuxtConfig({\n  app: {\n    head: {\n      charset: 'utf-8', // 快捷方式\n      viewport: 'width=device-width, initial-scale=1', // 快捷方式\n      title: 'My App',\n      meta: [\n        { name: 'description', content: 'My amazing site.' },\n        { name: 'charset', content: 'utf-8' },\n      ],\n      \"link\": [],\n      \"style\": [],\n      \"script\": []\n    }\n  }\n})\n```"}],"metadata":{},"filePath":"docs/guide/vue/nuxt/nuxt.md"}
{"messages":[{"role":"user","content":"2、设置各子页面标题"},{"role":"assistant","content":"```js\n首页\nuseHead({\n  title: '文章列表'\n})\n子页面\nuseHead({\n  titleTemplate: (s) => {\n    return s ? `${s} - 附属文本1` : \"附属文本2\";\n  },\n});\n```"}],"metadata":{},"filePath":"docs/guide/vue/nuxt/nuxt.md"}
{"messages":[{"role":"user","content":"3内置组件修改"},{"role":"assistant","content":"Nuxt 还提供了多种组件可以在模板中设置具体页面页头信息： , , , , , , , , ，像下面这样使用："}],"metadata":{},"filePath":"docs/guide/vue/nuxt/nuxt.md"}
{"messages":[{"role":"user","content":"插件"},{"role":"assistant","content":"```js\nexport default defineNuxtPlugin(nuxtApp => {\n  // Doing something with nuxtApp\n  console.log(nuxtApp)\n})\n```\nnuxtApp"}],"metadata":{},"filePath":"docs/guide/vue/nuxt/nuxt.md"}
{"messages":[{"role":"user","content":"VS Code"},{"role":"assistant","content":"VS Code 软件实在是太酷、太好用了，越来越多的新生代互联网民工正在使用它。\n前端男神 大大这样评价 VS Code：\n\n有一点你可能会感到惊讶：VS Code 这款软件本身，是用 JavaScript 语言编写的（具体请自行查阅基于 JS 的 PC 客户端开发框架 ）。Jeff Atwood 在 2007 年提出了著名的 Atwood 定律：\nJeff Atwood 这个人是谁不重要（他是 Stack Overflow 网站的联合创始人），重要的是这条定律。\n前端目前是处在春秋战国时代，各路英雄豪杰成为后浪，各种框架工具层出不穷，VS Code 软件无疑是大前端时代最骄傲的工具。\n如果你是做前端开发（JavaScript 编程语言为主），则完全可以将 VS Code 作为「 」。这款软件是为前端同学量身定制的，开箱即用。\n如果你是做其他语言方向的开发，并且不需要太复杂的集成开发环境，那么，你可以把 VS Code 作为「 」来使用，纵享丝滑。\n甚至是一些写文档、写作的同学，也经常把 VS Code 作为 markdown ，毫无违和感。\n退而求其次，即便你不属于以上任何范畴，你还可以把 VS Code 当作最简单的 来使用，完胜 Windows 系统自带的记事本。\n写下这篇文章，是顺势而为。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"一、惊艳登场：VS Code 的介绍"},{"role":"assistant","content":"VS Code 的全称是 Visual Studio Code，是一款开源的、免费的、跨平台的、高性能的、轻量级的代码编辑器。它在性能、语言支持、开源社区方面，都做得很不错。\n微软有两种软件：一种是 VS Code，一种是其他软件。\n在2015年4月29日的微软Build开发者大会上，微软宣布推出 VS Code之后，这个轻量级的编辑器成为全球无数开发者们最喜爱的开发工具。VS Code基于开源且跨平台的理念，每月都会进行迭代，并提供每天发布的 insider 版本（insider是微软的一种公测计划，类似于国内软件所说的内测版）。它拥有至少几万个插件，生态极为活跃和丰富。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"IDE 与 编辑器的对比"},{"role":"assistant","content":"IDE 和编辑器是有区别的：\n需要注意的是，VS Code 的定位是 ，而非 IDE ，但 VS Code 又比一般的编辑器的功能要丰富许多。可以这样理解：VS Code 的体量是介于编辑器和 IDE 之间。VS Code 的使命，是让开发者在编辑器里拥有 IDE 那样的开发体验。\nVS Code流行起来之后，使用 Sublime Text、Atom 这类编辑器软件的人，自然就越来越少了。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"前端利器之争： VS Code 与 WebStorm"},{"role":"assistant","content":"前端小白最喜欢问的一个问题是：哪个编辑器/IDE 好用？是 VS Code 还是 WebStorm （WebStorm 其实是 IntelliJ IDEA 的定制版）？我来做个对比：\n所以，如果你以后还问这个问题，那就真有些掉底了。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"VS Code 的技术栈、核心组件"},{"role":"assistant","content":"了解 VS Code的技术栈和核心组件，可以让我们对 VS Code 有更深入的认识。此小段，了解即可。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"VS Code 的安装"},{"role":"assistant","content":"VS Code 的安装很简单，直接去官网下载安装包，然后双击安装即可。\n\n上图中，直接点击 download，一键下载安装即可。\nVS Code支持以下平台：\n\n安装完成后的界面如下：\n\nVS Code被分为以下五个区域：\nVS Code在功能上非常克制，只包含了大多数开发流程中所需要的基础模块，包括：编辑器、文件管理、窗口管理、首选项设置、终端等。\n你需要根据具体需要安装额外的组件或者插件。比如说，如果开发TS项目，则需要安装 TS编译器，以及ESLint、TSLint等语法规则&代码风格的检查工具。如果开发C语言项目，则需要安装gcc、Clang等编译工具。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"二、崭露锋芒：VS Code 快捷键"},{"role":"assistant","content":"VS Code 用得熟不熟，首先就看你是否会用快捷键。以下列出的内容，都是常用快捷键，而加粗部分的快捷键，使用频率则非常高。\n任何工具，掌握 20%的技能，足矣应对 80% 的工作。既然如此，你可能会问：那就只保留 20% 的特性，不久可以满足 80%的用户了吗？\n但我想说的是： ，每个人都会用到不同的功能。\n掌握下面这些高频核心快捷键，你和你的工具，足矣露出锋芒。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"4、编辑操作"},{"role":"assistant","content":"另外再补充一点：将光标点击到某一行的任意位置时，默认就已经是 了，此时可以直接 或 ，无需点击鼠标。这个非常实用，是所有的编辑操作中，使用得最频繁的。它可以有以下使用场景：\n你看到了没？上面的两个场景，我全程没有使用鼠标，只通过简单的复制粘贴和方向键，就做到了如此迅速的copy代码。你说是不是很高效？"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"5、删除操作"},{"role":"assistant","content":"备注：上面所讲到的移动光标、编辑操作、删除操作的快捷键，在其他编辑器里，大部分都适用。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"6、多光标选择/多光标编辑"},{"role":"assistant","content":"多光标选择在编程的 方面可谓立下了汗马功劳。因为比较难记住，所以你要时不时回来复习这一段。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"7、多列选择/多列编辑"},{"role":"assistant","content":"多列选择是更高效的多光标选择，所以单独列成一小段。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"10、自定义快捷键"},{"role":"assistant","content":"按住快捷键「Cmd + Shift + P」，弹出命令面板，在命令面板中输入“快捷键”，可以进入快捷键的设置。\n当然，你也可以选择菜单栏「偏好设置 --> 键盘快捷方式」，进入快捷键的设置：\n\n此外，如果你输入这个快捷键后没起作用，那有可能是与其他软件（比如 PicGo 软件）的快捷键冲突了，请检查一下。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"11、快捷键列表"},{"role":"assistant","content":"你可以点击 VS Code 左下角的齿轮按钮，效果如下：\n\n上图中，在展开的菜单中选择「键盘快捷方式」，就可以查看和修改所有的快捷键列表了："}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"快捷键参考表（官方）"},{"role":"assistant","content":"VS Code官网提供了 PDF版本的键盘快捷键参考表，转需：\n我们在 VS Code软件里通过菜单栏「帮助-->键盘快捷方式参考」也可以打开相应平台的快捷键大全（PDF版本）。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"三、高端访问：命令面板的使用"},{"role":"assistant","content":"Mac 用户按住快捷键 （Windows 用户按住快捷键 ），可以打开快速命令面板。效果如下：\n\n命令面板的作用是 。如果让开发者记住所有的配置项在菜单的哪个位置是不现实的，而且有些命令并不在菜单中。\n有了命令面板之后，如果你需要修改一些设置项，或者进行一些快捷操作，则可以通过「命令面板」来操作，效率会更高。接下来列举一些。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"1、VS Code 设置为中文语言"},{"role":"assistant","content":"Mac 用户按住快捷键 （Windows 用户按住快捷键 ），打开命令面板。\n在命令面板中，输入 ，选择 ，然后安装插件 即可。\n或者，我们可以直接安装插件 ，是一样的。\n安装完成后，重启 VS Code。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"2、设置字体大小"},{"role":"assistant","content":"在命令面板输入“字体”，可以进行字体的设置，效果如下：\n\n当然，你也可以在菜单栏，选择「首选项-设置-常用设置」，在这个设置项里修改字体大小。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"3、快捷键设置"},{"role":"assistant","content":"在命令面板输入“快捷键”，就可以进入快捷键的设置。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"4、大小写转换"},{"role":"assistant","content":"选中文本后，在命令面板中输入 ，就可以修改文本的大小写了。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"5、使用命令行启动 VS Code"},{"role":"assistant","content":"（1）输入快捷键「Cmd + Shift + P 」，选择 ：\n\n（2）使用命令行：\n备注：这种方法快捷简单，但是在电脑重启之后就失效了。稍后在第五段，我会介绍更常见的方法。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"6、修改特定编程语言的设置项"},{"role":"assistant","content":"输入快捷键「Cmd + Shift + P 」打开命令面板，然后输入并执行 即可。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"0、设置项介绍"},{"role":"assistant","content":"在修改 VS Code配置之前，我们需要知道，在哪里可以找到设置项的入口。\n：Mac用户选择菜单栏「Code--> 首选项-->设置」，即可打开配置项：\n\n：点击软件右下角的设置图标：\n\n\n如上图所示，VS Code提供两种不同范围的设置：\n操作技巧：\n（1）我们可以在设置面板的顶部搜索框，输入关键词，就能迅速定位到你想要的设置项。\n（2）上图中，点击右上角的icon，可以通过 json文件的形式修改设置项。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"1、修改主题"},{"role":"assistant","content":"1）修改颜色主题：\n选择菜单栏「Code --> 首选项 --> 颜色主题」：\n\n在弹出的对话框中，挑选你一个你喜欢的的颜色主题吧，或者安装其他颜色的主题：\n\n或者在设置项里搜索 ，进行修改。\n2）修改文件图标的主题：\n选择菜单栏「Code --> 首选项 --> 文件图标主题」：\n\n在弹出的对话框中，挑选你一个你喜欢的的主题吧，或者安装其他的主题：\n\n或者在设置项里搜索 ，进行修改。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"2、面包屑（Breadcrumb）导航"},{"role":"assistant","content":"打开 VS Code 的设置项，选择「用户设置 -> 工作台 -> 导航路径」，如下图所示：\n\n上图中，将红框部分打钩即可。\n设置成功后，我们就可以查看到当前文件的「层级结构」，非常方便。如下图所示：\n\n有了这个面包屑导航，我们可以点击它，在任意目录、任意文件之间随意跳转。使用频繁非常高。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"3、是否显示代码的行号"},{"role":"assistant","content":"VS Code 默认显示代码的行号。你可以在设置项里搜索 修改设置，配置项如下：\n\n我建议保留这个设置项，无需修改。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"4、右侧是否显示代码的缩略图"},{"role":"assistant","content":"如果某个文件的代码量很大，缩略图就很有用了，可以预览全局，并在当前文件中快速跳转。\nVS Code 会在代码的右侧，默认显示缩略图。你可以在设置项里搜索 进行设置，配置项如下：\n\n上面这张图，你仔细琢磨下会发现，中文翻译十分精准。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"5、将当前行代码高亮显示（更改光标所在行的背景色）"},{"role":"assistant","content":"当我们把光标放在某一行时，这一行的背景色并没有发生变化。如果想 当前行的代码，需要设置两步：\n（1）在设置项里搜索 ，将选项值设置为 或者 。\n（2）在设置项里增加如下内容：\n```json\n\"workbench.colorCustomizations\": {\n    \"editor.lineHighlightBackground\": \"#00000090\",\n    \"editor.lineHighlightBorder\": \"#ffffff30\"\n}\n```\n上方代码，第一行代码的意思是：修改光标所在行的背景色（背景色设置为全黑，不透明度 90%）；第二行代码的意思是：修改光标所在行的边框色。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"6、改完代码后立即自动保存"},{"role":"assistant","content":"：\n改完代码后，默认不会自动保存。你可以在设置项里搜索 ，修改参数值为 ，即可自动保存。如下：\n\nfiles.autoSave的参数值有以下几种：\n：\n当然，你也可以直接在菜单栏选择「文件-自动保存」。勾选后，当你写完代码后，文件会立即实时保存。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"7、热退出"},{"role":"assistant","content":"当VS Code退出后，它可以记住未保存的文件。如果你希望达到这种效果，那么，你需要先将设置项 的值改为 。这个配置项要不要改，看你个人需要。比如我自己平时设置的值是 。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"8、保存代码后，是否立即格式化"},{"role":"assistant","content":"保存代码后，默认 进行代码的格式化。你可以在设置项里搜索 查看该配置项：\n\n我觉得这个配置项保持默认就好，不用打钩。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"9、自动格式化粘贴的内容"},{"role":"assistant","content":"在设置项里搜索 ，将设置项改为 ："}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"10、设置字体大小"},{"role":"assistant","content":"在设置项里搜索 ，然后根据需要设置各种模块的字体大小："}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"11、空格 or 制表符"},{"role":"assistant","content":"VS Code 会根据你所打开的文件来决定该使用空格还是制表。也就是说，如果你的项目中使用的都是制表符，那么，当你在写新的代码时，按下 tab 键后，编辑器就会识别成制表符。\n（1）建议的设置项如下：\n\n这样做，是为了取消系统的自动缩进，建议自己手动格式化比较好。 参考链接：\n\n\n（2）状态栏也会显示当前的缩进值。点击状态栏，可以直接修改 tabSize 缩进值：\n\n（3）另外，我们还可以安装 prettier 插件，设置代码在格式化时默认缩进值。prettier 是做代码格式化的最常见工具。\n\n（4）去掉每一行末尾的空格。在设置项里搜索 或者 ，将值设置为 true：\n\n一般来说，每一行代码末尾的空格是多余的，所以建议去掉。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"12、直观地显示代码里的空格和缩进 ✨"},{"role":"assistant","content":"代码里如果有缩进或者空格，肉眼是看不出来的，但是我们可以修改配置项，把它揪出来。\n在配置项里搜索 ，修改为 ：\n\n修改之后，代码里的空格、缩进的展示效果如下：\n\n看到了没？哪里有空格、哪里是缩进，全都一目了然。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"13、新建文件后的默认文件类型"},{"role":"assistant","content":"当我们按下快捷键「Cmd + N」新建文件时，VS Code 默认无法识别这个文件到底是什么类型的，因此也就无法识别相应的语法高亮。\n如果你想修改默认的文件类型，可以在设置项里搜索 ，设置项如下：\n\n上图中的红框部分，填入你期望的默认文件类型。我填的是 类型，你也可以填写成 或者 ，或者其他的语言类型。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"14、删除文件时，是否弹出确认框"},{"role":"assistant","content":"当我们在 VS Code 中删除文件时，默认会弹出确认框。如果你想修改设置，可以在设置项里搜索 。截图如下：\n\n我建议这个设置项保持默认的打钩就好，不用修改。删除文件前的弹窗提示，也是为了安全考虑，万一手贱不小心删了呢？"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"15、在新窗口打开文件/文件夹"},{"role":"assistant","content":"通过 （默认值为off）和 （默认值为default），可以配置在打开文件夹、打开文件时，是否开启一个新的窗口。我个人建议，把这两个配置项都设置为 on，避免旧的窗口被覆盖：\n\n补充知识—— 可以用来配置 如何恢复之前的会话窗口。涉及到的场景是：你把 VS Code 关闭了，然后又打开了，是否要展示之前打开过的文件、文件夹？参数值有以下几种："}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"16、自动删除行尾的空格"},{"role":"assistant","content":"打开设置项，搜索 ，将选项勾选，即可在保存文件时自动删除行尾的空格。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"17、突出显示成对的括号"},{"role":"assistant","content":"我们可以用不同颜色显示代码中成对的括号，并用连线标注括号范围。简称 。\n最早是通过 插件支持的，但是这个插件已经被废弃了，因为 VS Code 已经内置了该功能。我们可以通过 VS Code的如下配置项，达到效果：\n```json\n{\n  \"editor.bracketPairColorization.enabled\": true,\n  \"editor.guides.bracketPairs\": \"active\"\n}\n```"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"18、自动换行"},{"role":"assistant","content":"自动换行：意味着当文本到达屏幕或页面的右边缘时，自动换行会将文本移到下一行，以便继续输入或显示。\n打开设置项，搜索 ，将选项值设置为 on。\n此外，你还可以选择菜单栏 ，即可将当前文件设置为自动换行。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"1、快速生成HTML骨架"},{"role":"assistant","content":"先新建一个空的html文件，然后通过以下方式，可以快速生成html骨架。\n：输入 ，然后按下 键，即可生成html骨架。如下图：\n\n：输入 ，然后按住 键，即可生成html骨架。\n生成的骨架，内容如下：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n```\n有了上面的html骨架之后，我们就可以快乐地在里面插入CSS 代码和 JS 代码。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"2、并排编辑：左右（上下）显示多个编辑器窗口（copy代码利器）"},{"role":"assistant","content":"Mac 用户按住快捷键 ， Windows 用户按住快捷键 ，即可同时打开多个编辑器窗口，进行并排编辑。效果如下：\n\n按快捷键「Cmd + 1 」切换到左边的窗口，按快捷键「Cmd + 2 」切换到右边的窗口，以此类推。随时随地，想切就切。\n学会了这一招，以后 copy 代码的时候，leader 再也不用担心我抄得慢了，一天工资到手。\n当然，使用快捷键 只是其中一种方式，我们还有很多种方式打开并行编辑。我们来做一个汇总。\n如果你已经打开了一个编辑器，那么可以通过以下几种方式在另一侧打开另一个编辑器：（按照使用频率，从高到低排序）\n\n补充知识：通过配置项 可以控制编辑器在并排打开时出现的默认位置（默认值为right，你也可以根据需要改为 down）。如下图所示："}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"3、从终端 code 命令启动 VS Code（Mac电脑）"},{"role":"assistant","content":"在终端输入 或者输入 ，就可以启动 VS Code，十分便捷。即：\n为了达到目的，我们需要先将 VS Code的软件安装路径添加到环境变量，一劳永逸。具体操作如下：\n（1）打开 文件：\n```bash\ncd ~\nvim ./bash_profile\n```\n（2）在 bash_profile 中添加如下内容：\n```bash\n# 从终端启动VS Code，并设置vscode启动的命令别名\nalias code=\"/Applications/Visual\\ Studio\\ Code.app/Contents/Resources/app/bin/code\"\n```\n注意，由于 这个路径里有空格，所以需要在空格前面加上反斜杠 。\n（3）重启环境变量的配置：\n```\n# 重启\nsource ~/.bash_profile\n```\n大功告成。\n改完之后，如果没生效，那你把 文件 换成 文件试试。\n参考链接：\n当然，还可以通过命令面板，一键设置环境变量。具体做法是：输入快捷键「Cmd + shift + P」打开命令面板，然后选择 ：\n\n完成后就可以在终端输入命令+文件路径来启动 VS Code 了。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"3、从终端 code 命令启动 VS Code（Windows电脑）"},{"role":"assistant","content":"在终端输入 或者输入 ，就可以启动 VS Code，十分便捷。即：\n为了达到目的，我们需要先将 VS Code的软件安装路径添加到环境变量，一劳永逸。具体操作如下：\n（1）打开 VS Code 的安装位置，进入bin文件夹，复制路径。比如： 。\n（2）回到桌面，右键我的电脑-->高级系统设置-->环境变量-->编辑path值，在原来的path后面，追加内容 （即英文的分号+VS Code 的 bin 路径)\n（3）重启电脑，大功告成。\n改完之后，如果没生效，那八成是因为你填的 path 值有问题。\n参考链接："}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"4、在当前文件中搜索"},{"role":"assistant","content":"在上面的快捷键列表中，我们已经知道如下快捷键：\n多个搜索结果出来之后，按下 Enter 键之后跳转到下一个搜索结果，按下 Shift + Enter 键之后跳转到上一个搜索结果。\n另外，你可能会注意到，搜索框里有很多按钮，每个按钮都对应着不同的功能，如下图所示：\n\n上图中，你可以通过「Tab」键和「Shift + Tab」键在输入框和替换框之间进行切换。\n「在选定内容中查找」这个功能还是比较实用的。你也可以在设置项里搜索 ，勾选该设置项后，那么，当你选中指定内容后，然后按住「Cmd + F」，就可以 只在这些内容里进行查找。该设置项如下图所示："}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"5、全局搜索"},{"role":"assistant","content":"在上面的快捷键列表中，我们已经知道如下快捷键：\n\n上图中，你可以点击 部分，展开更多的配置项。然后点击 部分，进行过滤搜索。注意，第二个红圈那里会经常用到，它可以在搜索时过滤掉 、 等忽略文件。\n上图中，我们还可以点击“在编辑器中打开”，在一个单独的文件中聚合展示搜索结果："}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"6、文件名/文件夹的搜索"},{"role":"assistant","content":"前面的快捷键那一段我们讲过，通过 「Cmd + P」可以快速搜索并打开 /文件夹。这种方式，一般用于快速打开最近编辑过的文件。\n其实还有一种很巧妙的方式，可以在整个项目里，既能搜到文件，也能搜到 。这种方式，常用于 。操作方法很简单：\n\n当然，这招也有一点不足：不能搜中文。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"7、大纲视图"},{"role":"assistant","content":"如下图所示，大纲视图可以展示当前代码的方法结构、文件的目录结构："}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"8、文件对比"},{"role":"assistant","content":"VS Code 默认支持 。选中两个文件，然后右键选择「将已选项进行比较」即可，效果如下：\n\nVS Code 自带的对比功能并不够强大，我们可以安装插件 ，进行更丰富的对比。比如说，安装完插件 之后，我们可以将「当前文件」与「剪切板」里的内容进行对比：\n\n如果你安装了 GitLens 插件，还可以将两个git分支的代码进行比对，非常完美。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"9、查找某个函数在哪些地方被调用了"},{"role":"assistant","content":"比如我已经在 文件里调用了 函数。那么，如果我想知道 函数在其他文件中是否也被调用了，该怎么做呢？\n做法如下：在 文件里，选中 函数（或者将光标放置在 函数上），然后按住快捷键「Shift + F12」，就能看到 函数在哪些地方被调用了，比较实用。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"11、重构"},{"role":"assistant","content":"重构分很多种，我们来举几个例子。\n：\n当我们尝试去修改某个函数（或者变量名）时，我们可以把光标放在上面，然后按下「F2」键，那么，这个函数（或者变量名）出现的地方都会被修改。\n：\n选中某一段代码，这个时候，代码的左侧会出现一个「灯泡图标」，点击这个图标，就可以把这段代码提取为一个单独的函数。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"12：终端配置"},{"role":"assistant","content":"VS Code软件自带了终端，但我个人认为不是很好用，而且VS Code 软件关了之后，终端也没了。建议大家使用其他的终端软件，专业的事情交给专业的人做。\n："}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"13、Git 版本管理"},{"role":"assistant","content":"在 VS Code中使用Git之前，需要你先安装 Git 环境。\nVS Code 自带了 Git 版本管理的功能，如下图所示：\n\n上图中，我们可以在这里进行常见的 git 命令操作。如果你还不熟悉 ，可以先去补补课。\n我自己用的最多的功能是 和 ，自从用上了 VS Code 的这两个功能，简直离不开它。\n我们先来看看 diff 代码的效果：\n\n上图中，点击右上角的 ，然后点击 ，则可以换一种视图 diff 代码：\n\n：\n\n在VS Code的左下角会显示Git状态栏。如果当前代码仓库配置了远程仓库，那么“同步更改”会显示以下信息：\n点击“同步更改”按钮，会拉取（pull）远程分支到本地分支，并推送（push）本地的Git commit到远程分支。\n如果当前代码仓库没有配置远程仓库，则会显示“发布更改”的按钮。点击“发布更改”按钮，会把当前分支push到远程仓库。\n另外，我建议安装插件 搭配使用，它是 VS Code 中我最推荐的一个插件，简直是 Git 神器，码农必备。\n我还要补充一句：\n有人说，高手都是直接用命令行操作Git。然而，根据我多年的经验来看，如果你的代码仓库需要管理的分支特别多，与团队的其他成员需要经常协作，那么，我建议你 GUI 图形化工具来操作Git，避免出错。\n我推荐的GUI版的Git工具有："}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"14、将工作区放大/缩小"},{"role":"assistant","content":"我们在上面的设置项里修改字体大小后，仅仅只是修改了代码的字体大小。\n如果你想要缩放整个工作区（包括代码的字体、左侧导航栏的字体等），可以按下快捷键「 」。windows 用户是按下「ctrl +/-」\n。\n如果你想恢复默认的工作区大小，可以在命令面板输入 （英文是 ）\nf### 11、创建多层子文件夹\n我们可以在新建文件夹的时候，如果直接输入 ，比如：\n\n那么，就可以创建多层子文件夹，效果如下："}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"15、 文件夹的作用"},{"role":"assistant","content":"为了统一团队的 vscode 配置，我们可以在项目的根目录下建立 目录，在里面放置一些配置内容，比如：\n目录里的配置只针对当前项目范围内生效。将 提交到代码仓库，大家统一配置时，会非常方便。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"16、自带终端"},{"role":"assistant","content":"我们可以按下「Ctrl + `」打开 VS Code 自带的终端。我认为内置终端并没有那么好用，我更建议你使用第三方的终端 。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"17、markdown 语法支持"},{"role":"assistant","content":"VS Code 自带 markdown 语法高亮。也就是说，如果你是用 markdown 格式写文章，则完全可以用 VS Code 进行写作。\n写完 md 文件之后，你可以点击右上角的按钮进行预览，如下图所示：\n\n我一般是安装「Markdown Preview Github Styling」插件，以 GitHub 风格预览 Markdown 样式。样式十分简洁美观。\n你也可以在控制面板输入 ，直接全屏预览 markdown 文件。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"18、Emmet in VS Code"},{"role":"assistant","content":"可以极大的提高 html 和 css 的编写效率，它提供了一种非常简练的语法规则。\n举个例子，我们在编辑器中输入缩写代码： ，然后按下 Tab 键，即可得到如下代码片段：\n```html\n<ul>\n  <li></li>\n  <li></li>\n  <li></li>\n  <li></li>\n  <li></li>\n  <li></li>\n</ul>\n```\nVS Code 默认支持 Emmet。更多 Emmet 语法规则，可以自行查阅。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"19、修改字体，使用「Fira Code」字体"},{"role":"assistant","content":"这款字体很漂亮，很适合用来写代码：\n\n安装步骤如下：\n（1）进入 网站，下载并安装「Fira Code」字体。\n（2）打开 VS Code 的「设置」，搜索 ，修改相关配置为如下内容：\n```json\n\"editor.fontFamily\": \"'Fira Code',Menlo, Monaco, 'Courier New', monospace\", // 设置字体显示\n\"editor.fontLigatures\": false,//控制是否启用字体连字，true启用，false不启用\n```\n上方的第二行配置，取决于个人习惯，我是直接设置为 ，因为我不太习惯连字。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"20、代码格式化"},{"role":"assistant","content":"VS Code 默认对 JavaScript、TypeScript、JSON、HTML 提供了开箱即用的代码格式化支持。其他语言则需要先安装相应的插件才能支持。\n另外，我们还可以安装 Prettier 插件进行 的代码格式化。下一段将插件的时候，会讲解。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"21、智能提示 IntelliSense"},{"role":"assistant","content":"VS Code 默认对 JavaScript、TypeScript、JSON、HTML、CSS、SCSS、Less这7种语言（文件）提供了 的支持。其他编程语言则需要先安装相应的插件才能支持。\n在 VS Code插件职场中，下图是最受欢迎的8种 ：\n\n智能提示的功能很强大， 包括函数介绍、代码自动补全等等。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"22、调试与运行"},{"role":"assistant","content":"VS Code 了对 Node.js 运行时的调试支持，可以直接调试 JavaScript 和 TypeScript。其他编程语言的调试，则需要先安装相应的插件才能支持。\n在 VS Code插件市场中，下图是最受欢迎的几种调试插件："}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"23、文件传输：sftp"},{"role":"assistant","content":"如果你需要将本地文件通过 ftp 的形式上传到局域网的服务器（需要先把服务端的配置搭建好），可以安装 这个插件，很好用。在公司会经常用到。\n步骤如下：\n（1）安装插件 。\n（2）配置 文件。 插件安装完成后，输入快捷键「cmd+shift+P」弹出命令面板，然后输入 ，回车，当前工程的 文件夹下就会自动生成一个 文件，我们需要在这个文件里配置的内容可以是：\n举例如下：(注意，其中的注释需要去掉)\n```json\n{\n  \"host\": \"192.168.xxx.xxx\", //服务器ip\n  \"port\": 22, //端口，sftp模式是22\n  \"username\": \"\", //用户名\n  \"password\": \"\", //密码\n  \"protocol\": \"sftp\", //模式\n  \"agent\": null,\n  \"privateKeyPath\": null,\n  \"passphrase\": null,\n  \"passive\": false,\n  \"interactiveAuth\": false,\n  \"remotePath\": \"/root/node/build/\", //服务器上的文件地址\n  \"context\": \"./server/build\", //本地的文件地址\n\n  \"uploadOnSave\": true, //监听保存并上传\n  \"syncMode\": \"update\",\n  \"watcher\": {\n    //监听外部文件\n    \"files\": false, //外部文件的绝对路径\n    \"autoUpload\": false,\n    \"autoDelete\": false\n  },\n  \"ignore\": [\n    //忽略项\n    \"**/.vscode/**\",\n    \"**/.git/**\",\n    \"**/.DS_Store\"\n  ]\n}\n```\n（3）在 VS Code 的当前文件里，选择「右键 -> upload」，就可以将本地的代码上传到 指定的 ftp 服务器上（也就是在上方 中配置的服务器 ip）。\n我们还可以选择「右键 -> Diff with Remote」，就可以将本地的代码和 ftp 服务器上的代码做对比，非常方便。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"24、沉浸模式/禅模式"},{"role":"assistant","content":"程序员写代码需要专注，有时需要进入一种心流。VS Code给我们提供了一种全屏下的沉浸模式，周围的面板都会被隐藏起来，只显示编辑器部分。\n操作方法：菜单栏选择「查看-外观-禅模式」即可；或者按下快捷键 ，放手，再按 也可以达到目的。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"25、远程同步 VS Code 配置项"},{"role":"assistant","content":"北京时间的 ，微软发布 Visual Studio Code 1.48 稳定版。此版本 支持用户同步 VS Code的配置，只需要登录微软账号或者 GitHub 账号即可。\n有了这个功能之后，我们可以先在老电脑上登录账号，即可将软件的配置项自动开启云同步。当你下次换一个新的电脑，下载安装 VS Code，点击软件左下角的设置按钮，登录此前的微软账号或GitHub账号，即可自动将旧电脑的软件配置项，同步到新电脑的软件上。极其方便。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"26、正则表达式批量删除字符串"},{"role":"assistant","content":"：将文本中的字符串 ，批量替换为 。其中，开头字符 a 和 结尾字符 b 固定，中间xxx长度不确定。\n：传统查找替换无法胜任。可以使用VScode正则表达式功能，查找 替换为 即可。其中 是禁止贪婪匹配，否则会误删很多内容。\n：需求——将文本中的字符串 ，批量替换为 。其中，开头字符 a 固定，后面的xxx长度不确定。\n：传统查找替换无法胜任。可以使用VScode正则表达式功能，查找 替换为 即可。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"六、三头六臂：VS Code 插件介绍 & 插件推荐"},{"role":"assistant","content":"VS Code 有一个很强大的功能就是支持插件扩展，让你的编辑器仿佛拥有了三头六臂。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"安装插件"},{"role":"assistant","content":"上图中，点击红框部分，即可在顶部输入框里，查找你想要的插件名，然后进行安装。\n插件安装完成后，记得重启软件（或者点击插件位置的“重新加载”），插件才会生效。\n另外，我们还可以访问官网的插件市场来安装插件：\n："}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"插件的类型"},{"role":"assistant","content":"插件市场的首页有四个模块，可以作为重要的信息来源：\n\n\n插件市场至少有17种类型的插件：（按照数量排序）"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"插件的过滤显示"},{"role":"assistant","content":"在 VS Code中打开插件管理视图，可以针对已安装的插件，进行过滤展示。\n1）点击插件视图右上角的 按钮，可以展示不同状态的插件：\n\n2）在搜索框输入字符 ，会展示出不同类型的过滤器：\n\n：\n1）按大类搜：\n2）精准搜索：\n3）对插件进行排序：\n4）组合搜索：（举例）\n下面的内容，我来列举一些常见的插件，这些插件都很实用，小伙伴们可以按需安装。注意：每一类插件里， 。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Chinese (Simplified) Language Pack for Visual Studio Code"},{"role":"assistant","content":"让软件显示为简体中文语言。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"GitLens 【荐】"},{"role":"assistant","content":"我强烈建议你安装插件 ，它是 VS Code 中我最推荐的一个插件，简直是 Git 神器，码农必备。如果你不知道，那真是 out 了。\nGitLens 在 Git 管理上有很多强大的功能，比如：\n打开你的 Git仓库，未安装 GitLens 时是这样的：\n\n安装了 GitLens 之后是这样的：\n\n上图中，红框部分就是 GitLens 的功能，诸君可以自由发挥。\n补充一个有意思的趣事：Python插件、Ruby插件、GitLens插件、Vetur插件，这四个插件的开发者先后加入了微软。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Git History"},{"role":"assistant","content":"有些同学习惯使用编辑器中的 Git 管理工具，而不太喜欢要打开另外一个 Git UI 工具的同学，这一款插件满足你查询所有 Git 记录的需求。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Local History 【荐】"},{"role":"assistant","content":"维护文件的本地历史记录。代码意外丢失时，有时可以救命。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Vetur"},{"role":"assistant","content":"Vue 多功能集成插件，包括：语法高亮，智能提示，emmet，错误提示，格式化，自动补全，debugger。VS Code 官方钦定 Vue 插件，Vue 开发者必备。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"ES7 React/Redux/GraphQL/React-Native snippets"},{"role":"assistant","content":"React/Redux/react-router 的语法智能提示。\n安装该插件后，在代码中只需要输入 即可自动补全 这行代码。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"JavaScript(ES6) code snippets"},{"role":"assistant","content":"ES6 语法智能提示，支持快速输入。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"javascript console utils：快速打印 log 日志【荐】"},{"role":"assistant","content":"安装这个插件后，当我们按住快捷键「Cmd + Shift + L」后，即可自动出现日志 。简直是日志党福音。\n当我们选中某个变量 ，然后按住快捷键「Cmd + Shift + L」，即可自动出现这个变量的日志 。\n其他的同类插件还有：Turbo Console Log。\n不过，生产环境的代码，还是尽量少打日志比较好，避免出现一些异常。\n编程有三等境界："}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Code Spell Checker：单词拼写错误检查"},{"role":"assistant","content":"这个拼写检查程序的目标是帮助捕获常见的单词拼写错误，可以检测驼峰命名。从此告别 Chinglish."}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Auto Close Tag、Auto Rename Tag"},{"role":"assistant","content":"自动闭合配对的标签、自动重命名配对的标签。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"highlight-icemode：选中相同的代码时，让高亮显示更加明显"},{"role":"assistant","content":"VSCode 自带的高亮显示，实在是不够显眼。可以用插件支持一下。\n所用了这个插件之后，VS Code 自带的高亮就可以关掉了：\n在用户设置里添加 即可。\n参考链接："}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"vscode-icons"},{"role":"assistant","content":"vscode-icons 会根据文件的后缀名来显示不同的图标，让你更直观地知道每种文件是什么类型的。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"indent-rainbow：突出显示代码缩进"},{"role":"assistant","content":"插件：突出显示代码缩进。\n安装完成后，效果如下图所示："}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"TODO Highlight"},{"role":"assistant","content":"写代码过程中，突然发现一个 Bug，但是又不想停下来手中的活，以免打断思路，怎么办？按照代码规范，我们一般是在代码中加个 TODO 注释。比如：（注意，一定要写成大写 ，而不是小写的 ）\n```\n//TODO:这里有个bug，我一会儿再收拾你\n```\n或者：\n```\n//FIXME:我也不知道为啥， but it works only that way.\n```\n安装了插件 之后，按住「Cmd + Shift + P」打开命令面板，输入「Todohighlist」，选择相关的命令，我们就可以看到一个 todoList 的清单。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Better Comments"},{"role":"assistant","content":"为注释添加更醒目、带分类的色彩。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Prettier：代码格式化"},{"role":"assistant","content":"Prettier 是一个代码格式化工具， 。在一个多人协同开发的团队中，统一的代码编写规范非常重要。一套规范可以让我们编写的代码达到一致的风格，提高代码的可读性和统一性。自然维护性也会有所提高，代码的展示也会更加美观。\n步骤如下：\n（1）安装插件 。\n（2）在项目的根路径下，新建文件 ，并在文件中添加如下内容：\n```json\n{\n  \"printWidth\": 150,\n  \"tabWidth\": 4,\n  \"semi\": true,\n  \"singleQuote\": true,\n  \"trailingComma\": \"es5\",\n  \"tslintIntegration\": true,\n  \"insertSpaceBeforeFunctionParenthesis\": false\n}\n```\n上面的内容，是我自己的配置，你可以参考。更多配置，可见官方文档：\n（3）Mac用户按快捷键「Option + Shift + F」，Win 用户按快捷键「Alt + shift + F」，即可完成代码的格式化。如果你的VS Code 设置的是自动格式化代码，那么这一步可以忽略。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"ESLint：代码格式的校验"},{"role":"assistant","content":"日常开发中，建议用 Prettier 做 ，然后用 eslint 做 。很多人把这两个插件的功能弄混了。\n一般做法是：格式化建议是由程序员手动触发，格式校验由系统强制校验。通过 Prettier 触发格式化，是为了让用户有感知；通过eslint 做 校验之后，如果代码的格式不符合要求，系统就禁止你提交代码。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Beautify"},{"role":"assistant","content":"代码格式化工具。\n备注：相比之下，Prettier 是当前最流行的代码格式化工具，比 Beautify 用得更多。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Paste JSON as Code"},{"role":"assistant","content":"此插件可以将剪贴板中的 JSON 字符串转换成工作代码。支持多种语言。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"JS-CSS-HTML Formatter【荐】"},{"role":"assistant","content":"保存文件时，自动格式化 HTML、CSS、JS代码。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Polacode-2020：生成代码截图 【荐】"},{"role":"assistant","content":"可以把代码片段保存成美观的图片，主题不同，代码的配色方案也不同，也也可以自定义设置图片的边框颜色、大小、阴影。\n尤其是在我们做 PPT 分享时需要用到代码片段时，或者需要在网络上优雅地分享代码片段时，这一招很有用。\n生成的效果如下：\n\n其他同类插件： 。我们也可以通过 这个网站生成代码图片\n有人可能会说：直接用 QQ 截图不行吗？可以是可以，但不够美观、不够干净。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Image Preview 【荐】"},{"role":"assistant","content":"图片预览。鼠标移动到图片 url 上的时候，会自动显示图片的预览和图片尺寸。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"CSS Peek"},{"role":"assistant","content":"增强 HTML 和 CSS 之间的关联，快速查看该元素上的 CSS 样式。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Vue CSS Peek"},{"role":"assistant","content":"CSS Peek 对 Vue 没有支持，该插件提供了对 Vue 文件的支持。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Color Info"},{"role":"assistant","content":"这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Markdown Preview Github Styling 【荐】"},{"role":"assistant","content":"以 GitHub 风格预览 Markdown 样式，十分简洁优雅。就像下面这样，左侧书写 Markdown 文本，右侧预览 Markdown 的渲染效果："}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Markdown Preview Enhanced"},{"role":"assistant","content":"预览 Markdown 样式。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Markdown All in One"},{"role":"assistant","content":"这个插件将帮助你更高效地在 Markdown 中编写文档。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"sftp：文件传输 【荐】"},{"role":"assistant","content":"如果你需要将本地文件通过 ftp 的形式上传到局域网的服务器，可以安装 这个插件，很好用。在公司会经常用到。\n详细配置已经在上面讲过。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Live Server 【荐】"},{"role":"assistant","content":"在本地启动一个服务器，代码写完后可以实现「热更新」，实时地在网页中看到运行效果。就不需要每次都得手动刷新页面了。\n使用方式：安装插件后，开始写代码；代码写完后，右键选择「Open with Live Server」。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"open in browser"},{"role":"assistant","content":"安装 插件后，在 HTML 文件中「右键选择 --> Open in Default Browser」，即可在浏览器中预览网页。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Project Manager"},{"role":"assistant","content":"工作中，我们经常会来回切换多个项目，每次都要找到对应项目的目录再打开，比较麻烦。Project Manager 插件可以解决这样的烦恼，它提供了专门的视图来展示你的项目，我们可以把常用的项目保存在这里，需要时一键切换，十分方便。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"WakaTime 【荐】"},{"role":"assistant","content":"统计在 VS Code 里写代码的时间。统计效果如下："}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Code Time"},{"role":"assistant","content":"插件：记录编程时间，统计代码行数。\n安装该插件后，VS Code 底部的状态栏右下角可以看到时间统计。点击那个位置之后，选择「Code Time Dashboard」，即可查看统计结果。\n备注：团长试了一下这个 code time 插件，发现统计结果不是很准。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"File Tree to Text Generator：快速生成文件的目录树"},{"role":"assistant","content":"如题。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"minapp：小程序支持"},{"role":"assistant","content":"小程序开发必备插件。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Search node_modules"},{"role":"assistant","content":"模块里面的文件夹和模块实在是太多了，根本不好找。好在安装 这个插件后，输入快捷键「Cmd + Shift + P」，然后输入 ，在弹出的选项中选择 ，即可搜索 node_modules 里的模块。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"RemoteHub"},{"role":"assistant","content":"不要惊讶，RemoteHub 和 GitLens 是同一个作者开发出来的。\n插件的作用是：可以在本地查看 GitHub 网站上的代码，而不需要将代码下载到本地。\n\n这个插件目前使用的人还不多，赶紧安装起来尝尝鲜吧。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Live Share：实时编码分享"},{"role":"assistant","content":"这个神奇的插件是由微软官方出品，它的作用是： 。也就是说，它可以实现你和你的同伴一起写代码。这绝对就是 的神器啊。\n安装方式：\n打开插件管理，搜索“live share”，安装。安装后重启 VS Code，在左侧会多出一个按钮：\n\n上图中，点击红框部分，登录后就可以分享你的工作空间了。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Import Cost"},{"role":"assistant","content":"在项目开发过程中，我们会引入很多 npm 包，有时候可能只用到了某个包里的一个方法，却引入了整个包，导致代码体积增大很多。 插件可以在代码中友好的提示我们，当前引入的包会增加多少体积，这很有助于帮我们优化代码的体积。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"10、主题插件"},{"role":"assistant","content":"给你的 VS Code 换个皮肤吧，免费的那种。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"七、无缝切换：VS Code 配置云同步"},{"role":"assistant","content":"我们可以将配置云同步，这样的话，当我们换个电脑时，即可将配置一键同步到本地，就不需要重新安装插件了，也不需要重新配置软件。\n下面讲的两个同步方法，都可以，看你自己需要。方法1是 VS Code自带的同步功能，操作简单。方法2 需要安装插件，支持更多的自定义配置。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"方法1：使用 VS Code 自带的同步功能"},{"role":"assistant","content":"1、 ：\n（1）在菜单栏选择「 Code --> 首选项 --> 打开设置同步」：\n\n（2）选择需要同步的配置：\n\n（3）通过Microsoft或者GitHub账号登录。 上图中，点击“登录并打开”，然后弹出如下界面：\n\n上图中，使用 微软账号或者 GitHub账号登录：\n\n（4）同步完成后，菜单栏会显示“首先项同步已打开”，最左侧也会多出一个同步图标，如下图所示：\n\n2、 ：\n（1）点击菜单栏「Code --> 首选项 --> 设置同步已打开」，会弹出如下界面，进行相应的同步管理即可：\n\n（2）换另外一个电脑时，登录相同的账号，即可完成同步。\n参考链接："}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"方法2：使用插件 "},{"role":"assistant","content":"使用方法2，我们还可以把配置分享其他用户，也可以把其他用户的配置给自己用。\n1、 ：（将自己本地的配置云同步到 GitHub）\n（1）安装插件 。\n（2）安装完插件后，在插件里使用 GitHub 账号登录。\n（3）登录后在 vscode 的界面中，可以选择一个别人的 gist；也可以忽略掉，然后创建一个属于自己的 gist。\n（4）使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「更新/上传配置」，这样就可以把最新的配置上传到 GitHub。\n2、 ：（换另外一个电脑时，从云端同步配置到本地）\n（1）当我们换另外一台电脑时，可以先在 VS Code 中安装 插件。\n（2）安装完插件后，在插件里使用 GitHub 账号登录。\n（3）登录之后，插件的界面上，会自动出现之前的同步记录：\n\n上图中，我们点击最新的那条记录，就可将云端的最新配置同步到本地：\n\n如果你远程的配置没有成功同步到本地，那可能是网络的问题，此时，可以使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「下载配置」，多试几次。\n：\n如果我们想使用别人的配置，首先需要对方提供给你 gist。具体步骤如下：\n（1）安装插件 。\n（2）使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「下载配置」\n（3）在弹出的界面中，选择「Download Public Gist」，然后输入别人分享给你的 gist。注意，这一步不需要登录 GitHub 账号。"}],"metadata":{},"filePath":"docs/guide/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"常见配置"},{"role":"assistant","content":"：\n```\n \"files.autoSave\": \"onFocusChange\"\n```\n参考链接：\n：\n```json\n\"workbench.editor.enablePreview\": false,\n```"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"如何查看代码结构"},{"role":"assistant","content":"参考链接："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"在本地开启服务器"},{"role":"assistant","content":"```bash\n# 安装\nnpm install -g live-server\n\n# 启动\nlive-server\n```\n参考链接："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"常用插件"},{"role":"assistant","content":"方式一：打开VS Code，左侧有五个按钮，点击最下方的按钮，然后就可以开始安装相应的插件了。\n方式二：在vscode中输入快捷键「ctrl+shift+P」，弹出指令窗口，输入 ，回车，左侧即打开扩展安装的界面。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"sftp：文件传输"},{"role":"assistant","content":"输入快捷键「ctrl+shift+P」，弹出指令窗口，输入 ，回车，当前工作工程的 文件夹下就会自动生成一个 文件，我们需要在这个文件里配置的是：\n举例如下：(注意，其中的注释不能保留)\n```json\n{\n    \"host\": \"\",     //服务器ip\n    \"port\": 22,     //端口，sftp模式是22\n    \"username\": \"\", //用户名\n    \"password\": \"\", //密码\n    \"protocol\": \"sftp\", //模式\n    \"agent\": null,\n    \"privateKeyPath\": null,\n    \"passphrase\": null,\n    \"passive\": false,\n    \"interactiveAuth\": false,\n    \"remotePath\": \"/root/node/build/\",  //服务器上的文件地址\n    \"context\": \"./server/build\",        //本地的文件地址\n\n    \"uploadOnSave\": true,   //监听保存并上传\n    \"syncMode\": \"update\",\n    \"watcher\": {            //监听外部文件\n        \"files\": false,     //外部文件的绝对路径\n        \"autoUpload\": false,\n        \"autoDelete\": false\n    },\n    \"ignore\": [             //忽略项\n        \"**/.vscode/**\",\n        \"**/.git/**\",\n        \"**/.DS_Store\"\n    ]\n}\n```"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"Sass Formatter"},{"role":"assistant","content":"Sass 文件格式化。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"Code Outline：显示代码结构"},{"role":"assistant","content":"安装好插件「Code Outline」后，可以在左侧的资源管理器中，显示当前文件的代码结构：\n\n参考链接："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"vscode-fileheader：添加顶部注释模板(签名)"},{"role":"assistant","content":"（1）安装插件vscode -fileheader，并重启。\n（2）在首选项-》设置-》中搜索fileheader，找到头部模板修改。\n默认的快捷键是：「Ctrl + option + I」。\n参考链接："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"Express"},{"role":"assistant","content":"在本地开启Node服务器：\n\n然后在浏览器的地址栏输入 + 文件的相对路径，就可以通过服务器的形式打开这个文件。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"Copy Relative Path"},{"role":"assistant","content":"复制文件的相对路径：（相对于根路径而言）"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"open in browser"},{"role":"assistant","content":"在浏览器中打开。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"Auto Rename Tag"},{"role":"assistant","content":"适用于 JSX、Vue、HTML。在修改标签名时，能在你修改开始（结束）标签的时候修改对应的结束（开始）标签，帮你减少 50% 的击键。\n###Project Manager\n项目管理，让我们方便的在命令面板中切换项目文件夹，当然，你也可以直接打开包含多个项目的父级文件夹，但这样可能会让 VSCode 变慢。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"highlight-icemode：选中相同的代码时，让高亮显示更加明显【荐】"},{"role":"assistant","content":"VSCode自带的高亮显示，实在是不够显眼。用插件支持一下吧。\n所用了这个插件之后，VS Code自带的高亮就可以关掉了：\n在用户设置里添加 即可。\n参考链接："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"highlight-words：全局高亮（跨文件多色彩）"},{"role":"assistant","content":"参考链接："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"color-exchange：颜色格式转换【荐】"},{"role":"assistant","content":"安装完插件后，在css中输入颜色，然后按 ，就能进行颜色的格式转换。\n20181013_1450.png\n我在写这一段时，安装的人还不多，赶紧上车。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"vetur：vue 文件的基本语法高亮"},{"role":"assistant","content":"安装完 vetur 后还需要加上这样一段配置下：\n```\n\"emmet.syntaxProfiles\": {\n  \"vue-html\": \"html\",\n  \"vue\": \"html\"\n}\n```\n参考链接："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"问题"},{"role":"assistant","content":"问题1\n解决；You can kill the Microsoft.VSCode.Cpp.IntelliSense.Msvc process to save the file successfully. 也就是 IntelliSense 这个进程。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"编辑器相关"},{"role":"assistant","content":"前端开发的编辑器软件，我首先推荐 VS Code，其次推荐Sublime Text。\n有人说 WebStorm 也不错？但真实情况是，自从VS Code 问世之后，用 WebStorm 的人越来越少了。\nPS：文件的后缀名不能决定文件格式，只能决定打开文件打开的方式。"}],"metadata":{"title":null,"publish":true},"filePath":"docs/guide/guid/html/02-初识HTML.md"}
{"messages":[{"role":"user","content":"VS Code 的使用"},{"role":"assistant","content":"详情请移步至："}],"metadata":{"title":null,"publish":true},"filePath":"docs/guide/guid/html/02-初识HTML.md"}
{"messages":[{"role":"user","content":"Sublime Text 的使用"},{"role":"assistant","content":"详情请移步至："}],"metadata":{"title":null,"publish":true},"filePath":"docs/guide/guid/html/02-初识HTML.md"}
{"messages":[{"role":"user","content":"HTML的概念"},{"role":"assistant","content":"全称为 HyperText Markup Language，译为  。\nHTML 不是一种编程语言，是一种描述性的 。\n：HTML是负责描述文档 的语言。"}],"metadata":{"title":null,"publish":true},"filePath":"docs/guide/guid/html/02-初识HTML.md"}
{"messages":[{"role":"user","content":"概念：超文本"},{"role":"assistant","content":"所谓的超文本，有两层含义：\n（1）图片、音频、视频、动画、多媒体等内容，被称为超文本，因为它们超出了文本的限制。\n（2）不仅如此，它还可以从一个文件跳转到另一个文件，与世界各地主机的文件进行连接。即：超级链接文本。"}],"metadata":{"title":null,"publish":true},"filePath":"docs/guide/guid/html/02-初识HTML.md"}
{"messages":[{"role":"user","content":"概念：标记语言"},{"role":"assistant","content":"HTML 不是一种编程语言，是一种描述性的 。这主要有两层含义：\n（1） 。比如：标签 表示超链接、标签 表示图片、标签 表示一级标题等等，它们都是属于 HTML 标签。\n说的通俗一点就是：网页是由网页元素组成的，这些元素是由 HTML 标签描述出来，然后通过浏览器解析，就可以显示给用户看了。\n（2）编程语言是有编译过程的，而标记语言没有编译过程，HTML标签是直接由浏览器解析执行。"}],"metadata":{"title":null,"publish":true},"filePath":"docs/guide/guid/html/02-初识HTML.md"}
{"messages":[{"role":"user","content":"HTML是负责描述文档语义的语言"},{"role":"assistant","content":"HTML 格式的文件是一个纯本文文件（就是用txt文件改名而成），用一些标签来描述语义，这些标签在浏览器页面上是无法直观看到的，所以称之为“超文本标记语言”。\n接下来，我们需要学习 HTML 中的很多“标签对儿”，这些“标签对儿”能够给文本不同的语义。\n比如，面试的时候问你， 标签有什么作用？\n关乎“语义”的更深刻理解，等接下来我们学习了各种标签，就明白了。"}],"metadata":{"title":null,"publish":true},"filePath":"docs/guide/guid/html/02-初识HTML.md"}
{"messages":[{"role":"user","content":"HTML的历史"},{"role":"assistant","content":"其中，我们专门来对XHTML做一个介绍。\nXHTML：Extensible Hypertext Markup Language，可扩展超文本标注语言。\nXHTML的主要目的是为了  ，也可以理解为HTML的升级版。\nHTML的标记书写很不规范，会造成其它的设备(ipad、手机、电视等)无法正常显示。\nXHTML与HTML4.0的标记基本上一样。\nXHTML是  HTML。\n我们稍后将对XHTML的编写规范进行介绍。"}],"metadata":{"title":null,"publish":true},"filePath":"docs/guide/guid/html/02-初识HTML.md"}
{"messages":[{"role":"user","content":"书写第一个 HTML 页面"},{"role":"assistant","content":"我们打开 VS Code 软件，新建一个文件，名叫 （注意，文件名是 ，后缀名是 ），保存到本地。\n紧接着，在文件里，输入 ，然后按一下键盘上的 键，就可以自动生成如下内容：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n```\n上面的内容，就是 html 页面的骨架。我们在此基础之上，新增几个标签，完整代码如下：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <h3>我是三级标题</h3>\n    <img src=\"\" alt=\"\" />\n    <a href=\"https://www.jd.com\">我是超链接，可以点击一下</a>\n  </body>\n</html>\n```\n标签写完之后，我们用 chrome 浏览器打开上面这个 文件，看看页面效果：\n到此，第一个简单的 HTML 页面就写完了。是不是很有成就感？"}],"metadata":{"title":null,"publish":true},"filePath":"docs/guide/guid/html/02-初识HTML.md"}
{"messages":[{"role":"user","content":"HTML结构详解"},{"role":"assistant","content":"HTML标签通常是成对出现的（  ），比如 和 ；也有少部分单标签（  ），如： 、 和 等。\n属性与标记之间、各属性之间需要以空格隔开。属性值以双引号括起来。"}],"metadata":{"title":null,"publish":true},"filePath":"docs/guide/guid/html/02-初识HTML.md"}
{"messages":[{"role":"user","content":"快速生成 html 的骨架"},{"role":"assistant","content":"：在 VS Code 中新建 html 文件，输入 ，按 键后，自动生成的代码如下：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\" />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n```\n：在Sublime Text中安装 插件。新建html文件，输入 ，按 键后，自动生成的代码如下：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n```\n：在Sublime Text中安装 插件。新建html文件，输入 ，按 键后，自动生成的代码如下：\n```html\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\n  <head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\" />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n```\n上面的方式2和方式3中，我们会发现，第一行的内容有些不太一样，这就是我们接下来要讲的 。"}],"metadata":{"title":null,"publish":true},"filePath":"docs/guide/guid/html/02-初识HTML.md"}
{"messages":[{"role":"user","content":"1、文档声明头"},{"role":"assistant","content":"任何一个标准的HTML页面，第一行一定是一个以 开头的语句。这一行，就是文档声明头，即 DocType Declaration，简称DTD。\n。"}],"metadata":{"title":null,"publish":true},"filePath":"docs/guide/guid/html/02-初识HTML.md"}
{"messages":[{"role":"user","content":"HTML4.01有哪些规范呢？"},{"role":"assistant","content":"这个版本是IE6开始兼容的。 。如今，手机、移动端的网页，就可以使用HTML5了，因为其兼容性更高。\n说个题外话，html1 至 html3 是美国军方以及高等研究所用的，并未对外公开。\nHTML4.01里面有两大种规范，每大种规范里面又各有3种小规范。所以一共6种规范（见下图）。\nHTML4.01里面规定了 和 两大种规范。HTML觉得自己有一些规定不严谨，比如，标签是否可以用大写字母呢？ 所以，HTML就觉得，把一些规范严格的标准，又制定了一个XHTML1.0。在XHTML中的字母X，表示“严格的”。\n总结一下，HTML4.01一共有6种DTD。说白了，HTML的第一行语句一共有6种情况：\n\n下面对上图中的三种小规范进行解释：\n：\n表示“严格的”，这种模式里面的要求更为严格。这种严格体现在哪里？有一些标签不能使用。\n比如，u标签，就是给一个本文加下划线，但是这和HTML的本质有冲突，因为HTML最好是只负责语义，不要负责样式，而u这个下划线是样式。所以，在strict中是不能使用u标签的。\n那怎么给文本增加下划线呢？今后将使用css属性来解决。\nXHTML1.0更为严格，因为这个体系本身规定比如标签必须是小写字母、必须严格闭合标签、必须使用引号引起属性等等。\n：表示“普通的”，这种模式就是没有一些别的规范。\n：表示“框架”，在框架的页面使用。\n在sublime输入的html:xt，x表示XHTML，t表示transitional。\n在HTML5中极大的简化了DTD，也就是说HTML5中就没有XHTML了。HTML5的DTD（文档声明头）如下：\n```\n<!DOCTYPE html>\n```"}],"metadata":{"title":null,"publish":true},"filePath":"docs/guide/guid/html/02-初识HTML.md"}
{"messages":[{"role":"user","content":"2、页面语言 "},{"role":"assistant","content":"下面这行标签，用于指定页面的语言类型：\n```html\n<html lang=\"en\"></html>\n```\n最常见的语言类型有两种："}],"metadata":{"title":null,"publish":true},"filePath":"docs/guide/guid/html/02-初识HTML.md"}
{"messages":[{"role":"user","content":"html5 的比较完整的骨架："},{"role":"assistant","content":"```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\" />\n    <meta name=\"Author\" content=\"\" />\n    <meta name=\"Keywords\" content=\"厉害很厉害\" />\n    <meta\n      name=\"Description\"\n      content=\"网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。\"\n    />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n```\n面试题：\n头标签内部的常见标签如下：\n：\nmeta表示“元”。“元”配置，就是表示基本的配置项目。\n常见的几种 meta 标签如下：\n（1）字符集 charset：\n```html\n<meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\" />\n```\n字符集用meta标签中的 定义，charset就是character set（即“字符集”），即 。\n(Character set)是多个字符的集合。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。\n上面这行代码非常关键， 是必须要写的代码，否则可能导致乱码。比如你保存的时候，meta写的和声明的不匹配，那么浏览器就是乱码。\nutf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312等。关于“编码方式”，我们在下一段会详细介绍。\n（2）视口 viewport：\n```html\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n```\n：表示视口宽度等于屏幕宽度。\nviewport 这个知识点，初学者还比较难理解，以后学 Web 移动端的时候会用到。\n（3）定义“关键词”：\n举例如下：\n```html\n<meta name=\"Keywords\" content=\"网易,邮箱,游戏,新闻,体育,娱乐,女性,亚运,论坛,短信\" />\n```\n这些关键词，就是告诉搜索引擎，这个网页是干嘛的，能够提高搜索命中率。让别人能够找到你，搜索到你。\n（4）定义“页面描述”：\nmeta除了可以设置字符集，还可以设置关键字和页面描述。\n只要设置Description页面描述，那么百度搜索结果，就能够显示这些语句，这个技术叫做 （search engine optimization，搜索引擎优化）。\n设置页面描述的举例：\n```html\n<meta\n  name=\"Description\"\n  content=\"网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。\"\n/>\n```\n效果如下：\n\n上面的几种 标签都不用记，但是另外还有一个 标签是需要记住的：\n```html\n<meta http-equiv=\"refresh\" content=\"3;http://www.baidu.com\" />\n```\n上面这个标签的意思是说，3秒之后，自动跳转到百度页面。\n:\n用于设置网页标题：\n```html\n<title>网页的标题</title>\n```\ntitle标签也是有助于SEO搜索引擎优化的。\n：\n```html\n<base href=\"/\" />\n```\nbase 标签用于指定基础的路径。指定之后，所有的 a 链接都是以这个路径为基准。"}],"metadata":{"title":null,"publish":true},"filePath":"docs/guide/guid/html/02-初识HTML.md"}
{"messages":[{"role":"user","content":"4、标签"},{"role":"assistant","content":"标签的属性有：\n标签另外还有一些属性，这里用个例子来解释：\n\n上方代码中，当我们对 这几个字使用超链时， 属性表示默认显示的颜色、 属性表示鼠标点击但是还没有松开时的颜色、 属性表示点击完成之后显示的颜色。效果如下："}],"metadata":{"title":null,"publish":true},"filePath":"docs/guide/guid/html/02-初识HTML.md"}
{"messages":[{"role":"user","content":"计算机编码介绍"},{"role":"assistant","content":"计算机，不能直接存储文字，存储的是编码。\n计算机只能处理二进制的数据，其它数据，比如：0-9、a-z、A-Z，这些字符，我们可以定义一套规则来表示。假如：A用110表示，B用111表示等。\n美国发布的，用1个字节(8位二进制)来表示一个字符，共可以表示2^8=256个字符。\n美国的国家语言是英语，只要能表示0-9、a-z、A-Z、特殊符号。\n 。用2个字节(16位二进制)来表示一个汉字，共可以表示2^16＝65536个汉字。例如：\n中国的ANSI编码是GB2312编码(简体)，对6763汉字进行编码，含600多特殊字符。另外还有GBK(简体)。\n日本的ANSI编码是JIS编码。\n台湾的ANSI编码是BIG5编码（繁体）。\n对GB2312进行了扩展，用来显示罕见的、古汉语的汉字。现在已经收录了2.1万左右。并提供了1890个汉字码位。K的含义就是“扩展”。\n用4个字节(32位二进制)来表示一个字符，想法不错，但效率太低。例如，字母A用ASCII表示的话一个字节就够，可用Unicode编码的话，得用4个字节表示，造成了空间的极大浪费。A的Unicode编码是0000 0000 0000 0000 0000 0000 0100 0000\n根据字符的不同，选择其编码的长度。比如：一个字符A用1个字节表示，一个汉字用2个字节表示。\n毫无疑问，开发中，都用 编码吧，准没错。\n\n字库规模： UTF-8（字很全） > gb2312（只有汉字）\n\n我们用meta标签声明的当前这个html文档的字库，一定要和保存的文件编码类型一样，否则乱码（重点）。\n拿 sublime编辑器举例，当我们不设置的时候，sublime默认类型就是UTF-8。而一旦更改为gb2312的时候，就一定要记得设置一下sublime的保存类型： 。VS Code 的道理一样。\n\n保存大小：UTF-8（更臃肿、加载更慢） > gb2312 （更小巧，加载更快）\n总结：\n列出2个使用情形：\n1） 你们公司是做日本动漫的，经常出现一些日语动漫的名字，网页要使用UTF-8。如果用gb2312将无法显示日语。\n2） 你们公司就是中文网页，极度的追求网页的显示速度，要使用gb2312。如果使用UTF-8将每个汉字多一个byte，所以5000个汉字，多5kb。\n我们亲测：\n我们是怎么查看网页的编码方式的呢？在浏览器中打开网页，右键，选择“查看网页源代码”，找到meta标签中的charset属性即可。\n那么，我们为什么可以查看网页的源代码呢？因为这个打开的html网页已经存到我的临时文件夹里了，临时文件夹里的html是纯文本文件，纯文本文件自然可以查看网页的源代码。"}],"metadata":{"title":null,"publish":true},"filePath":"docs/guide/guid/html/02-初识HTML.md"}
{"messages":[{"role":"user","content":"1、编写XHTML的规范："},{"role":"assistant","content":"（1）所有标记元素都要正确的嵌套，不能交叉嵌套。正确写法举例：\n（2）所有的标记都必须小写。\n（3）所有的标签都必须闭合。\n（4）所有的属性值必须加引号。\n（5）所有的属性必须有值。 、\n（6）XHTML文档开头必须要有DTD文档类型定义。"}],"metadata":{"title":null,"publish":true},"filePath":"docs/guide/guid/html/02-初识HTML.md"}
{"messages":[{"role":"user","content":"（1）HTML对换行不敏感，对tab不敏感"},{"role":"assistant","content":"HTML只在乎标签的嵌套结构，嵌套的关系。谁嵌套了谁，谁被谁嵌套了，和换行、tab无关。换不换行、tab不tab，都不影响页面的结构。\n也就是说，HTML不是依靠缩进来表示嵌套的，而是看标签的嵌套关系。但是，我们发现有良好的缩进，代码更易读。建议大家都正确缩进标签。\n百度为了追求极致的显示速度，所有HTML标签都没有换行、都没有缩进（tab），HTML和换不换行无关，标签的层次依然清晰，只不过程序员不可读了。如下图所示："}],"metadata":{"title":null,"publish":true},"filePath":"docs/guide/guid/html/02-初识HTML.md"}
{"messages":[{"role":"user","content":"（2）空白折叠现象"},{"role":"assistant","content":"HTML中所有的 ，如果有空格、换行、tab都将被折叠为一个空格显示。\n举例如下："}],"metadata":{"title":null,"publish":true},"filePath":"docs/guide/guid/html/02-初识HTML.md"}
{"messages":[{"role":"user","content":"（3）标签要严格封闭"},{"role":"assistant","content":"标签不封闭的结果是灾难性的。\n标签不封闭的举例如下："}],"metadata":{"title":null,"publish":true},"filePath":"docs/guide/guid/html/02-初识HTML.md"}
{"messages":[{"role":"user","content":"html 的常见元素"},{"role":"assistant","content":"html 的常见元素主要分为两类：head 区域的元素、body 区域的元素。下面来分别介绍。"}],"metadata":{"title":"12-HTML基础回顾"},"filePath":"docs/guide/guid/html/11-HTML基础回顾.md"}
{"messages":[{"role":"user","content":"1、head 区域的 html 元素"},{"role":"assistant","content":"：\n```html\n<base href=\"/\">\n```\nbase 标签用于指定基础的路径。指定之后，所有的 a 链接都是以这个路径为基准。"}],"metadata":{"title":"12-HTML基础回顾"},"filePath":"docs/guide/guid/html/11-HTML基础回顾.md"}
{"messages":[{"role":"user","content":"2、html 元素（body 区域）"},{"role":"assistant","content":"div 是最常见的元素，大多数场景下，都可以用div（实在不行就多包几层div）。可见， 。\n："}],"metadata":{"title":"12-HTML基础回顾"},"filePath":"docs/guide/guid/html/11-HTML基础回顾.md"}
{"messages":[{"role":"user","content":"html 文档的大纲"},{"role":"assistant","content":"我们平时在写论文或者其他文档的时候，一般会先列出大纲，然后再写具体的内容。\n同样，html 网页也可以看成是一种文档，也有属于它的大纲。\n一个常见的html文档，它的结构可以是：\n```html\n    <section>\n        <h1>一级标题</h1>\n\n        <section>\n            <h2>二级标题</h2>\n            <p>段落内容</p>\n        </section>\n\n        <section>\n            <h2>二级标题</h2>\n            <p>段落内容</p>\n        </section>\n\n        <aside>\n            <p>广告内容</p>\n        </aside>\n\n    </section>\n\n    <footer>\n        <p>某某公司出品</p>\n    </footer>\n```"}],"metadata":{"title":"12-HTML基础回顾"},"filePath":"docs/guide/guid/html/11-HTML基础回顾.md"}
{"messages":[{"role":"user","content":"查看网页大纲的工具"},{"role":"assistant","content":"我们可以通过 这个工具查看一个网页的大纲。\n：\n（1）将网址 保存到书签栏\n（2）去目标网页，点击书签栏的网址，即可查看该网页的大纲。\n这个工具非常好用，既可以查看网页的大纲，也可以查看 markdown 在线文档的结构。"}],"metadata":{"title":"12-HTML基础回顾"},"filePath":"docs/guide/guid/html/11-HTML基础回顾.md"}
{"messages":[{"role":"user","content":"html 元素的分类"},{"role":"assistant","content":"按照样式分类：\n按照内容分类：\n\n图片来源："}],"metadata":{"title":"12-HTML基础回顾"},"filePath":"docs/guide/guid/html/11-HTML基础回顾.md"}
{"messages":[{"role":"user","content":"html 元素的嵌套关系"},{"role":"assistant","content":"：在 HTML5 中 是合法的， 是不合法的 ；但是在 html 4.0.1 中， 仍然是不合法的。"}],"metadata":{"title":"12-HTML基础回顾"},"filePath":"docs/guide/guid/html/11-HTML基础回顾.md"}
{"messages":[{"role":"user","content":"html 元素的默认样式和 CSS Reset"},{"role":"assistant","content":"比如下拉框这种比较复杂的元素，是自带默认样式的。如果没有这个默认样式，则该元素在页面上不会有任何表现，则必然增加一些工作量。\n同时，默认样式也会带来一些问题：比如，有些默认样式我们是不需要的；有些默认样式甚至无法去掉。\n如果我们不需要默认的样式，这里就需要引入一个概念： 。"}],"metadata":{"title":"12-HTML基础回顾"},"filePath":"docs/guide/guid/html/11-HTML基础回顾.md"}
{"messages":[{"role":"user","content":"常见的 CSS Reset 方案"},{"role":"assistant","content":"：\nCSS Tools: Reset CSS。链接：\n：\n雅虎的 CSS Reset。链接：\n我们可以直接通过 CDN 的方式引入：\n```html\n<link rel=\"stylesheet\" type=\"text/css\" href=\"http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css\">\n```\n：（比较有争议）\n```css\n*{\n    margin: 0;\n    padding: 0;\n}\n\n```\n上面何种写法，比较简洁，但也有争议。有争议的地方在于，可能会导致 css 选择器的性能问题。"}],"metadata":{"title":"12-HTML基础回顾"},"filePath":"docs/guide/guid/html/11-HTML基础回顾.md"}
{"messages":[{"role":"user","content":"Normalize.css"},{"role":"assistant","content":"上面的几种 css reset 的解决思路是：将所有的默认样式清零。\n但是， 的思路是：既然浏览器提供了这些默认样式，那它就是有意义的。 。"}],"metadata":{"title":"12-HTML基础回顾"},"filePath":"docs/guide/guid/html/11-HTML基础回顾.md"}
{"messages":[{"role":"user","content":"em 和 i 的区别"},{"role":"assistant","content":"共同点：二者都是表示斜体。\n区别："}],"metadata":{"title":"12-HTML基础回顾"},"filePath":"docs/guide/guid/html/11-HTML基础回顾.md"}
{"messages":[{"role":"user","content":"form 表单的作用"},{"role":"assistant","content":"所以，如果我们是通过 Ajax 提交表单数据，也建议加上 form。"}],"metadata":{"title":"12-HTML基础回顾"},"filePath":"docs/guide/guid/html/11-HTML基础回顾.md"}
{"messages":[{"role":"user","content":"Turbo和monorepo"},{"role":"assistant","content":"我们先来看看单一代码库monorepo和多代码仓库（multirepos）有什么区别\n多代码仓库（multirepos）:每个项目存储在一个完全独立的、版本控制的代码库中。是我目前遇到项目普遍使用的一种方式。例如每个项目的web端是一个代码仓库、H5是另一个。\nMonorepo 是指在一个 git 仓库下管理多个项目的代码。这些项目可能是相关的，但通常在逻辑上是独立的，可以由不同的团队维护。比如 ;这种项目常依托于npm或者pnpm提供的 方案；通过 方案，对项目进行多个分包\n<img src=\"https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fpackage-graph.3b11ffd3.png&w=828&q=75&dpl=dpl_Bop6cDpFyhYDskUdvBvkzjLN8JGg\" />\n我们可以通过设置工作区，在不同的项目中共享一个项目的作为依赖，同时我们管理多个项目也会变得更加容易"}],"metadata":{},"filePath":"docs/guide/project/turbo/turbo.mdx"}
{"messages":[{"role":"user","content":"turbo创建monorepo"},{"role":"assistant","content":"具有缓存机制、任务并行执行优化。他能帮我们方便的创建 仓库，且能帮我们快速构建 项目,内部提供丰富的管理打包方法。\n```bash\nnpm install turbo -g\n```\n我们使用 的模板，他创建的是一个原生的vite项目\n```bash\nnpx create-turbo@latest --example with-vite\n```\n我们使用 作为包管理工具,他便于我们使用 的目录结构\n<img src=\"/monorepo/steps1.png\" />\n我们的文件就初始好了\n<img src=\"/monorepo/setps2.png\" />\n这里是简化的目录结构\n```md\n|-- try\n    |-- .eslintrc.js\n    |-- .gitignore\n    |-- .npmrc\n    |-- package.json\n    |-- pnpm-lock.yaml\n    |-- pnpm-workspace.yaml\n    |-- README.md\n    |-- turbo.json\n    |-- .vscode\n    |   |-- settings.json\n    |-- apps\n    |   |-- docs\n    |   |   |-- package.json\n    |   |-- web\n    |       |-- package.json\n    |-- packages\n        |-- eslint-config\n        |   |-- package.json\n        |-- typescript-config\n        |   |-- package.json\n        |-- ui\n            |-- \n       \n```"}],"metadata":{},"filePath":"docs/guide/project/turbo/turbo.mdx"}
{"messages":[{"role":"user","content":"编辑pnpm-workspace.yaml工作区文件"},{"role":"assistant","content":"这个文件是我们 文件的根本，我们需要来确定我们的工作区，我们的工作区的包可以独立安装也可以互相引用，我们来看看 的内容\n```yaml\npackages:\n  - 'apps/*'\n  - 'packages/*'\n```\n这里代表我们的 和 目录下的所有文件都是工作区， 是通配符的意思，代表我们 和 目录下的所有文件都是工作区"}],"metadata":{},"filePath":"docs/guide/project/turbo/turbo.mdx"}
{"messages":[{"role":"user","content":"启动项目文件"},{"role":"assistant","content":"```bash\npnpm run dev\n```\n这个命令会执行 命令，这个命令会启动所有工作区的项目\n```json\n   \"dev\": \"turbo dev\",\n```\n但我们希望不启动全部命令可以使用 通过 参数来指定我们想要启动的工作区项目，注意这里的--filter参数后面是包名不是文件名\n这里我们启动的是工作区模板，如果我们添加新的项目该怎么做呢？"}],"metadata":{},"filePath":"docs/guide/project/turbo/turbo.mdx"}
{"messages":[{"role":"user","content":"新增项目"},{"role":"assistant","content":"这里添加我的 项目\n```bash\ncd apps\ngit clone https://github.com/Manshawar/Manshawar-blog.git\n```\n我们安装包;\n```bash\npnpm install\n```\n不过我们再学习pnpm的时候 发现了可以使用 来调用本地的包进行安装\n```bash\npnpm install --filter=[package的name]\n```\n用工作区安装包，pnpm会直接调用本地缓存安包的速度非常的快\n```bash\nturbo dev --filter blog\n```\n我们可以使用turbo启动项目，由于 的缓存机制 打开项目的速度会肉眼可见的变快"}],"metadata":{},"filePath":"docs/guide/project/turbo/turbo.mdx"}
{"messages":[{"role":"user","content":"添加本地包进行依赖"},{"role":"assistant","content":"我们要注意到 文件，在 版本后，由于默认的 被改为了 ，他会优先从 中拉取包，我们无法安装工作区的本地包，我们需要在 文件中新增下面这一行文本,它会优先从本地拉去包\n这里时issue地址\n```yaml\nlink-workspace-packages = true\n```\n\n我们再使用 命令安装本地依赖\n```bash\npnpm instal @repo/eslint-config --filter blog\n```\n接下来你会在工作区中看到 工作区依赖包\n<img src=\"/monorepo/package1.png\" />\n我们可以编辑 来控制其版本，这里我们设置为\n```yaml\nsave-prefix = ''\n```\n这里是相关链接\n现在你可以开始你的monorepo项目了，打包详细参考turbo官网"}],"metadata":{},"filePath":"docs/guide/project/turbo/turbo.mdx"}
{"messages":[{"role":"user","content":"常见配置"},{"role":"assistant","content":"：\n```\n \"files.autoSave\": \"onFocusChange\"\n```\n参考链接：\n：\n```json\n\"workbench.editor.enablePreview\": false,\n```"}],"metadata":{},"filePath":"docs/guide/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"如何查看代码结构"},{"role":"assistant","content":"参考链接："}],"metadata":{},"filePath":"docs/guide/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"在本地开启服务器"},{"role":"assistant","content":"```bash\n# 安装\nnpm install -g live-server\n\n# 启动\nlive-server\n```\n参考链接："}],"metadata":{},"filePath":"docs/guide/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"常用插件"},{"role":"assistant","content":"方式一：打开VS Code，左侧有五个按钮，点击最下方的按钮，然后就可以开始安装相应的插件了。\n方式二：在vscode中输入快捷键「ctrl+shift+P」，弹出指令窗口，输入 ，回车，左侧即打开扩展安装的界面。"}],"metadata":{},"filePath":"docs/guide/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"sftp：文件传输"},{"role":"assistant","content":"输入快捷键「ctrl+shift+P」，弹出指令窗口，输入 ，回车，当前工作工程的 文件夹下就会自动生成一个 文件，我们需要在这个文件里配置的是：\n举例如下：(注意，其中的注释不能保留)\n```json\n{\n    \"host\": \"\",     //服务器ip\n    \"port\": 22,     //端口，sftp模式是22\n    \"username\": \"\", //用户名\n    \"password\": \"\", //密码\n    \"protocol\": \"sftp\", //模式\n    \"agent\": null,\n    \"privateKeyPath\": null,\n    \"passphrase\": null,\n    \"passive\": false,\n    \"interactiveAuth\": false,\n    \"remotePath\": \"/root/node/build/\",  //服务器上的文件地址\n    \"context\": \"./server/build\",        //本地的文件地址\n\n    \"uploadOnSave\": true,   //监听保存并上传\n    \"syncMode\": \"update\",\n    \"watcher\": {            //监听外部文件\n        \"files\": false,     //外部文件的绝对路径\n        \"autoUpload\": false,\n        \"autoDelete\": false\n    },\n    \"ignore\": [             //忽略项\n        \"**/.vscode/**\",\n        \"**/.git/**\",\n        \"**/.DS_Store\"\n    ]\n}\n```"}],"metadata":{},"filePath":"docs/guide/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"Sass Formatter"},{"role":"assistant","content":"Sass 文件格式化。"}],"metadata":{},"filePath":"docs/guide/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"Code Outline：显示代码结构"},{"role":"assistant","content":"安装好插件「Code Outline」后，可以在左侧的资源管理器中，显示当前文件的代码结构：\n\n参考链接："}],"metadata":{},"filePath":"docs/guide/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"vscode-fileheader：添加顶部注释模板(签名)"},{"role":"assistant","content":"（1）安装插件vscode -fileheader，并重启。\n（2）在首选项-》设置-》中搜索fileheader，找到头部模板修改。\n默认的快捷键是：「Ctrl + option + I」。\n参考链接："}],"metadata":{},"filePath":"docs/guide/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"Express"},{"role":"assistant","content":"在本地开启Node服务器：\n\n然后在浏览器的地址栏输入 + 文件的相对路径，就可以通过服务器的形式打开这个文件。"}],"metadata":{},"filePath":"docs/guide/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"Copy Relative Path"},{"role":"assistant","content":"复制文件的相对路径：（相对于根路径而言）"}],"metadata":{},"filePath":"docs/guide/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"open in browser"},{"role":"assistant","content":"在浏览器中打开。"}],"metadata":{},"filePath":"docs/guide/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"Auto Rename Tag"},{"role":"assistant","content":"适用于 JSX、Vue、HTML。在修改标签名时，能在你修改开始（结束）标签的时候修改对应的结束（开始）标签，帮你减少 50% 的击键。\n###Project Manager\n项目管理，让我们方便的在命令面板中切换项目文件夹，当然，你也可以直接打开包含多个项目的父级文件夹，但这样可能会让 VSCode 变慢。"}],"metadata":{},"filePath":"docs/guide/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"highlight-icemode：选中相同的代码时，让高亮显示更加明显【荐】"},{"role":"assistant","content":"VSCode自带的高亮显示，实在是不够显眼。用插件支持一下吧。\n所用了这个插件之后，VS Code自带的高亮就可以关掉了：\n在用户设置里添加 即可。\n参考链接："}],"metadata":{},"filePath":"docs/guide/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"highlight-words：全局高亮（跨文件多色彩）"},{"role":"assistant","content":"参考链接："}],"metadata":{},"filePath":"docs/guide/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"color-exchange：颜色格式转换【荐】"},{"role":"assistant","content":"安装完插件后，在css中输入颜色，然后按 ，就能进行颜色的格式转换。\n20181013_1450.png\n我在写这一段时，安装的人还不多，赶紧上车。"}],"metadata":{},"filePath":"docs/guide/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"vetur：vue 文件的基本语法高亮"},{"role":"assistant","content":"安装完 vetur 后还需要加上这样一段配置下：\n```\n\"emmet.syntaxProfiles\": {\n  \"vue-html\": \"html\",\n  \"vue\": \"html\"\n}\n```\n参考链接："}],"metadata":{},"filePath":"docs/guide/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"问题"},{"role":"assistant","content":"问题1\n解决；You can kill the Microsoft.VSCode.Cpp.IntelliSense.Msvc process to save the file successfully. 也就是 IntelliSense 这个进程。"}],"metadata":{},"filePath":"docs/guide/guid/tool/vscode配置.md"}
{"messages":[{"role":"user","content":"2、 ai提升需求"},{"role":"assistant","content":"```ts\n   messages: [\n        {\n          role: 'system',\n          content: '你是一个代码文档助手，回答必须基于提供的代码库内容'\n        },\n        {\n          role: 'user',\n          content: `根据${path.basename(filePath)}的${block.name}部分，${generateQuestion(block)}`\n        },\n        {\n          role: 'assistant',\n          content: generateAnswer(block, filePath)\n        }]\nfunction generateQuestion(block: CodeBlock): string {\n  switch(block.type) {\n    case 'function':\n      return `请解释${block.name}函数的作用和参数`;\n    case 'component':\n      return `如何使用${block.name}组件？`;\n    case 'markdown':\n      return `总结${block.name}章节的主要内容`;\n  }\n}\nfunction generateAnswer(block: CodeBlock, filePath: string): string {\n  const sourceRef = `（来源：${path.basename(filePath)}#${block.name}）`;\n  \n  if (block.type === 'markdown') {\n    return `文档内容：${block.content.slice(0, 200)}... ${sourceRef}`;\n  }\n  \n  return `代码片段：\n\\`\\`\\`${block.type === 'function' ? 'typescript' : 'jsx'}\n${block.content}\n\\`\\`\\`\n${block.comments.join('\\n')} ${sourceRef}`;\n}\n```"}],"metadata":{},"filePath":"docs/guide/AIGC/JSON训练集的Plugin工具.mdx"}
{"messages":[{"role":"user","content":"diff"},{"role":"assistant","content":"import Diff from \"@/page/baseScript/diff\";\n我们先看看简化版本，它并没有处理递归和更新\n<img src=\"https://ik.imagekit.io/Manshawar/ferris_Ry3QHhKSw\" />\n<Diff  />\n```ts\n\n  // 定义虚拟节点接口\n  interface VNode {\n    type: string;\n    props: Record<string, any>;\n    children: VNode[];\n    key?: string | number;\n  }\n\n  // 定义补丁操作的几种类型\n  type Patch =\n    | { type: \"REPLACE\"; newNode: VNode }\n    | { type: \"UPDATE_PROPS\"; props: Record<string, any> }\n    | { type: \"REORDER\"; moves: (MoveAction | null)[] }\n    | { type: \"TEXT\"; content: string };\n\n  type MoveAction =\n    | { type: \"INSERT\"; node: VNode; index: number }\n    | { type: \"REMOVE\"; index: number };\n\n  // 核心diff算法\n  function diff(oldNode: VNode, newNode: VNode): Patch[] {\n    const patches: Patch[] = [];\n\n    // 1. 类型不同直接替换\n    if (oldNode.type !== newNode.type) {\n      patches.push({ type: \"REPLACE\", newNode });\n      return patches;\n    }\n\n    // 2. 比较属性差异\n    const propPatches = diffProps(oldNode.props, newNode.props);\n    if (propPatches) {\n      patches.push({ type: \"UPDATE_PROPS\", props: propPatches });\n    }\n\n    // 3. 比较子节点差异\n    const childPatches = diffChildren(oldNode.children, newNode.children);\n    console.log(\"childPatches\", childPatches);\n    if (childPatches.length > 0) {\n      patches.push({ type: \"REORDER\", moves: childPatches });\n    }\n\n    return patches;\n  }\n\n  // 比较属性差异\n  function diffProps(\n    oldProps: Record<string, any>,\n    newProps: Record<string, any>\n  ): Record<string, any> | null {\n    const patches: Record<string, any> = {};\n    let hasChanges = false;\n\n    // 找出变化的属性\n    for (const key in newProps) {\n      if (newProps[key] !== oldProps[key]) {\n        patches[key] = newProps[key];\n        hasChanges = true;\n      }\n    }\n\n    // 找出被删除的属性\n    for (const key in oldProps) {\n      if (!(key in newProps)) {\n        patches[key] = undefined;\n        hasChanges = true;\n      }\n    }\n\n    return hasChanges ? patches : null;\n  }\n\n  // 比较子节点差异（简化版）\n  function diffChildren(oldChildren: VNode[], newChildren: VNode[]): (MoveAction | null)[] {\n    const moves: (MoveAction | null)[] = [];\n    const oldMap: Record<string | number, VNode> = {};\n    const newMap: Record<string | number, VNode> = {};\n\n    // 创建key映射表\n    oldChildren.forEach((child, index) => {\n      const key = child.props.key ?? index;\n      oldMap[key] = child;\n    });\n\n    newChildren.forEach((child, index) => {\n      const key = child.props.key ?? index;\n      newMap[key] = child;\n    });\n\n    // 找出需要删除的节点\n    oldChildren.forEach((child, index) => {\n      const key = child.props.key ?? index;\n      if (!newMap[key]) {\n        moves.push({ type: \"REMOVE\", index });\n      }\n    });\n\n    // 找出需要新增/移动的节点\n    newChildren.forEach((child, newIndex) => {\n      const key = child.props.key ?? newIndex;\n      const oldIndex = oldChildren.find(c => (c.props.key ?? c) === key);\n\n      if (!oldIndex) {\n        moves.push({ type: \"INSERT\", node: child, index: newIndex });\n      } else if (oldIndex.props.key !== key) {\n        // 这里简化处理，实际需要更复杂的移动逻辑\n        moves.push({ type: \"INSERT\", node: child, index: newIndex });\n      }\n       // else if(oldIndex.props.key !== key&&oldIndex!==newIndex) 这里简化处理，实际需要更复杂的移动逻辑\n    });\n\n    return moves;\n  }\n\n  // 使用示例\n  const oldVNode: VNode = {\n    type: \"div\",\n    props: { className: \"container\" },\n    children: [\n      { type: \"p\", props: { key: 1 }, children: [] },\n      { type: \"span\", props: { key: 2 }, children: [] },\n    ],\n  };\n\n  const newVNode: VNode = {\n    type: \"div\",\n    props: { className: \"wrapper\" },\n    children: [\n      { type: \"span\", props: { key: 2 }, children: [] },\n      { type: \"input\", props: { key: 3 }, children: [] },\n    ],\n  };\n\n  const patches = diff(oldVNode, newVNode);\n  console.log(patches);\n\n```\n这里是完整的diff算法\n```ts\ninterface VNode {\n  type: string | Function; // 支持组件\n  props: Record<string, any>;\n  children: VNode[];\n  key?: string | number;\n  el?: HTMLElement; // 关联的真实DOM\n}\n\ntype Patch = \n  | { type: 'REPLACE'; newNode: VNode }\n  | { type: 'UPDATE_PROPS'; patches: PropPatch[] }\n  | { type: 'REORDER'; moves: MoveAction[] }\n  | { type: 'TEXT'; content: string };\n\ntype PropPatch = \n  | { op: 'set'; key: string; value: any }\n  | { op: 'remove'; key: string };\n\ntype MoveAction = \n  | { type: 'INSERT'; node: VNode; afterKey?: string | number }\n  | { type: 'MOVE'; fromKey: string | number; toKey: string | number }\n  | { type: 'REMOVE'; key: string | number };\n\n// 优化后的diff算法\nfunction diff(oldNode: VNode, newNode: VNode): Patch[] {\n  const patches: Patch[] = [];\n\n  // 1. 节点类型不同直接替换\n  if (oldNode.type !== newNode.type) {\n    return [{ type: 'REPLACE', newNode }];\n  }\n\n  // 2. 比较属性差异（优化后的实现）\n  const propPatches = diffProps(oldNode.props, newNode.props);\n  if (propPatches.length > 0) {\n    patches.push({ type: 'UPDATE_PROPS', patches: propPatches });\n  }\n\n  // 3. 处理文本节点（新增优化）\n  if (typeof oldNode.children[0]?.type === 'string' && \n      typeof newNode.children[0]?.type === 'string') {\n    if (oldNode.children[0] !== newNode.children[0]) {\n      patches.push({ \n        type: 'TEXT', \n        content: newNode.children[0].props.nodeValue \n      });\n    }\n    return patches;\n  }\n\n  // 4. 优化后的子节点diff\n  const childPatches = diffChildren(oldNode.children, newNode.children);\n  if (childPatches.length > 0) {\n    patches.push({ type: 'REORDER', moves: childPatches });\n  }\n\n  return patches;\n}\n\n// 优化后的属性比较（支持事件处理）\nfunction diffProps(oldProps: Record<string, any>, newProps: Record<string, any>): PropPatch[] {\n  const patches: PropPatch[] = [];\n  const allKeys = new Set([...Object.keys(oldProps), ...Object.keys(newProps)]);\n\n  allKeys.forEach(key => {\n    // 跳过children属性\n    if (key === 'children') return;\n\n    const oldVal = oldProps[key];\n    const newVal = newProps[key];\n\n    // 事件处理优化（以on开头的属性）\n    if (key.startsWith('on')) {\n      if (oldVal !== newVal) {\n        patches.push({ op: 'remove', key });\n        patches.push({ op: 'set', key, value: newVal });\n      }\n      return;\n    }\n\n    if (!newProps.hasOwnProperty(key)) {\n      patches.push({ op: 'remove', key });\n    } else if (oldVal !== newVal) {\n      patches.push({ op: 'set', key, value: newVal });\n    }\n  });\n\n  return patches;\n}\n\n// 优化后的子节点diff（双指针算法）\nfunction diffChildren(oldChildren: VNode[], newChildren: VNode[]): MoveAction[] {\n  const moves: MoveAction[] = [];\n  const keyIndexMap: Map<string | number, number> = new Map();\n  const newKeyMap: Map<string | number, VNode> = new Map();\n\n  // 构建旧节点的key索引\n  oldChildren.forEach((child, index) => {\n    const key = child.key ?? index;\n    keyIndexMap.set(key, index);\n  });\n\n  // 构建新节点key映射\n  newChildren.forEach(child => {\n    const key = child.key ?? Symbol();\n    newKeyMap.set(key, child);\n  });\n\n  let lastIndex = 0;\n  const newChildrenWithKey = newChildren.map((child, index) => ({\n    key: child.key ?? index,\n    node: child,\n    index\n  }));\n\n  // 第一轮遍历：处理已有节点的移动\n  newChildrenWithKey.forEach(({ key, node, index: newIndex }) => {\n    const oldIndex = keyIndexMap.get(key);\n    \n    if (oldIndex === undefined) {\n      // 新增节点\n      moves.push({ \n        type: 'INSERT', \n        node,\n        afterKey: newChildrenWithKey[newIndex - 1]?.key \n      });\n    } else {\n      // 需要移动的节点\n      if (oldIndex < lastIndex) {\n        moves.push({\n          type: 'MOVE',\n          fromKey: key,\n          toKey: newChildrenWithKey[newIndex - 1]?.key\n        });\n      }\n      lastIndex = Math.max(oldIndex, lastIndex);\n    }\n  });\n\n  // 第二轮遍历：处理需要删除的节点\n  oldChildren.forEach(oldChild => {\n    const key = oldChild.key ?? Symbol();\n    if (!newKeyMap.has(key)) {\n      moves.push({ type: 'REMOVE', key });\n    }\n  });\n\n  return moves;\n}\n\n// 新增：应用补丁到真实DOM\nfunction applyPatch(el: HTMLElement, patches: Patch[]) {\n  patches.forEach(patch => {\n    switch (patch.type) {\n      case 'REPLACE':\n        const newEl = createElement(patch.newNode);\n        el.parentNode?.replaceChild(newEl, el);\n        break;\n        \n      case 'UPDATE_PROPS':\n        patch.patches.forEach(propPatch => {\n          if (propPatch.op === 'set') {\n            if (propPatch.key.startsWith('on')) {\n              // 事件处理\n              const eventType = propPatch.key.slice(2).toLowerCase();\n              el.addEventListener(eventType, propPatch.value);\n            } else {\n              el.setAttribute(propPatch.key, propPatch.value);\n            }\n          } else {\n            el.removeAttribute(propPatch.key);\n          }\n        });\n        break;\n        \n      case 'REORDER':\n        const fragment = document.createDocumentFragment();\n        patch.moves.forEach(move => {\n          // 实际DOM操作需要根据key查找对应节点\n          // 这里简化处理，实际需要维护key与DOM的映射\n        });\n        el.appendChild(fragment);\n        break;\n        \n      case 'TEXT':\n        el.textContent = patch.content;\n        break;\n    }\n  });\n}\n\n// 虚拟DOM创建函数（示例）\nfunction createElement(vnode: VNode): HTMLElement {\n  // 实际实现需要处理组件等情况\n  const el = document.createElement(vnode.type as string);\n  // 应用props和children...\n  return el;\n}\n\n```"}],"metadata":{},"filePath":"docs/guide/js/diff.mdx"}
{"messages":[{"role":"user","content":"从 koa 到 mini-vite（二）插件容器"},{"role":"assistant","content":"这个是仓库地址"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(二).mdx"}
{"messages":[{"role":"user","content":"1、什么是插件容器"},{"role":"assistant","content":"vite 的插件容器是使用的管线设计模式，其设计参考了 rollup 的插件机制"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(二).mdx"}
{"messages":[{"role":"user","content":"2、插件容器的流程以及和vite的关系"},{"role":"assistant","content":"插件顺序\n一个 Vite 插件可以额外指定一个 enforce 属性（类似于 webpack 加载器）来调整它的应用顺序。enforce 的值可以是 pre 或 post。解析后的插件将按照以下顺序排列：\n相当数量的 Rollup 插件将直接作为 Vite 插件工作（例如：@rollup/plugin-alias 或 @rollup/plugin-json），但并不是所有的，因为有些插件钩子在非构建式的开发服务器上下文中没有意义。\n一般来说，只要 Rollup 插件符合以下标准，它就应该像 Vite 插件一样工作：\n没有使用 moduleParsed 钩子。\n它在打包钩子和输出钩子之间没有很强的耦合。\n如果一个 Rollup 插件只在构建阶段有意义，则在 build.rollupOptions.plugins 下指定即可。它的工作原理与 Vite 插件的 enforce: 'post' 和 apply: 'build' 相同。\n你也可以用 Vite 独有的属性来扩展现有的 Rollup 插件:\n```js\nimport example from \"rollup-plugin-example\";\nimport { defineConfig } from \"vite\";\n\nexport default defineConfig({\n  plugins: [\n    {\n      ...example(),\n      enforce: \"post\",\n      apply: \"build\",\n    },\n  ],\n});\n```\n从官网上获取的信息来看，我们的插件容器是和rollup高度一致的，我们先建立ts类型文件\n```ts\n// src/node/pluginContainer.ts\nimport type {\n  LoadResult,\n  PartialResolvedId,\n  SourceDescription,\n  PluginContext as RollupPluginContext,\n  ResolvedId,\n} from \"rollup\";\n\nexport interface PluginContainer {\n  resolveId(id: string, importer?: string): Promise<PartialResolvedId | null>;\n  load(id: string): Promise<LoadResult | null>;\n  transform(code: string, id: string): Promise<SourceDescription | null>;\n}\n\n```\n插件容器基本为rollup插件的封装，所以我们的类型也应该保持一致；\n来看看最核心的插件容器代码\n```ts\nexport const createPluginContainer = (plugins: Plugin[]): PluginContainer => {\n  // 插件上下文对象\n  // @ts-ignore 这里仅实现上下文对象的 resolve 方法\n  class Context implements RollupPluginContext {\n    async resolve(id: string, importer?: string) {\n      let out = await pluginContainer.resolveId(id, importer);\n      if (typeof out === \"string\") out = { id: out };\n      return out as ResolvedId | null;\n    }\n  }\n  // 插件容器\n  const pluginContainer: PluginContainer = {\n    async resolveId(id: string, importer?: string) {\n      const ctx = new Context() as any;\n      for (const plugin of plugins) {\n        if (plugin.resolveId) {\n          const newId = await plugin.resolveId.call(ctx as any, id, importer);\n          if (newId) {\n            id = typeof newId === \"string\" ? newId : newId.id;\n            return { id };\n          }\n        }\n      }\n      return null;\n    },\n    async load(id) {\n      const ctx = new Context() as any;\n      for (const plugin of plugins) {\n        if (plugin.load) {\n          const result = await plugin.load.call(ctx, id);\n          if (result) {\n            return result;\n          }\n        }\n      }\n      return null;\n    },\n    async transform(code, id) {\n      const ctx = new Context() as any;\n      for (const plugin of plugins) {\n        if (plugin.transform) {\n          const result = await plugin.transform.call(ctx, code, id);\n          if (!result) continue;\n          if (typeof result === \"string\") {\n            code = result;\n          } else if (result.code) {\n            code = result.code;\n          }\n        }\n      }\n      return { code };\n    },\n  };\n\n  return pluginContainer;\n};\n\n```\n这个后续会添加到我们的koa中间件中，先来看看他的每个函数方法代表什么"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(二).mdx"}
{"messages":[{"role":"user","content":"3、插件容器的方法解析"},{"role":"assistant","content":"我们来看我们 第一个方法 他做了什么事情呢，他会解析我们的路径，事实上，他的工作是帮我们筛选路径\n```js\n async resolveId(id, importer) {\n      const ctx = new Context();\n      for (const plugin of plugins) {\n        if (plugin.resolveId) {\n          const newId = await plugin.resolveId.call(ctx, id, importer);\n          if (newId) {\n            id = typeof newId === 'string' ? newId : newId.id;\n            return newId;\n          }\n        }\n      }\n      return null\n    },\n\n```\n此方法会接受两个参数，一个是id，一个是importer，id是当前路径，importer的其入口文件\n```js\n//a.tsx\nimport b from './b'\n```\n我们在读取 的时候 ，id是b，importer是a.tsx;这个方法在后期的引入路径解析和模块依赖开发中十分有效；\n```ts\n  class Context implements RollupPluginContext {\n    async resolve(id: string, importer?: string) {\n      let out = await pluginContainer.resolveId(id, importer);\n      if (typeof out === \"string\") out = { id: out };\n      return out as ResolvedId | null;\n    }\n  }\n```\n我们会看到我们在方法执行的第一步， 这个方法会帮助我们创建一个上下文对象，他将我们的resolve插件方法，挂载到了 上，这个方法继承于 ,我们后续可以使用 ，在每一个插件中去调用路径处理方法；\n```ts\nfor (const plugin of plugins) {\n        if (plugin.resolveId) {\n          const newId = await plugin.resolveId.call(ctx, id, importer);\n          if (newId) {\n            id = typeof newId === 'string' ? newId : newId.id;\n            return newId;\n          }\n        }\n      }\n```\n这里会遍历我们后续书写的插件，调用每一个插件上的 方法，调用该方法时，其 会指向我们创建的 ；如果我们能得到新的id返回值，如果存在。则会将其返回，不存在则返回null；\n\n```ts\n    async load(id) {\n      const ctx = new Context();\n      for (const plugin of plugins) {\n        if (plugin.load) {\n          const res = await plugin.load.call(ctx, id);\n          if (res) {\n            return res\n          }\n        }\n      }\n      return null\n    },\n\n```\n我们 方法，实际上和上文的 方法时一致的， 。我们的路径和对应的代码片段，应该时在找到时就返回了，而不是循环遍历完所有的插件；\n\n```ts\n async transform(code, id) {\n      const ctx = new Context();\n      for (const plugin of plugins) {\n        if (plugin.transform) {\n          code = code.trim()\n          const res = await plugin.transform.call(ctx, code, id);\n          if (!res) {\n            continue\n          }\n          if (typeof res === 'string') {\n            code = res\n          } else {\n            code = res.code\n          }\n        }\n      }\n      return { code }\n    }\n```\ntransform方法他会接受 的返回值 ，和其处理的 ；这里的处理和上文 和 不一致，他会在获取到值后持续循环，并不会退出，code每一次在循环中重新赋值，最后会返回所有transform处理后的code；\n下面开始会在处理流程上进行解析"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(二).mdx"}
{"messages":[{"role":"user","content":"4、上下文环境"},{"role":"assistant","content":"```ts\nimport { indexHtmlMiddware } from \"./node/middlewares/indexHtml\";\nimport { transformMiddleware } from \"./node/middlewares/transformMiddleware\";\nconst root = process.cwd();\n\nexport interface ServerContext {\n  root: string;\n  PluginContainer: PluginContainer,\n  app: Koa;\n  plugins: Plugin[]\n\n}\nconst plugins = resolvePlugins();\nconst PluginContainer = createPluginContainer(plugins)\nconst serverContext: ServerContext = {\n  root: process.cwd(),\n  PluginContainer,\n  app,\n  plugins: plugins\n}\nfor (const plugin of plugins) {\n  if (plugin.configureServer) {\n    await plugin.configureServer(serverContext)\n  }\n}\napp.use(indexHtmlMiddware(serverContext));\napp.use(transformMiddleware(serverContext));\n```\n这个方法返回的是一个插件数组，如 ;我们的服务端上下文环境是一个对象，他包含根目录对象，插件容器，koa实例，以及插件数组，我们会将上下文环境分发给每一个中间件\n```ts\nfor (const plugin of plugins) {\n  if (plugin.configureServer) {\n    await plugin.configureServer(serverContext)\n  }\n}\n```\n此处是将插件中，每一个 钩子中，能获取到服务器环境的上下文环境，我们后续会用到；"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(二).mdx"}
{"messages":[{"role":"user","content":"5、html文件的读取"},{"role":"assistant","content":"```ts\nimport path from \"path\";\nimport fs from \"fs-extra\";\nimport { ServerContext } from \"../../index\";\nimport { Middleware } from \"koa\";\nexport function indexHtmlMiddware(serverContext: ServerContext): Middleware {\n  return async (ctx, next) => {\n    const { res, req } = ctx;\n  \n    if (req.url === \"/\") {\n      const { root } = serverContext;\n      const indexHtmlPath = path.resolve(root, \"index.html\");\n      if (await fs.pathExists(indexHtmlPath)) {\n        const readHtml = await fs.readFile(indexHtmlPath, \"utf-8\");\n        let html = readHtml;\n      \n        for (const plugin of serverContext.plugins) {\n          if (plugin.transformIndexHtml) {\n            html = await plugin.transformIndexHtml(html)\n          }\n        }\n\n        res.statusCode = 200;\n        res.setHeader(\"Content-Type\", \"text/html\");\n\n        ctx.body = html\n      }\n    }\n    return next();\n\n  }\n\n}\n```\n当我们的路径为 时，开始读取我们的 文件，如果存在，则读取文件内容，然后遍历我们的插件，如果存在 方法，则调用该方法，将返回值赋值给html，最后将html返回给客户端；\n```ts\n       let html = readHtml;\n       for (const plugin of serverContext.plugins) {\n          if (plugin.transformIndexHtml) {\n            html = await plugin.transformIndexHtml(html)\n          }\n        }\n\n```\n此处的for循环会反复的遍历 钩子，并对我们的 进行处理，每一次在插件循环中，只要我们的插件有对 处理的钩子，处理后就会对 重新赋值,最终将处理后的 返回给客户端；"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(二).mdx"}
{"messages":[{"role":"user","content":"6、插件中间件"},{"role":"assistant","content":"```ts\nimport { SourceDescription } from \"rollup\"\nimport { Middleware } from \"koa\";\nimport { ServerContext } from \"../../index\";\nimport createDebug from \"debug\";\nimport { isJSRequest, cleanUrl } from \"../utils\"\nconst debug = createDebug(\"dev\");\n\n//transformRequest .......\n\n//transformRequest\nexport function transformMiddleware(serverContext: ServerContext): Middleware {\n  return async (ctx, next) => {\n    const { req, res } = ctx\n    if (req.method !== \"GET\" || !req.url) {\n      return next()\n    }\n    const url = req.url;\n    debug(\"transformMiddleware: %s\", url);\n    if (isJSRequest(url)) {\n      let resCode = await transformRequest(url, serverContext);\n\n      if (!resCode) {\n        return next();\n      }\n\n      if (resCode && typeof resCode !== \"string\") {\n        resCode = resCode.code;\n      }\n      res.statusCode = 200;\n      res.setHeader(\"Content-Type\", \"application/javascript\");\n      return res.end(resCode);\n    }\n  }\n\n}\n```\n我们的 方法，他会在请求会js请求的时候进行处理，可以打开谷歌控制台，我们在network中可以找到 区块，这个请求主要是处理script标签的src和其中的import引入；都是我们的js请求，这里的会有一个正则进行校验 ;\n我们的插件容器，最后会返回一个js片段出来，这个片段则是我们给客户端的代码片段\n我们来看看 ; 是怎么对插件进行处理的\n```ts\nasync function transformRequest(url: string, serverContext: ServerContext): Promise<SourceDescription | null | string | undefined> {\n  const { PluginContainer } = serverContext;\n  url = cleanUrl(url);\n  let res;\n  let resolveId = await PluginContainer.resolveId(url);\n  if (resolveId?.id) {\n    let code = await PluginContainer.load(resolveId?.id);\n    if (typeof code === \"object\" && code !== null) {\n      code = code.code\n    }\n    if (code) {\n      res = await PluginContainer.transform(code, resolveId?.id);\n    }\n  }\n\n  return res\n}\n\n```\n我们可以看到具体的处理流程"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(二).mdx"}
{"messages":[{"role":"user","content":"7、插件"},{"role":"assistant","content":"```js\n// plugins/index.ts\nimport { Plugin } from \"./plugin\";\nimport { allin } from \"./allin\";\nimport { resolvePath } from \"./resolve\";\nimport { esbuildTransformPlugin } from \"./esbuild\";\nimport { importAnalysisPlugin } from \"./importAnalysis\"\nexport const resolvePlugins = (): Plugin[] => {\n  return [\n    // allin(),\n    resolvePath(),\n    esbuildTransformPlugin(),\n    importAnalysisPlugin()\n  ]\n}\n```\n这三个插件是vite的基石插件，我这边写了一个allin的插件，一个插件总和了其他插件的功能，可以在代码库中阅读该代码进一步理解"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(二).mdx"}
{"messages":[{"role":"user","content":"7-1、resolvePath插件"},{"role":"assistant","content":"```ts\nimport { ServerContext } from './../../index';\nimport resolve from \"resolve\";\nimport { Plugin } from \"./plugin\";\n\nimport path from \"path\";\nimport fs, { pathExists } from \"fs-extra\";\nimport { DEFAULT_EXTERSIONS } from \"../contants\";\nimport { cleanUrl, normalizePath } from \"../utils\";\nexport function resolvePath(): Plugin {\n  let serverContext: ServerContext\n  return {\n    name: \"resolvePlugin\",\n    configureServer(s) {\n      serverContext = s\n    },\n    async resolveId(id, importer) {\n      if (path.isAbsolute(id)) {\n        if (await pathExists(id)) {\n          return {\n            id\n          }\n        }\n        id = path.join(serverContext.root, id);\n        if (await pathExists(id)) {\n          return {\n            id\n          }\n        }\n      } else if (id.startsWith(\".\")) {\n        if (!importer) {\n          throw new Error(\"`importer` should not be undefined\");\n        }\n        const hasExtension = path.extname(id).length > 1;\n        let resolvedId: string;\n      \n        if (hasExtension) {\n          //请于test中查看resolve.test.ts测试\n        \n          resolvedId = normalizePath(resolve.sync(id, { basedir: path.dirname(importer) }));\n          if (await pathExists(resolvedId)) {\n            return {\n              id: resolvedId,\n            }\n          }\n        } else {\n          \n          for (const extname of DEFAULT_EXTERSIONS) {\n            try {\n              const withExtension = `${id}${extname}`;\n           \n              resolvedId = normalizePath(resolve.sync(withExtension, {\n                basedir: path.dirname(importer),\n              }));\n            \n              if (await pathExists(resolvedId)) {\n            \n                return {\n                  id: resolvedId\n                }\n              }\n            } catch (error) {\n              continue\n            }\n          }\n        }\n      }\n      return null\n    },\n\n\n  }\n}\n\n```\n这个插件主要是对路径进行处理\n这里是一个测试代码，用于测试resolve方法\n以下是测试代码\n```ts\nimport resolve from \"resolve\";\nimport path from \"path\";\n\ntest('resolveImporter', () => {\n  let id = \"./App.tsx\";\n  let importer = \"src/client/main.tsx\"\n  let res = resolve.sync(id, { basedir: path.dirname(importer) });\n  expect(res).toBe(`D:\\code\\study\\vite\\minivite\\koaVite\\src\\client\\App.tsx`);\n});\n```"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(二).mdx"}
{"messages":[{"role":"user","content":"7-2、esbuildTransformPlugin插件"},{"role":"assistant","content":"这个插件主要是用于帮助我们获取对应的 片段；\n```ts\nimport { Plugin } from \"./plugin\";\nimport { isJSRequest } from \"../utils\";\nimport path from \"path\";\nimport fs from \"fs-extra\";\nimport esbuild from \"esbuild\";\nexport function esbuildTransformPlugin(): Plugin {\n  return {\n    name: \"esbuild-transform\",\n    async load(id) {\n      if (isJSRequest(id)) {\n        try {\n          let code = await fs.readFile(id, \"utf-8\");\n          return code\n        } catch (error) {\n          return null\n        }\n      }\n    },\n    async transform(code, id) {\n      if (isJSRequest(id)) {\n        const extname = path.extname(id).slice(1);\n        const { code: resCode, map } = await esbuild.transform(code, {\n          target: \"esnext\",\n          format: \"esm\",\n          sourcemap: true,\n          loader: extname as \"js\" | \"ts\" | \"jsx\" | \"tsx\",\n        })\n        return {\n          code: resCode,\n          map\n        }\n      }\n      return null\n    }\n  }\n\n}\n\n```\n这个插件有两步，一是读取对应的 片段，二是对其 片段使用 进行处理；"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(二).mdx"}
{"messages":[{"role":"user","content":"7-3、importAnalysisPlugin插件"},{"role":"assistant","content":"```ts\nimport { Plugin } from \"./plugin\";\nimport {\n  BARE_IMPORT_RE,\n  DEFAULT_EXTERSIONS,\n  PRE_BUNDLE_DIR,\n} from \"../contants\";\nimport { ServerContext } from \"../../index\";\nimport { init, parse } from \"es-module-lexer\";\nimport MagicString from \"magic-string\";\nimport {\n  cleanUrl,\n  isJSRequest,\n  normalizePath\n} from \"../utils\";\nimport path from \"path\";\n\nexport function importAnalysisPlugin(): Plugin {\n  let serverContext: ServerContext;\n  return {\n    name: \"m-vite:import-analysis\",\n    configureServer(s) {\n      serverContext = s\n    },\n    async transform(code, id) {\n      const resolve = async (id: string, importer?: string) => {\n        let resolved = await serverContext.PluginContainer.resolveId(id, normalizePath(importer as string));\n\n        if (!resolved) {\n          return\n        }\n        const relPath = resolved.id.startsWith(\"/\") ? resolved.id : normalizePath(\n          path.join('/', path.relative(serverContext.root, resolved.id))\n        );\n        return relPath\n      }\n      if (!isJSRequest(id)) {\n        return null\n      }\n      await init;\n      const [imports] = parse(code);\n      const ms = new MagicString(code);\n\n      for (const importInfo of imports) {\n        const { s: modStart, e: modEnd, n: modSource } = importInfo;\n        if (!modSource) continue;\n        if (BARE_IMPORT_RE.test(modSource as string)) {\n          const bundlePath = normalizePath(\n            path.join('/', PRE_BUNDLE_DIR, `${modSource}.js`)\n          );\n          ms.overwrite(modStart, modEnd, bundlePath as string)\n        } else if (modSource.startsWith(\".\") || modSource.startsWith(\"/\")) {\n          const resolved = await resolve(modSource, id) as string;\n          if (resolved) {\n            ms.overwrite(modStart, modEnd, resolved)\n          }\n        }\n      }\n      return {\n        code: ms.toString(),\n        map: ms.generateMap()\n      }\n    }\n  }\n}\n\n```\n我们由main.tsx开始，来看看他是如何进行处理的"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(二).mdx"}
{"messages":[{"role":"user","content":"1-1-1-1、 可变性"},{"role":"assistant","content":"```rust\nlet space = \"     \";\nlet space = space.len();\n这样可以遮蔽 但如果你使用变量 则会报错 因为我们不能修改变量的类型 涉及到变量类型的修改需要遮蔽\n错误示例\nlet mut spaces = \"   \";\n spaces = spaces.len();\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"1-2-1、基本数据类型"},{"role":"assistant","content":"（ ）类型表示单个值。Rust 有 4 个基本的标量类型：整型、浮点型、布尔型和字符\ni&u 可选值 8，16，32，64，128，size\n整型\n是英文单词 的首字母，与之相反的是 ,\n数字字面量还可以使用 作为可视分隔符以方便读数，如 ，此值和 相同\n整数溢出 在 的情况下，256 变成 0，257 变成 1，依此类推"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"1-2-2、符合数据类型"},{"role":"assistant","content":"1、元组类型\n```rust\n let tup: (i32, f64, u8) = (500, 6.4, 1);\ntup.0\n let (x,y,z) = tup\n```\n2、数组类型\n明确元素数量不需要改变时，数组会更有用,大小 增长或缩小。如果不确定是使用数组还是 vector，那就应该使用一个 vector\n```rust\nlet a: [i32; 5] = [1, 2, 3, 4, 5];\nlet a=[3;5] 等效于let a = [3, 3, 3, 3, 3]\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"1-3、函数"},{"role":"assistant","content":"Rust 代码中的函数和变量名使用下划线命名法（ ，直译为蛇形命名法）规范风格 another_function\n函数调用是一个表达式。宏调用是一个表达式。我们用来创建新作用域的大括号（代码块） 也是一个表达式，表达式的结尾没有分号。如果在表达式的末尾加上分号，那么它就转换为语句，而语句不会返回值。\n```rust\n    let y = {\n        let x = 3;\n        x + 1\n    };\n    println!(\"这是y{}\", y);//这个是成立的 但加上;后，会从表达式变成语句,会报错\n\tfn five() -> i8 {\n    \treturn -2 + 2;\n\t}\n等效于\nfn five() -> i8 {\n    \t -2 + 2\n\t}\n不能加;\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"1-4-1、if"},{"role":"assistant","content":"是一个表达式，我们可以在 语句的右侧使用它来将结果赋值给一个变量;\n```rust\n let  condition = false;\n let number = if condition { 5 } else { 6 };\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"1-4-2、循环"},{"role":"assistant","content":"Rust 有三种循环： 、 和 。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"loop"},{"role":"assistant","content":"关键字告诉 Rust 一遍又一遍地执行一段代码直到你明确要求停止。停止关键字 break\n```rust\nfn loopfn() {\n    let mut x = 0;\n    let _res = loop {\n        if x == 100 {\n            break x;\n        }\n        x += 1;\n    };\n    println!(\"值{}\", x)\n}//loop新婚换可以使用break 返回出值 类似于 if\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"while"},{"role":"assistant","content":"在程序中计算循环的条件也很常见。当条件为真，执行循环。当条件不再为真，调用 停止循环。这个循环类型可以通过组合 、 、 和 来实现；"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"for"},{"role":"assistant","content":"可以使用 循环来对一个集合的每个元素执行一些代码。\n，它是标准库提供的类型，用来生成从一个数字开始到另一个数字之前结束的所有数字的序列,start..end 包左不包右\n```rust\nfn main() {\n    for number in (1..4).rev() {\n        println!(\"{}!\", number);\n    }\n    println!(\"LIFTOFF!!!\");\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"2、所有权"},{"role":"assistant","content":"所有权规则"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"2-1-1、string"},{"role":"assistant","content":"Rust 有第二个字符串类型， 。这个类型管理被分配到堆上的数据，所以能够存储在编译时未知大小的文本。可以使用 函数基于字符串字面量来创建\n双冒号（ ）运算符允许我们将特定的 函数置于 类型的命名空间（namespace）下,而不需要使用类似 这样的名字\n```rust\nlet s = String::from(\"hello\");\n s.push_str(\", world!\"); // push_str() 在字符串后追加字面值\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"2-1-2、移动"},{"role":"assistant","content":"栈内存\n所以这两个 被放入了栈中\n```rust\n let x = 5;\n let y = x;\n```\n以下的代码会对指针产生移动，为了性能考虑，并不会赋值堆内存，而是移动其指针\nRust 同时使第一个变量无效了，这个操作被称为 （ ）\n```rust\n   let s1 = String::from(\"hello\");\n   let s2 = s1;\n//这段代码不能运行\n//当变量离开作用域后，Rust 自动调用 drop 函数并清理变量的堆内存。\n```\n两个指针指向同一个堆，这样会导致在离开时进行两次释放，这是一个叫做 （ ）的错误\nRust 永远也不会自动创建数据的 “深拷贝”。因此，任何 的复制可以被认为对运行时性能影响较小。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"2-1-3、克隆"},{"role":"assistant","content":"可以使用一个叫做 的通用函数\n```rust\n let s1 = String::from(\"hello\");\n let s2 = s1.clone();\n\n println!(\"s1 = {}, s2 = {}\", s1, s2);\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"2-1-4、拷贝"},{"role":"assistant","content":"```rust\n   let x = 5;\n   let y = x;\n\n   println!(\"x = {}, y = {}\", x, y);\n```\n像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的\nRust 有一个叫做 trait 的特殊标注，可以用在类似整型这样的存储在栈上的类型上"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"2-1-5、所有权函数"},{"role":"assistant","content":"将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样。\n```rust\nfn main() {\n    let s: String = String::from(\"hello\");\n    let s1: String = s.clone();\n    takes_ownership(s);\n    println!(\"smain{}\", s1);\n\n    let x = 5; // x 进入作用域\n\n    makes_copy(x);\n    println!(\"xmain{}\", x);\n}\nfn takes_ownership(s: String) {\n    println!(\"s,{}\", s)\n}\nfn makes_copy(some_integer: i32) {\n    // some_integer 进入作用域\n    println!(\"{}\", some_integer);\n}\n```\n传入值进入函数 栈类型会重新赋值\n传入堆的值，会将指针改变指向，因为后续指针变了所以 s 的值就没有了。形参 s 的指针就指向实参的堆了\n返回值也可以转移所有权\n我们可以使用元组来返回多个值\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let (s2, len) = calculate_length(s1);\n\n    println!(\"The length of '{}' is {}.\", s2, len);\n}\n\nfn calculate_length(s: String) -> (String, usize) {\n    let length = s.len(); // len() 返回字符串的长度\n\n    (s, length)\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"2-2、引用"},{"role":"assistant","content":"```rust\nfn main() {\n    println!(\"Hello, world!\");\n    let s1 = String::from(\"hello\");\n    let len = calculate_length(&s1);\n    println!(\"len{},s1{}\", len, s1);\n}\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n//传入后都不会改变指针位置\n```\n& 符号就是 ，它们允许你使用值但不获取其所有权。\n函数签名使用 来表明参数 的类型是一个引用；\n可变引用\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    change(&mut s);\n}\n\nfn change(some_string: &mut String) {\n    some_string.push_str(\", world\");\n}\n```\n可变引用有一个很大的限制：在同一时间，只能有一个对某一特定数据的可变引用。尝试创建两个可变引用的代码将会失败\n```rust\n let mut s = String::from(\"hello\");\n\n    let r1 = &mut s;\n    let r2 = &mut s;\n\n    println!(\"{}, {}\", r1, r2);\n数据竞争，rust不会编译\n* 两个或更多指针同时访问同一数据。\n* 至少有一个指针被用来写入数据。\n* 没有同步数据访问的机制。\n```\n可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能 拥有\n```rust\n    let mut s = String::from(\"hello\");\n\n    {\n        let r1 = &mut s;\n    } // r1 在这里离开了作用域，所以我们完全可以创建一个新的引用\n\n    let r2 = &mut s;\n```\n```rust\n    let mut s = String::from(\"hello\");\n\n    let r1 = &s; // 没问题\n    let r2 = &s; // 没问题\n    let r3 = &mut s; // 大问题\n\n    println!(\"{}, {}, and {}\", r1, r2, r3);\n```\n可变会通过指针访问堆数据，如果不用 mut,&仅仅是借用，无法进行修改，没有存在所有权在&中；\n不能在拥有不可变引用的同时拥有可变引用，多个不可变引用是可以的\n```rust\nlet mut s = String::from(\"hello\");\n\n    let r1 = &s; // 没问题\n    let r2 = &s; // 没问题\n    println!(\"{} and {}\", r1, r2);\n    // 此位置之后 r1 和 r2 不再使用\n\n    let r3 = &mut s; // 没问题\n    println!(\"{}\", r3);\n    let r4 = &mut s; // 没问题\n    println!(\"r4{}\", r4);\n//不可变引用 r1 和 r2 的作用域在 println! 最后一次使用之后结束，这也是创建可变引用 r3 的地方。它们的作用域没有重叠，所以代码是可以编译的\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"2-2-1、悬垂指针"},{"role":"assistant","content":"```\n悬垂指针是其指向的内存可能已经被分配给其它持有者\n```\n```rust\nfn dangle() -> &String { // dangle 返回一个字符串的引用\n\n    let s = String::from(\"hello\"); // s 是一个新字符串\n\n    &s // 返回字符串 s 的引用\n} // 这里 s 离开作用域并被丢弃。其内存被释放。\n  // 危险！\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"2-3、切片 slice"},{"role":"assistant","content":"另一个没有所有权的数据类型是 。slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"2-3-1、"},{"role":"assistant","content":"```rust\n   let s = String::from(\"hello world\");\n\n    let hello = &s[0..5];\n    let world = &s[6..11];\n    let slice = &s[0..2];\n    let slice = &s[..2];\n    let slice = &s[3..len];\n    let slice = &s[3..];\n    let slice = &s[0..len];\n    let slice = &s[..];\n```\n“字符串 slice” 的类型声明写作\n字符串 slice，正如你想象的那样，是针对字符串的。不过也有更通用的 slice 类型。考虑一下这个数组"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"3-1-1、结构体"},{"role":"assistant","content":"类似于对象\n```rust\n\n#[derive(Debug)]\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\nfn main() {\n    let mut user1 = User {\n        email: String::from(\"hello.com\"),\n        active: true,\n        username: String::from(\"姬霓太美\"),\n        sign_in_count: 123456,\n    };\n    user1.email = String::from(\"我是你的谁.com\");\n    // println!(\"{:?}\", user1);\n    test_fn(&mut user1);\n    println!(\"{:?}\", user1);\n}\n\nfn test_fn(test: &mut User) {\n    test.sign_in_count = 5;\n    println!(\"{:?}\", test);\n}\n\n```\n注意 所有权机制\n\n```rust\nfn build_user(email: String, username: String) -> User {\n    User {\n        email,\n        username,\n        active: true,\n        sign_in_count: 1,\n    }\n}\n```\n语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值 必须放在最后\n```rust\n.. 语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值。\n  let user2 = User {\n        username: String::from(\"马喽\"),\n        ..user1\n    };\n```\n所有权会发生移动"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"3-1-2、元组"},{"role":"assistant","content":"```rust\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nfn main() {\n    let black = Color(0, 0, 0);\n    let origin = Point(0, 0, 0);\n}\n\n//元组实际使用场景\nfn main() {\n    let rect1 = (30, 50);\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        area(rect1)\n    );\n}\n\nfn area(dimensions: (u32, u32)) -> u32 {\n    dimensions.0 * dimensions.1\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"3-1-3、单元结构体"},{"role":"assistant","content":"你想要在某个类型上实现 trait 但不需要在类型中存储数据的时候发挥作用\n```rust\nstruct AlwaysEqual;\n\nfn main() {\n    let subject = AlwaysEqual;\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"3-1-4、打印结构体"},{"role":"assistant","content":"```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\"rect1 is {:?}\", rect1);\n}\n```\n在结构体定义之前加上外部属性\n两种风格 \ndbg!宏打印\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let scale = 2;\n    let rect1 = Rectangle {\n        width: dbg!(30 * scale),\n        height: 50,\n    };\n\n    dbg!(&rect1);\n}\n//[src/main.rs:14] &rect1 = Rectangle {\n    //width: 60,\n    //height: 50,\n//}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"3-2、方法语法"},{"role":"assistant","content":"与函数类似：它们使用 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。不过方法与函数是不同的，因为它们在结构体的上下文中被定义（或者是枚举或 trait 对象的上下文，将分别在第 6 章和第 17 章讲解），并且它们第一个参数总是 ，它代表调用该方法的结构体实例。\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {//impl 块中的所有内容都将与 Rectangle 类型相关联\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }//在 area 的签名中，使用 &self 来替代 rectangle: &Rectangle，&self 实际上是 self: &Self 的缩写\n    fn width(&self) -> bool {\n        self.width > 0\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        rect1.area()\n    );\nprintln!(\"Hello, world!{}\", rect1.width());同名的情况下，()是方法，不加（）是值\nprintln!(\"Hello, world!{}\", rect1.width);\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"3-2-1、关联函数"},{"role":"assistant","content":"所有在 块中定义的函数被称为 （ ）\n我们可以定义不以 为第一参数的关联函数（因此不是方法）\n```rust\nimpl Rectangle {\n    fn square(size: u32) -> Rectangle {\n        Rectangle {\n            width: size,\n            height: size,\n        }\n    }\n}\n```\n使用结构体名和 语法来调用这个关联函数：比如 。这个方法位于结构体的命名空间中： 语法用于关联函数和模块创建的命名空间。第 7 章会讲到模块。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"3-2-2、多个 impl 块"},{"role":"assistant","content":"```rust\nimpl Rectangle {\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n}\n\nimpl Rectangle {\n    fn can_hold(&self, other: &Rectangle) -> bool {\n        self.width > other.width && self.height > other.height\n    }\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"4-1-1、定义枚举"},{"role":"assistant","content":"```rust\n#[derive(Debug)]\nenum IpAddrkind {\n    V4,\n    V6,\n}\nstruct IpAddr {\n    kind: IpAddrkind,\n    address: String,\n}\nfn main() {\n    let four = dbg!(IpAddrkind::V4);\n    let six = IpAddrkind::V6;\n    dbg!(four);\n    route(IpAddrkind::V4);\n    route(IpAddrkind::V6);\n    let home = IpAddr {\n        kind: IpAddrkind::V4,\n        address: String::from(\"127.0.0.1\"),\n    };\n    let loopback = IpAddr {\n        kind: IpAddrKind::V6,\n        address: String::from(\"::1\"),\n    };\n}\nfn route(ip_type: IpAddrkind) {}\n\n```\n注意枚举的成员位于其标识符的命名空间中，并使用两个冒号分开。这么设计的益处是现在 和 都是 类型的。例如，接着可以定义一个函数来获取任何 ："}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"4-1-2、枚举成员"},{"role":"assistant","content":"```rust\n    #[derive(Debug)]\n    enum IpAddr {\n        V4(String),\n        V6(String),\n    }\n    let home = IpAddr::V4(String::from(\"127.0.0.1\"));\n    let loopback = IpAddr::V6(String::from(\"::1\"));\n    println!(\"home,{:?}\", home)\n```\n我们直接将数据附加到枚举的每个成员上，这样就不需要一个额外的结构体了\n每个成员可以处理不同类型和数量的数据。IPv4 版本的 IP 地址总是含有四个值在 0 和 255 之间的数字部分。如果我们想要将 地址存储为四个 值而 地址仍然表现为一个 ，这就不能使用结构体了。枚举则可以轻易地处理这个情况：\n莫非 模板字符串出现了\n```rust\nenum IpAddr {\n    V4(u8, u8, u8, u8),\n    V6(String),\n}\n\nlet home = IpAddr::V4(127, 0, 0, 1);\n\nlet loopback = IpAddr::V6(String::from(\"::1\"));\n```\n兼容各种类型\n```rust\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n/////////\nstruct Ipv4Addr {\n    // --snip--\n}\n\nstruct Ipv6Addr {\n    // --snip--\n}\n\nenum IpAddr {\n    V4(Ipv4Addr),\n    V6(Ipv6Addr),\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"4-1-3、枚举的 impl"},{"role":"assistant","content":"```rust\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\nimpl Message {\n    fn call(&self) {\n        println!(\"hello\")\n    }\n}\nfn impl_test() {\n    let msg = Message::Write(String::from(\"wukong\"));\n    println!(\"msg{:?}\", msg);\n    msg.call()\n}\n\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"4-1-4、Option 枚举"},{"role":"assistant","content":"类型应用广泛是因为它编码了一个非常普遍的场景，即一个值要么有值要么没值\nRust 并没有很多其他语言中有的空值功能。 （ ）是一个值，它代表没有值。在有空值的语言中，变量总是这两种状态之一：空值和非空值。不过它确实拥有一个可以编码存在或不存在概念的枚举。这个枚举是\n可以推论出不同类型\n可以在函数中直接使用 ，而不需要写成 ，这是因为 Rust 提供了一个方便的语法糖，使得 可以直接作为 类型的值使用\n```rust\nenum Option<T> {\n    Some(T),\n    None,\n}\n  let some_number = Some(5);\n  let some_string = Some(\"a string\");\n```\n```rust\nlet x: i8 = 5;\nlet y: Option<i8> = Some(5);\n\nlet sum = x + y;\n//这段代码不能编译，因为它尝试将 Option<i8> 与 i8 相加\n```\noption 是内置的，可以直接调用\n```rust\n#[derive(Debug)]\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n    None,\n}\nfn main() {\n    println!(\"Hello, world!\");\n    let val = Value_in_cents(Coin::Penny);\n\n    let val: Option<u8> = Value_in_cents(Coin::None);\n    println!(\"{:?}\", val)\n}\nfn Value_in_cents(coin: Coin) -> Option<u8> {\n    match coin {\n        Coin::Penny => {\n            println!(\"Lucky penny!\");\n            Some(1)\n        }\n        Coin::Dime => Some(5),\n        Coin::Nickel => Some(10),\n        Coin::Quarter => Some(25),\n        Coin::None => None,\n    }\n}\n\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"4-2-5、例子"},{"role":"assistant","content":"```rust\npub mod staff_mod {\n    use crate::const_v::arr_enum::staff::StaffEnum;\n    use std::collections::HashMap;\n    #[derive(Debug)]\n    pub struct Company {\n        department: HashMap<String, Vec<String>>,\n    }\n\n    impl Company {\n        pub fn new() -> Self {\n            Company {\n                department: HashMap::new(),\n            }\n        }\n        pub fn add(&mut self, name: String, department: String) {\n            self.department\n                .entry(department)\n                .or_insert(vec![])\n                .push(name)\n        }\n        pub fn get_department(&self, department_name: String) -> Option<Vec<String>> {\n            let res: Option<&Vec<String>> = self.department.get(&department_name);\n            let res: Option<Vec<String>> = res.cloned();\n\n            if let Some(mut vec) = res {\n                vec.sort();\n                return Some(vec);\n            } else {\n                return None;\n            }\n\n            // match res {\n            //     Some(vec) => println!(\"{:?}\", vec),\n            //     None => println!(\"None\"),\n            // }\n        }\n    }\n}\n\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"4-2、match"},{"role":"assistant","content":"可以把 表达式想象成某种硬币分类器：硬币滑入有着不同大小孔洞的轨道，每一个硬币都会掉入符合它大小的孔洞。同样地，值也会通过 的每一个模式，并且在遇到第一个 “符合” 的模式时，值会进入相关联的代码块并在执行中被使用。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"4-2-1、绑定值"},{"role":"assistant","content":"```rust\n#[derive(Debug)]\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(UsState),\n    None,\n}\n#[derive(Debug)] // 这样可以立刻看到州的名称\nenum UsState {\n    Alabama,\n    Alaska,\n    // --snip--\n}\nfn main() {\n    println!(\"Hello, world!\");\n    let val = Value_in_cents(Coin::Penny);\n\n    let val: Option<u8> = Value_in_cents(Coin::None);\n    let val: Option<u8> = Value_in_cents(Coin::Quarter(UsState::Alabama));\n    println!(\"{:?}\", val)\n}\nfn Value_in_cents(coin: Coin) -> Option<u8> {\n    match coin {\n        Coin::Penny => {\n            println!(\"Lucky penny!\");\n            Some(1)\n        }\n        Coin::Dime => Some(5),\n        Coin::Nickel => Some(10),\n        Coin::Quarter(state) => {\n            println!(\"State quarter from {:?}!\", state);\n            Some(25)\n        }\n        Coin::None => None,\n    }\n}\n\n```\n可以传入枚举值 在 match 中的回调获取当前传入的值"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"4-2-2、Option 匹配"},{"role":"assistant","content":"```rust\n#[derive(Debug)]\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(UsState),\n    None,\n}\n#[derive(Debug)] // 这样可以立刻看到州的名称\nenum UsState {\n    Alabama,\n    Alaska,\n    // --snip--\n}\nfn main() {\n    println!(\"Hello, world!\");\n    let val = Value_in_cents(Coin::Penny);\n\n    let val: Option<u8> = Value_in_cents(Coin::None);\n    let val: Option<u8> = Value_in_cents(Coin::Quarter(UsState::Alabama));\n    println!(\"{:?}\", val);\n    let five: Option<i32> = dbg!(Some(5));\n    println!(\"{:?}\", five);\n    let six = plus_one(five);\n    println!(\"{:?}\", six);\n    let none = plus_one(None);\n}\nfn Value_in_cents(coin: Coin) -> Option<u8> {\n    match coin {\n        Coin::Penny => {\n            println!(\"Lucky penny!\");\n            Some(1)\n        }\n        Coin::Dime => Some(5),\n        Coin::Nickel => Some(10),\n        Coin::Quarter(state) => {\n            println!(\"State quarter from {:?}!\", state);\n            Some(25)\n        }\n        Coin::None => None,\n    }\n}\nfn plus_one(x: Option<i32>) -> Option<i32> {\n    match x {\n        None => None,\n        Some(i) => Some(i + 1),\n    }\n}\n```\n可以通过使用 some，来对值进行处理\nRust 知道我们没有覆盖所有可能的情况甚至知道哪些模式被忘记了！Rust 中的匹配是 （ ）：必须穷举到最后的可能性来使代码有效。特别的在这个 的例子中，Rust 防止我们忘记明确的处理 的情况，这让我们免于假设拥有一个实际上为空的值，从而使之前提到的价值亿万的错误不可能发生。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"4-2-3、通配模式和_占位符"},{"role":"assistant","content":"```rust\n    let dice_roll = 9;\n    match dice_roll {\n        3 => add_fancy_hat(),\n        7 => remove_fancy_hat(),\n        other => move_player(other),\n    }\n\n    fn add_fancy_hat() {}\n    fn remove_fancy_hat() {}\n    fn move_player(num_spaces: u8) {}\n```\n最后一个分支则涵盖了所有其他可能的值，模式是我们命名为 的一个变量。 分支的代码通过将其传递给 函数来使用这个变量。\n因为最后一个模式将匹配所有未被特殊列出的值\nRust 还提供了一个模式，当我们不想使用通配模式获取的值时，请使用 ，这是一个特殊的模式，可以匹配任意值而不绑定到该值。\n我们必须将通配分支放在最后，因为模式是按顺序匹配的。\nother 和*区别 *获取不到参数 ，而 other 则是最后一位，能获取到参数"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"4-2-4、if let"},{"role":"assistant","content":"获取通过等号分隔的一个模式和一个表达式。\n```rust\nfn main() {\n    let mut some_u8_value = 3;\n    if let 3 = some_u8_value {\n        println!(\"three\");\n    } else {\n        some_u8_value += 1;\n        println!(\"some_u8_value{}\", some_u8_value)\n    }\n}\n\n```\n使用 意味着编写更少代码，更少的缩进和更少的样板代码。然而，这样会失去 强制要求的穷尽性检查。\n可以在 中包含一个 。 块中的代码与 表达式中的 分支块中的代码相同，这样的 表达式就等同于 和"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"5-1-1、包"},{"role":"assistant","content":"一个包中至多 包含一个库 crate（library crate）；包中可以包含任意多个二进制 crate（binary crate）；包中至少包含一个 crate，无论是库的还是二进制的\n在此，我们有了一个只包含 的包，意味着它只含有一个名为 的二进制 crate。如果一个包同时含有 和 ，则它有两个 crate：一个库和一个二进制项，且名字都与包相同。通过将文件放在 目录下，一个包可以拥有多个二进制 crate：每个 下的文件都会被编译成一个独立的二进制 crate。\n将一个 crate 的功能保持在其自身的作用域中，可以知晓一些特定的功能是在我们的 crate 中定义的还是在 crate 中定义的，这可以防止潜在的冲突。例如， crate 提供了一个名为 的特性（trait）。我们还可以在我们自己的 crate 中定义一个名为 的 。因为一个 crate 的功能是在自身的作用域进行命名的，当我们将 作为一个依赖，编译器不会混淆 这个名字的指向。在我们的 crate 中，它指向的是我们自己定义的 。我们可以通过 这一方式来访问 crate 中的 特性（trait）。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"5-1-2、模块的作用域和私有性"},{"role":"assistant","content":"通过执行 ，来创建一个新的名为 的库。然后将示例 7-1 中所罗列出来的代码放入 中，来定义一些模块和函数\n```rust\nmod front_of_house {\n    mod hosting {\n        fn add_to_waitlist() {}\n\n        fn seat_at_table() {}\n    }\n\n    mod serving {\n        fn take_order() {}\n\n        fn serve_order() {}\n\n        fn take_payment() {}\n    }\n}\n```\n和 被称为 crate 根。如此称呼的原因是，这两个文件中任意一个的内容会构成名为 的模块，且该模块位于 crate 的被称为 的模块结构的根部"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"5-1-3、路径用于引用模块树中的项"},{"role":"assistant","content":"路径有两种形式：\n作用域\nRust 中默认所有项（函数、方法、结构体、枚举、模块和常量）都是私有的。父模块中的项不能使用子模块中的私有项，但是子模块中的项可以使用他们父模块中的项。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"pub"},{"role":"assistant","content":"可以通过使用 关键字来创建公共项，使子模块的内部部分暴露给上级模块\n函数是私有的。私有性规则不但应用于模块，还应用于结构体、枚举、函数和方法\n```rust\n#[cfg(test)]\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n        fn seat_at_table() {}\n    }\n    mod serving {\n        fn take_order() {}\n        fn serve_order() {}\n        fn take_payment() {}\n    }\n}\npub fn eat_at_restaurant() {\n    // 绝对路径\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // 相对路径\n    front_of_house::hosting::add_to_waitlist();\n}\n\n```\n我们还可以使用 来设计公有的结构体和枚举，不过有一些额外的细节需要注意。如果我们在一个结构体定义的前面使用了 ，这个结构体会变成公有的，但是这个结构体的字段仍然是私有的\n```rust\n\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n        fn seat_at_table() {}\n    }\n    mod serving {\n        fn take_order() {}\n        fn serve_order() {}\n        fn take_payment() {}\n    }\n}\npub fn eat_at_restaurant() {\n    // 绝对路径\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // 相对路径\n    front_of_house::hosting::add_to_waitlist();\n    let mut meal = back_of_house::Breakfast::summer(\"Rye\");\n    meal.toast = String::from(\"Wheat\");\n//不能修改seasonal_fruit 因为它是私有的\n    println!(\"I'd like {} toast please\", meal.toast);\n}\nfn serve_order() {}\nmod back_of_house {\n    fn fix_incorrect_order() {\n        cook_order();\n        super::serve_order();\n    }\n    pub struct Breakfast {\n        pub toast: String,\n        seasonal_fruit: String,\n    }\n    impl Breakfast {\n        pub fn summer(toast: &str) -> Breakfast {\n            Breakfast {\n                toast: String::from(toast),\n                seasonal_fruit: String::from(\"peaches\"),\n            }\n        }\n    }\n}\n\n\n\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"枚举"},{"role":"assistant","content":"```rust\n\nmod back_of_house {\n    pub enum Appetizer {\n        Soup,\n        Salad,\n    }\n}\n\npub fn eat_at_restaurant() {\n    let order1 = back_of_house::Appetizer::Soup;\n    let order2 = back_of_house::Appetizer::Salad;\n}\n```\n如果枚举成员不是公有的，那么枚举会显得用处不大；给枚举的所有成员挨个添加 是很令人恼火的，因此枚举成员默认就是公有的。结构体通常使用时，不必将它们的字段公有化，因此结构体遵循常规，内容全部是私有的，除非使用 关键字。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"super"},{"role":"assistant","content":"我们还可以使用 开头来构建从父模块开始的相对路径。这么做类似于文件系统中以 开头的语法。\n```rust\nfn serve_order() {}\nmod back_of_house {\n    fn fix_incorrect_order() {\n        cook_order();\n        super::serve_order();\n    }\n}\n\n```\n我们认为 模块和 函数之间可能具有某种关联关系，并且，如果我们要重新组织这个 crate 的模块树，需要一起移动它们。因此，我们使用 ，这样一来，如果这些代码被移动到了其他模块，我们只需要更新很少的代码"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"5-1-4、use"},{"role":"assistant","content":"在作用域中增加 和路径类似于在文件系统中创建软连接（符号连接，symbolic link）。通过在 crate 根增加 ，现在 在作用域中就是有效的名称了，如同 模块被定义于 crate 根一样。通过 引入作用域的路径也会检查私有性，同其它路径一样\n和相对路径来将一个项引入作用域\n```rust\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\nuse crate::front_of_house::hosting;\n//use front_of_house::hosting;\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist;\n}\n```\n其他包引入\n```rust\nuse std::fmt;\nuse std::io;\n\nfn function1() -> fmt::Result {\n    // --snip--\n}\n\nfn function2() -> io::Result<()> {\n    // --snip--\n}\n//使用as关键字来解决\nuse std::fmt::Result;\nuse std::io::Result as IoResult;\n\nfn function1() -> Result {\n    // --snip--\n}\n\nfn function2() -> IoResult<()> {\n    // --snip--\n}\n```\n如你所见，使用父模块可以区分这两个 类型。如果我们是指定 和 ，我们将在同一作用域拥有了两个 类型，当我们使用 时，Rust 则不知道我们要用的是哪个。\n我们可以使用 as 关键字来提供新名称"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"重导出"},{"role":"assistant","content":"当使用 关键字将名称导入作用域时，在新作用域中可用的名称是私有的。如果为了让调用你编写的代码的代码能够像在自己的作用域内引用这些类型，可以结合 和 。这个技术被称为 “ （ ）”\n```rust\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub use crate::front_of_house::hosting;\n// pub use，我们可以使用一种结构编写代码，却将不同的结构形式暴露出来。这样做使我们的库井井有条，方便开发这个库的开发者和调用这个库的开发者之间组织起来\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\n```\n通过 ，现在可以通过新路径 来调用 函数。如果没有指定 ， 函数可以在其作用域中调用 ，但外部代码则不允许使用这个新路径。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"使用外部包"},{"role":"assistant","content":"```rust\nuse rand::Rng;\nuse std::collections::HashMap;\nfn main() {\n    let secret_number = rand::thread_rng().gen_range(1..101);\n}\n```\n注意标准库（ ）对于你的包来说也是外部 crate。因为标准库随 Rust 语言一同分发，无需修改 来引入 ，不过需要通过 将标准库中定义的项引入项目包的作用域中来引用它们，比如我们使用的 ："}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"嵌套路径"},{"role":"assistant","content":"```rust\nuse std::cmp::Ordering;\nuse std::io;\n等同于\nuse std::{cmp::Ordering, io}; 一样的可以合在一起\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"glob"},{"role":"assistant","content":"```rust\nuse std::collections::*;\n```\n这个 语句将 中定义的所有公有项引入当前作用域。使用 glob 运算符时请多加小心！Glob 会使得我们难以推导作用域中有什么名称和它们是在何处定义的。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"5-1-5 分割不同的文件"},{"role":"assistant","content":"```rust\n\n/lib.rs\nmod front_of_house;\n需要再同级目录下有这个文件名\n/front_of_house.rs\npub mod hosting;\n\n//需要再同名目录下有这个文件名\n/front_of_house/hosting\npub fn add_to_waitlist() {}\n\n上述后两步等效\npub mod hosting {\n    pub fn add_to_waitlist() {}\n}\n在 mod front_of_house 后使用分号，而不是代码块，这将告诉 Rust 在另一个与模块同名的文件中加载模块的内容。继续重构我们例子，将 hosting 模块也提取到其自己的文件中，仅对 src/front_of_house.rs 包含 hosting 模块的声明进行修改：\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"6-1、vec"},{"role":"assistant","content":"是的，Rust 中的 （动态数组）也要求其所有元素必须是同一类型。 是 Rust 标准库中提供的一种动态大小的数组类型，但它仍然遵循 Rust 的类型系统规则，即所有元素必须是同质的。\n类似于任何其他的 ，vector 在其离开作用域时会被释放，如示例 8-4 所标注的"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"6-1-1、语法"},{"role":"assistant","content":"```rust\nlet v: Vec<i32> = Vec::new();\nlet v = vec![1, 2, 3];\n```\nRust 提供了 宏。这个宏会根据我们提供的值来创建一个新的\n修改值必须使用 关键字使其可变。放入其中的所有值都是 类型的，\n注:用此方法超出范围不会报错\n```rust\n    match v.get(100) {\n        Some(x) => println!(\"{:?}\", x),\n        None => println!(\"None\"),\n    }\n```\n```rust\n//报错\nlet mut v = vec![1, 2, 3, 4, 5];\n\nlet first = &v[0];\n\nv.push(6);\n\nprintln!(\"The first element is: {}\", first);\n\n//修正\nlet mut v = vec![1, 2, 3, 4, 5];\nv.push(6);\nlet first = &v[0];\nprintln!(\"The first element is: {}\", first);\n```\n在读取元素后再添加，内存会发生变化，前面的代码不知有它，不认过去，君生我未生；"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"6-1-2、循环"},{"role":"assistant","content":"```rust\n    for i in &mut v {\n        *i += 50\n    }\n```\n为了修改可变引用所指向的值，在使用 运算符之前必须使用解引用运算符（ ）获取 中的值"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"6-1-3、枚举结合 vec"},{"role":"assistant","content":"```rust\n    enum spreadsheetceel {\n        Int(i32),\n        Float(f64),\n        Text(String),\n    };\n    let row = vec![\n        spreadsheetceel::Int(3),\n        spreadsheetceel::Text(String::from(\"blue\")),\n        spreadsheetceel::Float(10.12),\n    ];\n```\n用枚举生成 vec，可以存储不同的类型，另外 可以使用 match 来对不同的值进行匹配 确保不会报错"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"6-2-1、初始化"},{"role":"assistant","content":"以下两个方法等效\n字符串是 UTF-8 编码的，所以可以包含任何正确编码的数据\n```rust\n    let s = \"initContent\".to_string();\n    let s = String::from(\"initial contents\");\n    println!(\"{}\", s);\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"6-2-2、更新字符串"},{"role":"assistant","content":"可以通过 方法来附加字符串 slice，从而使 变长，如示例 8-15 所示。\n```rust\nlet mut s1 = String::from(\"foo\");\nlet s2 = \"bar\";\ns1.push_str(s2);\nprintln!(\"s2 is {}\", s2);\n```\ns2 是 slice，我们不能获取其所有权，避免自身所有权失效\n方法被定义为获取一个单独的字符作为参数，并附加到 中\n```rust\nlet mut s = String::from(\"lo\");\ns.push('l');\n```\n拼接，遵循所有权规则\n```rust\n    let s1 = String::from(\"Hello, \");\n    let s2 = String::from(\"world\");\n    let res = s1 + &s2;\n    println!(\"{},{}\", res, s2);\n```\n运算符使用了 函数，这个函数签名看起来像这样：\nself 的所有权会被获取\n```rust\nfn add(self, s: &str) -> String {\n\n```\n使用了 ，意味着我们使用第二个字符串的 与第一个字符串相加。这是因为 函数的 参数：只能将 和 相加，不能将两个 值相加。\n可以被 （ ）成 。当 函数被调用时，Rust 使用了一个被称为 （ ）的技术，你可以将其理解为它把 变成了"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"6-2-3、  宏"},{"role":"assistant","content":"与 的工作原理相同，不过不同于将输出打印到屏幕上，它返回一个带有结果内容的 。这个版本就好理解的多，并且不会获取任何参数的所有权。\n```rust\n let s1 = String::from(\"tic\");\n    let s2 = String::from(\"tic\");\n    let s3 = String::from(\"tic\");\n    let s = format!(\"{}-{}-{}\", s1, s2, s3);\n    println!(\"{}\", s);\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"6-2-4、索引字符串"},{"role":"assistant","content":"Rust 不允许使用索引获取 字符的原因是，索引操作预期总是需要常数时间 (O(1))。但是对于 不可能保证这样的性能，因为 Rust 必须从开头到索引位置遍历来确定有多少有效的字符。\n比如一些非英文字符，在字节码中不能确保是第一位\n我们可以用 slice 来解决\n```rust\n    let hello = \"Здравствуйте\";\n    let s = &hello[0..4];\n    println!(\"{}\", s)\n这里，s 会是一个 &str，它包含字符串的头 4 个字节。早些时候，我们提到了这些字母都是 2 个字节长的，所以这意味着 s 将会是 “Зд”。\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"6-2-5、遍历字符串"},{"role":"assistant","content":"如果你需要操作单独的 Unicode 标量值，最好的选择是使用 方法。对 “नमस्ते” 调用 方法会将其分开并返回六个 类型的值，接着就可以遍历其结果来访问每一个元素了：\n```rust\n    for c in hello.chars() {\n        println!(\"{}\", c);\n    }\n\n```\n方法返回每一个原始字节，这可能会适合你的使用场景\n```rust\nfor b in \"नमस्ते\".bytes() {\n    println!(\"{}\", b);\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"6-3、hash-map"},{"role":"assistant","content":"像 vector 一样，哈希 map 将它们的数据储存在堆上，这个 的键类型是 而值类型是 。类似于 vector，哈希 map 是同质的：所有的键必须是相同类型，值也必须都是相同类型。\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\n\nscores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Yellow\"), 50);\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"6-3-1、元组构建"},{"role":"assistant","content":"是使用一个元组的 vector 的 方法，其中每个元组包含一个键值对。 方法可以将数据收集进一系列的集合类型，包括 。例如，如果队伍的名字和初始分数分别在两个 vector 中，可以使用 方法来创建一个元组的 vector，其中 “Blue” 与 10 是一对，依此类推。接着就可以使用 方法将这个元组 vector 转换成一个 ，如示例 8-21 所示：\n必须规定类型\n```rust\n   let teams = vec![String::from(\"Blue\"), String::from(\"Yellow\")];\n    let initial_scores = vec![10, 50];\n    let score: HashMap<_, _> = teams.iter().zip(initial_scores).collect();\n    println!(\"{:?}\", score);\n```\n在类型中规定借用即可\n```rust\n  let a = [1, 2, 3];\n  let b = [4, 5, 6];\n\n    let zipped: Vec<(&i32, &i32)> = a.iter().zip(b.iter()).collect();\n```\n这里 类型标注是必要的，因为 有可能当成多种不同的数据结构，而除非显式指定否则 Rust 无从得知你需要的类型。但是对于键和值的类型参数来说，可以使用下划线占位，而 Rust 能够根据 vector 中数据的类型推断出 所包含的类型。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"6-3-2、hashma 和所有权"},{"role":"assistant","content":"```rust\nuse std::collections::HashMap;\n\nlet field_name = String::from(\"Favorite color\");\nlet field_value = String::from(\"Blue\");\n\nlet mut map = HashMap::new();\nmap.insert(field_name, field_value);\n// 这里 field_name 和 field_value 不再有效，\n// 尝试使用它们看看会出现什么编译错误！\n```\n当 调用将 和 移动到哈希 map 中后，将不能使用这两个绑定。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"6-3-3、访问 hashmap 中的值"},{"role":"assistant","content":"通过 get 访问 hashmap 的值，注意所有权及借用\n返回 ，所以结果被装进 如果没有对应值，会返回\n```rust\n    let field_name = String::from(\"Favorite color\");\n    let field_value = String::from(\"Blue\");\n\n    let mut map = HashMap::new();\n    map.insert(&field_name, &field_value);\n\n    let val = map.get(&field_name);\n    println!(\"{:?}\", val);\n```\n使用与 vector 类似的方式来遍历哈希 map 中的每一个键值对，也就是 循环：\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\n\nscores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Yellow\"), 50);\n\nfor (key, value) in &scores {\n    println!(\"{}: {}\", key, value);\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"6-3-4、键入"},{"role":"assistant","content":"覆盖值\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\n\nscores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Blue\"), 25);\n\nprintln!(\"{:?}\", scores);\n```\n没有对应值\n哈希 map 有一个特有的 API，叫做 ，它获取我们想要检查的键作为参数。 函数的返回值是一个枚举，\n```rust\n  let mut map: HashMap<&String, &String> = HashMap::new();\n    map.insert(&field_name, &field_value);\n\n    let val = map.get(&field_name);\n    println!(\"{:?}\", val);\n    let str: String = String::from(\"haha\");\n    let name: String = String::from(\"haha\");\n    map.entry(&field_name).or_insert(&str);\n    let enter_v = map.entry(&name).or_insert(&str);\n    println!(\"{:?}\", enter_v);\n    println!(\"{:?}\", map);\n```\nmap 和 get 不能一起， 对 进行了可变借用，而 对 进行了不可变借用。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"6-3-5、根据旧值更新"},{"role":"assistant","content":"方法事实上会返回这个键的值的一个可变引用（ ）,所以为了赋值必须首先使用星号（ ）解引用\n```rust\n    let text = \"hello world wonderful world\";\n    let mut map = HashMap::new();\n    for word in text.split_whitespace() {\n        let count = map.entry(word).or_insert(0);\n        *count += 1;\n    }\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"7-1、Result 与可恢复的错误"},{"role":"assistant","content":"```rust\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    let f = File::open(\"hello.txt\");\n\n    let f = match f {\n        Ok(file) => file,\n        Err(error) => match error.kind() {\n            ErrorKind::NotFound => match File::create(\"hello.txt\") {\n                Ok(fc) => fc,\n                Err(e) => panic!(\"Problem creating the file: {:?}\", e),\n            },\n            other_error => panic!(\"Problem opening the file: {:?}\", other_error),\n        },\n    };\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"7-1-1、panic 简写:unwrap 和 expect"},{"role":"assistant","content":"，它的实现就类似于示例 9-4 中的 语句。如果 值是成员 ， 会返回 中的值。如果 是成员 ， 会为我们调用 。这里是一个实践 的例子：\n```rust\nuse std::fs::File;\n\nfn main() {\n    let f = File::open(\"hello.txt\").unwrap();\n}\n\n```\n使用 而不是 并提供一个好的错误信息可以表明你的意图并更易于追踪 panic 的根源。 的语法看起来像这样\n```rust\nuse std::fs::File;\n\nfn main() {\n    let f = File::open(\"hello.txt\").expect(\"Failed to open hello.txt\");\n}\n```\n在调用 时使用的错误信息将是我们传递给 的参数，而不像 那样使用默认的 信息,expect 是自定义的，帮助我们更容易找到错误信息"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"7-1-2、错误传播简写 ?UI 运算符"},{"role":"assistant","content":"```rust\nuse std::io;\nuse std::io::Read;\nuse std::fs::File;\n\nfn read_username_from_file() -> Result<String, io::Error> {\n    let mut f = File::open(\"hello.txt\")?;\n    let mut s = String::new();\n    f.read_to_string(&mut s)?;\n    Ok(s)\n}\n```\n运算符消除了大量样板代码并使得函数的实现更简单。我们甚至可以在 之后直接使用链式方法调用来进一步缩短代码，如示例 9-8 所示：\n```rust\nuse std::io;\nuse std::io::Read;\nuse std::fs::File;\n\nfn read_username_from_file() -> Result<String, io::Error> {\n    let mut s = String::new();\n\n    File::open(\"hello.txt\")?.read_to_string(&mut s)?;\n\n    Ok(s)\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"7-1-3、main 的?处理"},{"role":"assistant","content":"函数是特殊的，其必须返回什么类型是有限制的。 函数的一个有效的返回值是 ，同时出于方便，另一个有效的返回值是 ，如下所示：\n```rust\nuse std::error::Error;\nuse std::fs::File;\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let f = File::open(\"hello.txt\")?;\n\n    Ok(())\n}\n```\n函数是特殊的，其必须返回什么类型是有限制的。 函数的一个有效的返回值是 ，同时出于方便，另一个有效的返回值是"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"7-1-4、可以帮助函数中断"},{"role":"assistant","content":"```rust\nimpl Guess {\n    pub fn new(value: i32) -> Guess {\n        if value < 1 || value > 100 {\n            panic!(\"Guess value must be between 1 and 100, got {}.\", value);\n        }\n\n        Guess { value }\n    }\n\n    pub fn value(&self) -> i32 {\n        self.value\n    }\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"8-1-1、函数泛型"},{"role":"assistant","content":"```rust\nfn largest<T: PartialOrd + Copy>(list: &Vec<T>) -> T {\n    let mut largest = list[0];\n    for &item in list.iter() {\n        if item > largest {\n            largest = item;\n        }\n    }\n    largest\n}\n```\n涉及到 trait"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"8-1-2、结构体和枚举"},{"role":"assistant","content":"```rust\nstruct PointA<T> {\n    x: T,\n    y: T,\n}\n//两个类型一致\nstruct Point<T, U> {\n    x: T,\n    y: U,\n}\n//可以不一致\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"8-1-3、方法"},{"role":"assistant","content":"```rust\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Point<T> {\n    fn x(&self) -> &T {\n        &self.x\n    }\n}\n\nfn main() {\n    let p = Point { x: 5, y: 10 };\n\n    println!(\"p.x = {}\", p.x());\n}\n```\n必须在 后面声明 ，这样就可以在 上实现的方法中使用它了。在 之后声明泛型 ，这样 Rust 就知道 的尖括号中的类型是泛型而不是具体类型。\n```rust\nstruct Point<T, U> {\n    x: T,\n    y: U,\n}\nimpl<T, U> Point<T, U> {\n    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {\n        Point {\n            x: self.x,\n            y: other.y,\n        }\n    }\n}\n```\n可以用类型推断，多个类型会根据方法参数的类型进行推断"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"8-2、trait"},{"role":"assistant","content":"类似于其他语言中常被称为 （ ）的功能，虽然有一些不同。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"8-2-1、定义 trait"},{"role":"assistant","content":"如果可以对不同类型调用相同的方法的话，这些类型就可以共享相同的行为了。trait 定义是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合\n```rust\npub mod _trait {\n    pub trait Summary {\n        fn summarize(&self) -> String;\n    }\n}\n```\ntrait 体中可以有多个方法：一行一个方法签名且都以分号结尾。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"8-2-2、结构体"},{"role":"assistant","content":"```rust\nmod _trait;\npub use _trait::_trait::Summary;\npub struct NewsArticle {\n    pub headline: String,\n    pub location: String,\n    pub author: String,\n    pub content: String,\n}\n\nimpl Summary for NewsArticle {\n    fn summarize(&self) -> String {\n        format!(\"{}, by {} ({})\", self.headline, self.author, self.location)\n    }\n}\n\npub struct Tweet {\n    pub username: String,\n    pub content: String,\n    pub reply: bool,\n    pub retweet: bool,\n}\n\nimpl Summary for Tweet {\n    fn summarize(&self) -> String {\n        format!(\"{}: {}\", self.username, self.content)\n    }\n}\n```\n它们并不位于 crate 本地作用域中。这个限制是被称为 （ ） 的程序属性的一部分，或者更具体的说是 （ ），其得名于不存在父类型。这条规则确保了其他人编写的代码不会破坏你代码，反之亦然。没有这条规则的话，两个 crate 可以分别对相同类型实现相同的 trait，而 Rust 将无从得知应该使用哪一个实现。\n不能修改其他的 trait"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"8-2-3、默认实现"},{"role":"assistant","content":"```rust\npub mod _trait {\n    pub trait Summary {\n        fn summarize(&self) -> String;\n        fn default_summarize(&self) -> String {\n            String::from(\"Read more ...\")\n        }\n    }\n}\n\nimpl Summary for NewsArticle {\n    fn summarize(&self) -> String {\n        format!(\"{},by {} ({})\", self.headline, self.author, self.author)\n    }\n    fn default_summarize(&self) -> String {\n        format!(\"默认实现取消\")\n    }\n}\nimpl Summary for Tweet {\n    fn summarize(&self) -> String {\n        format!(\"{}:{}\", self.username, self.content)\n    }\n}\n```\n该 impl 如果重新定义默认实现的函数 则优先调用定义后的值，\n无法从相同方法的重载实现中调用默认方法"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"8-2-4、可作为参数"},{"role":"assistant","content":"```rust\npub fn notify(item: impl Summary) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"8-2-5、trait Bound 语法"},{"role":"assistant","content":"可以通过作为泛型的值来进行简写\n\n```rust\npub fn notify(item: &impl Summary, item2: &impl Summary) {\n    // println!(\"{:?}\", item)\n}\npub fn notify2<T: Summary>(item: &T, item2: &T) {\n    // println!(\"{:?}\", item)\n}\nfn main() {\n    let article = NewsArticle {\n        headline: String::from(\"Penguins win the Stanley Cup Championship!\"),\n        location: String::from(\"Pittsburgh, PA, USA\"),\n        author: String::from(\"Iceburgh\"),\n        content: String::from(\n            \"The Pittsburgh Penguins once again are the best\n    hockey team in the NHL.\",\n        ),\n    };\n    notify(&article, &article);\n    notify2(&article, &article);\n    // notify();\n    println!(\"Hello, world!\");\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"8-2-6、通过+指定多个 bound"},{"role":"assistant","content":"两个 debug 都需要\n```rust\nuse std::fmt::Debug;\n#[derive(Debug, Clone)]\npub struct NewsArticle {\n.....\n}\npub fn notify<T: Summary + Clone + Debug>(item: &T, item2: &T) {\n    let res = format!(\"{}\", item.clone().summarize());\n    let res2 = item2.clone();\n    println!(\"{},{:#?}\", res, res2)\n}\n```\n简写\n```rust\npub fn notify3<T, U>(item: &T, item2: &U)\nwhere\n    T: Summary,\n    U: Summary + Debug + Clone,\n{\n    let res = format!(\"{}\", item.summarize());\n    let res2 = item2.clone();\n    println!(\"{},{:#?}\", res, res2)\n}\n```\n8-2-7、retrun 定义 trait\n```rust\nfn returns_summarizable() -> impl Summary {\n    Tweet {\n        username: String::from(\"horse_ebooks\"),\n        content: String::from(\"of course, as you probably already know, people\"),\n        reply: false,\n        retweet: false,\n    }\n}\n```\n```rust\n  returns_summarizable(&mut article);\n  fn returns_summarizable(_item: &mut NewsArticle) -> &dyn Summary {\n    _item\n}\n\n```\n只适用于返回单一类型的情况"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"8-2-7、可选 impl"},{"role":"assistant","content":"只有满足打印 Display，且比较 PartialOrd 此函数才会生效\n```rust\nimpl<T: Display + PartialOrd> Pair<T> {\n    fn cmp_display(&self) {\n        if self.x >= self.y {\n            println!(\"The largest member is x = {}\", self.x);\n        } else {\n            println!(\"The largest member is y = {}\", self.y);\n        }\n    }\n}\n```\n标准库\n```rust\nimpl<T: Display> ToString for T {\n    // --snip--\n}\n```\n我们可以对任何实现了 trait 的类型调用由 定义的 方法,可以将整型转换为对应的 值，因为整型实现了"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"8-3、生命周期"},{"role":"assistant","content":"主要用来处理引用数据类型发生的错误"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"8-3-1、函数中的泛型生命周期"},{"role":"assistant","content":"生命周期参数名称必须以撇号（ ）开头，其名称通常全是小写，类似于泛型其名称非常短。 是大多数人默认使用的名称。生命周期参数标注位于引用的 之后，并有一个空格来将引用类型与生命周期标注分隔开。\n所替代的具体生命周期是 的作用域与 的作用域相重叠的那一部分。换一种说法就是 。因为我们用相同的生命周期参数 标注了返回的引用值，所以返回的引用值就能保证在 和 中较短的那个生命周期结束之前保持有效。\n```\nuse std::env;\nuse std::fs;\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let query = &args[1];\n    let filename = &args[2];\n    let contents = fs::read_to_string(filename).expect(\"Error reading file\");\n    println!(\"With text:\\n{}\", contents);\n    parse_config(query, filename);\n}\nfn parse_config<'a>(query: &'a str, filename: &'a str) -> (&'a str, &'a str) {\n    // let query = &args[1];\n    // let filename = &args[2];\n    (query, filename)\n}\n\n```\n```rust\n\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n```\n成功\n```rust\n  let string1 = String::from(\"long string is long\");\n\n    {\n        let string2 = String::from(\"xyz\");\n        let result = longest(string1.as_str(), string2.as_str());\n        println!(\"The longest string is {}\", result);\n    }\n```\n失败\n```rust\n   let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = String::from(\"xyz\");\n        result = longest(string1.as_str(), string2.as_str());\n    }\n    println!(\"The longest string is {}\", result);\n```\n该函数的生命周期与较短的保持一致，说明在 string2 生命周期结束时，rusult 的生命周期就结束了\n报错,如果直接返回 String 不会报错 ，as_str 返回的是一个&str 类型 是一个引用，没有所有权\n```rust\n\nfn longest2() -> &str {\n    let result = String::from(\"really long string\");\n    let res = result.as_str();\n    res\n}\n\n```\n最好的解决方案是返回一个有所有权的数据类型而不是一个引用，这样函数调用者就需要负责清理这个值了。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"8-3-2、结构体定义的生命周期"},{"role":"assistant","content":"这是一个引用值，我们可以在 struct 中定义它的生命周期，novel 在上面 他的生命周期比 import 的生命周期更长，当 import 退出的时候 novel 都不会退出 所以 他的引用值是有效的\n```rust\nstruct ImportantExcerpt<'a> {\n    part: &'a str,\n}\n\nfn main() {\n    let novel = String::from(\"Call me Ishmael. Some years ago...\");\n    let first_sentence = novel.split('.')\n        .next()\n        .expect(\"Could not find a '.'\");\n    let i = ImportantExcerpt { part: first_sentence };\n}\n```\n在 Rust 中，如果你有一个结构体包含 的字段，你必须为这些引用字段指定生命周期参数。这是因为 Rust 需要确保这些引用的生命周期是有效的，并且不会在结构体实例的生命周期内变得无效。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"8-3-3、省略生命周期"},{"role":"assistant","content":"第一条规则是每一个是引用的参数都有它自己的生命周期参数。换句话说就是，有一个引用参数的函数有一个生命周期参数： ，有两个引用参数的函数有两个不同的生命周期参数， ，依此类推。\n第二条规则是如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数： 。\n第三条规则是如果方法有多个输入生命周期参数并且其中一个参数是 或 ，说明是个对象的方法(method)(译者注： 这里涉及 Rust 的面向对象，参见第 17 章), 那么所有输出生命周期参数被赋予 的生命周期。第三条规则使得方法更容易读写，因为只需更少的符号。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"8-3-4、方法的生命周期"},{"role":"assistant","content":"之后和类型名称之后的生命周期参数是必要的，不过因为第一条生命周期规则我们并不必须标注 引用的生命周期。\n```rust\nimpl<'a> ImportantExcerpt<'a> {\n    fn level(&self) -> i32 {\n        3\n    }\n}\n```\n这里是一个适用于第三条生命周期省略规则的例子：\n因为其中一个参数是 ，返回值类型被赋予了 的生命周期，这样所有的生命周期都被计算出来了\n```rust\nimpl<'a> ImportantExcerpt<'a> {\n    fn announce_and_return_part(&self, announcement: &str) -> &str {\n        println!(\"Attention please: {}\", announcement);\n        self.part\n    }\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"8-3-5、静态生命周期"},{"role":"assistant","content":"这里有一种特殊的生命周期值得讨论： ，其生命周期 存活于整个程序期间。所有的字符串字面量都拥有 生命周期，我们也可以选择像下面这样标注出来：\n```rust\nlet s: &'static str = \"I have a static lifetime.\";\n```\n因为生命周期也是泛型，所以生命周期参数 和泛型类型参数 都位于函数名后的同一尖括号列表中"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"8-3-6、生命周期与 trait"},{"role":"assistant","content":"```rust\nfn longest_with_an_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str\nwhere\n    T: Display,\n{\n    println!(\"Announcement! {}\", ann);\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n```\n这个额外的参数会在函数比较字符串 slice 的长度之前被打印出来，这也就是为什么 trait bound 是必须的。因为生命周期也是泛型，所以生命周期参数 和泛型类型参数 都位于函数名后的同一尖括号列表中。\n如果不加 Display，无法确定泛型类型，也就无法判断能否打印\n总结 trait 帮其规定为泛型时候的行为"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"9-1-1、#[test]"},{"role":"assistant","content":"：这个属性表明这是一个测试函数\n```rust\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n        assert_eq!(2 + 2, 4);\n    }\n}\n```\n函数体通过使用 宏来断言 2 加 2 等于 4。一个典型的测试的格式，就是像这个例子中的断言一样。接下来运行就可以看到测试通过。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"9-1-2、"},{"role":"assistant","content":"宏由标准库提供，在希望确保测试中一些条件为 时非常有用。需要向 宏提供一个求值为布尔值的参数\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn larger_can_hold_smaller() {\n        let larger = Rectangle { width: 8, height: 7 };\n        let smaller = Rectangle { width: 5, height: 1 };\n\n        assert!(larger.can_hold(&smaller));\n    }\n}\n```\n注意在 模块中新增加了一行： 。 是一个普通的模块，它遵循第 7 章 部分介绍的可见性规则。因为这是一个内部模块，要测试外部模块中的代码，需要将其引入到内部模块的作用域中。 。\n让我们为测试函数增加一个自定义失败信息参数：带占位符的格式字符串，以及 函数的值：\n```rust\n#[test]\nfn greeting_contains_name() {\n    let result = greeting(\"Carol\");\n    assert!(\n        result.contains(\"Carol\"),\n        \"Greeting did not contain name, value was `{}`\", result\n    );\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"9-1-2、 和 "},{"role":"assistant","content":"这两个宏分别比较两个值是相等还是不相等。当断言失败时他们也会打印出这两个值具体是什么，以便于观察测试 失败\n```rust\n    fn exploration() {\n        assert_eq!(2 + 2, 4);\n    }\n```\n宏在传递给它的两个值不相等时通过，而在相等时失败。在代码按预期运行，我们不确定值 是什么，不过能确定值绝对 是什么的时候，这个宏最有用处。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"9-1-3、#[should_panic]"},{"role":"assistant","content":"可以通过对函数增加另一个属性 来实现这些。这个属性在函数中的代码 panic 时会通过，而在其中的代码没有 panic 时失败。\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn greater_than_100() {\n        Guess::new(200);\n    }\n}\n```\n我们可以给 属性增加一个可选的 参数。测试工具会确保错误信息中包含其提供的文本\n```rust\n#[should_panic(expected = \"Guess value must be less than or equal to 100\")]\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"9-1-4 Result"},{"role":"assistant","content":"不能在使用 的测试中使用 注解。要断言操作返回 值， 在 值上使用问号运算符。相反，请使用\n```rust\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() -> Result<(), String> {\n        if 2 + 2 == 4 {\n            Ok(())\n        } else {\n            Err(String::from(\"two plus two does not equal four\"))\n        }\n    }\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"9-2、运行测试"},{"role":"assistant","content":"```rust\n$ cargo test -- --test-threads=1\n```\n这里将测试线程设置为 ，告诉程序不要使用任何并行机制。这也会比并行运行花费更多时间，不过在有共享的状态时，测试就不会潜在的相互干扰了。\n```rust\n$ cargo test -- --show-output\n\n```\n如果你希望也能看到通过的测试中打印的值，可以通过在末尾增加 参数来告知 Rust 显示通过测试的输出\n```rust\ncargo test #[test]函数名称\n```\n可以向 传递任意测试的名称来只运行这个测试，这个也可以过滤 名称中携带这个字段的都会进行测试\n```rust\ncargo test -- --ignored\n```\n可以使用 属性来标记耗时的测试并排除他们\n```rust\n#[test]\nfn it_works() {\n    assert_eq!(2 + 2, 4);\n}\n\n#[test]\n#[ignore]\nfn expensive_test() {\n    // 需要运行一个小时的代码\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"9-3-1、单元测试"},{"role":"assistant","content":"测试模块的 标注告诉 Rust 只在执行 时才编译和运行测试代码，而在运行 时不这么做。\n你需要使用 来指定他们不应该被包含进编译结果中\nrust 可以测试私有函数\n```rust\npub fn add_two(a: i32) -> i32 {\n    internal_adder(a, 2)\n}\n\nfn internal_adder(a: i32, b: i32) -> i32 {\n    a + b\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn internal() {\n        assert_eq!(4, internal_adder(2, 2));\n    }\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"9-3-2、集成测试"},{"role":"assistant","content":"为了编写集成测试，需要在项目根目录创建一个 目录，与 同级。Cargo 知道如何去寻找这个目录中的集成测试文件。接着可以随意在这个目录中创建任意多的测试文件，Cargo 会将每一个文件当作单独的 crate 来编译。\n集成测试对于你需要测试的库来说完全是外部的。同其他使用库的代码一样使用库文件，也就是说它们只能调用一部分库中的公有 API 。集成测试的目的是测试库的多个部分能否一起正常工作。一些单独能正确运行的代码单元集成在一起也可能会出现问题，所以集成测试的覆盖率也是很重要的。\n```rust\nuse adder;\n\n#[test]\nfn it_adds_two() {\n    assert_eq!(4, adder::add_two(2));\n}\n```\n如果我们可以创建 一个 文件并创建一个名叫 的函数，我们希望这个函数能被多个测试文件的测试函数调用\n```rust\npub fn setup() {\n    // 编写特定库测试所需的代码\n}\n\n```\n为了不让 出现在测试输出中，我们将创建 ，而不是创建 。这是一种 Rust 的命名规范，这样命名告诉 Rust 不要将 看作一个集成测试文件。将 函数代码移动到 并删除 文件之后，测试输出中将不会出现这一部分。 目录中的子目录不会被作为单独的 crate 编译或作为一个测试结果部分出现在测试输出中。\n一旦拥有了 ，就可以将其作为模块以便在任何集成测试文件中使用。这里是一个 中调用 函数的 测试的例子：\n```rust\nuse adder;\n\nmod common;\n\n#[test]\nfn it_adds_two() {\n    common::setup();\n    assert_eq!(4, adder::add_two(2));\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"10-1-1、使用闭包存储结果"},{"role":"assistant","content":"```rust\nlet expensive_closure = |num| {\n    println!(\"calculating slowly...\");\n    thread::sleep(Duration::from_secs(2));\n    num\n};\n   println!(\"today,do{}pushups!\", res.value(4));\n    println!(\"Next, do {} situps!\", res.value(3));\n```\n闭包不要求像 函数那样在参数和返回值上注明类型。函数中需要类型标注是因为他们是暴露给用户的显式接口的一部分。严格的定义这些接口对于保证所有人都认同函数使用和返回值的类型来说是很重要的。但是闭包并不用于这样暴露在外的接口：他们储存在变量中并被使用，不用命名他们或暴露给库的用户调用。\n闭包通常很短，并只关联于小范围的上下文而非任意情境。\n如果尝试调用闭包两次，第一次使用 类型作为参数而第二次使用 ，则会得到一个错误：\n```rust\nlet example_closure = |x| x;\n\nlet s = example_closure(String::from(\"hello\"));\nlet n = example_closure(5);\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"10-1-2、cacher单例模式"},{"role":"assistant","content":"```rust{\nimpl<T> Cacher<T>\n    where T: Fn(u32) -> u32\n{\n    fn new(calculation: T) -> Cacher<T> {\n        Cacher {\n            calculation,\n            value: None,\n        }\n    }\n\n    fn value(&mut self, arg: u32) -> u32 {\n        match self.value {\n            Some(v) => v,\n            None => {\n                let v = (self.calculation)(arg);\n                self.value = Some(v);\n                v\n            },\n        }\n    }\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"10-1-3、闭包与环境"},{"role":"assistant","content":"闭包从环境中捕获一个值，闭包会在闭包体中储存这个值以供使用\n```rust\nfn main() {\n    let x = 4;\n\n    let equal_to_x = |z| z == x;\n\n    let y = 4;\n\n    assert!(equal_to_x(y));\n}\n```\n以下不能编译，因为作用域的生命周期中没有x\n```rust\nfn main() {\n    let x = 4;\n\n    fn equal_to_x(z: i32) -> bool { z == x }\n\n    let y = 4;\n\n    assert!(equal_to_x(y));\n}\n```\n闭包可以通过三种方式捕获其环境，他们直接对应函数的三种获取参数的方式：获取所有权，可变借用和不可变借用。这三种捕获值的方式被编码为如下三个 trait：\nRust 根据其如何使用环境中变量来推断我们希望如何引用环境。由于所有闭包都可以被调用至少一次，所以所有闭包都实现了 。那些并没有移动被捕获变量的所有权到闭包内的闭包也实现了 ，而不需要对被捕获的变量进行可变访问的闭包则也实现了"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"10-2-1、Iterator trait 和 next 方法"},{"role":"assistant","content":"trait 是类型规范 impl trait for struct 可以理解成extends trait的类型\n```rust\npub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n\n    // 此处省略了方法的默认实现\n}\n```\n是 实现者被要求定义的唯一方法。 一次返回迭代器中的一个项，封装在 中，当迭代器结束时，它返回 。\n```rust\n#[test]\nfn iterator_demonstration() {\n    let v1 = vec![1, 2, 3];\n\n    let mut v1_iter = v1.iter();\n\n    assert_eq!(v1_iter.next(), Some(&1));\n    assert_eq!(v1_iter.next(), Some(&2));\n    assert_eq!(v1_iter.next(), Some(&3));\n    assert_eq!(v1_iter.next(), None);\n}\n```\n这些调用 方法的方法被称为 （ ），因为调用他们会消费迭代器。一个消费适配器的例子是 方法。这个方法获取迭代器的所有权并反复调用 来遍历迭代器，因而会消费迭代器"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"10-2-2、迭代器方法"},{"role":"assistant","content":"trait 中定义了另一类方法，被称为 （ ），他们允许我们将当前迭代器变为不同类型的迭代器。可以链式调用多个迭代器适配器。不过因为所有的迭代器都是惰性的，必须调用一个消费适配器方法以便获取迭代器适配器调用的结果。\n```rust\nlet v1: Vec<i32> = vec![1, 2, 3];\n\nlet v2: Vec<_> = v1.iter().map(|x| x + 1).collect();\n\nassert_eq!(v2, vec![2, 3, 4]);\n```\n可以将任何可迭代的东西变成一个相关的集合。 这是在各种上下文中使用的标准库中功能更强大的方法之一。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"10-2-3、闭包获取环境"},{"role":"assistant","content":"```rust\n\n#[derive(PartialEq, Debug)]\nstruct Shoe {\n    size: u32,\n    style: String,\n}\n\nfn shoes_in_my_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {\n    shoes.into_iter()\n        .filter(|s| s.size == shoe_size)\n        .collect()\n}\n\n#[test]\nfn filters_by_size() {\n    let shoes = vec![\n        Shoe { size: 10, style: String::from(\"sneaker\") },\n        Shoe { size: 13, style: String::from(\"sandal\") },\n        Shoe { size: 10, style: String::from(\"boot\") },\n    ];\n\n    let in_my_size = shoes_in_my_size(shoes, 10);\n\n    assert_eq!(\n        in_my_size,\n        vec![\n            Shoe { size: 10, style: String::from(\"sneaker\") },\n            Shoe { size: 10, style: String::from(\"boot\") },\n        ]\n    );\n}\n```\n如果是函数的话，需要规定其生命周期，shoe_size的生命周期和筛选的生命周期不一致"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"10-2-4、自定义迭代器"},{"role":"assistant","content":"```rust\n\nstruct Counter {\n    count: u32,\n}\n\nimpl Counter {\n    fn new() -> Counter {\n        Counter { count: 0 }\n    }\n}\nimpl Iterator for Counter {\n    type Item = u32;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.count += 1;\n\n        if self.count < 6 {\n            Some(self.count)\n        } else {\n            None\n        }\n    }\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"11-1、Box"},{"role":"assistant","content":"box 允许你将一个值放在堆上而不是栈上。留在栈上的则是指向堆数据的指针。\n使用场景"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"11-1-1、Box存储"},{"role":"assistant","content":"```rust\nfn main() {\n    let b = Box::new(5);\n    println!(\"b = {}\", b);\n}\n```\n其值是一个指向被分配在堆上的值 的 。这个程序会打印出 ；"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"11-1-2、Box递归类型"},{"role":"assistant","content":"```rust\nenum List{\n    Cons(i32, Box<List>),\n    Nil,\n}\nuse crate::List::{Cons, Nil};\nfn main() {\n    let list = Cons(1,\n        Box::new(Cons(2,\n            Box::new(Cons(3,\n                Box::new(Nil))))));\n}\n```\n因为 是一个指针，我们总是知道它需要多少空间：指针的大小并不会根据其指向的数据量而改变。\n现在实现这个概念的方式更像是一个项挨着另一项，而不是一项包含另一项。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"11-2、Deref智能指针"},{"role":"assistant","content":"实现 trait 允许我们重载"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"11-2-1、解引用"},{"role":"assistant","content":"```rust\nfn main() {\n    let x = 5;\n    let y = &x;\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n```\n一旦解引用了 ，就可以访问 所指向的整型值并可以与 做比较\n11-2-2、deref的trait\n```rust\nuse std::ops::Deref;\n\n\nimpl<T> Deref for MyBox<T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        &self.0\n    }\n}\n```\n没有 trait 的话，编译器只会把 引用类型解引用。 方法向编译器提供了一种能力：能够获取任何实现了 trait 的类型的值，并且可以通过调用这个类型的 方法来获取一个解引用方法已知的 引用。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"11-2-3、解引用转换规则"},{"role":"assistant","content":"类似于使用 trait 重载不可变引用的 运算符，Rust 提供了 trait 用于重载可变引用的 运算符。\nRust 在发现类型和 trait 的实现满足以下三种情况时会进行解引用强制转换：\n前两种情况除了可变性之外是相同的：第一种情况表明如果有一个 ，而 实现了返回 类型的 ，则可以直接得到 。第二种情况表明对于可变引用也有着相同的行为。\n第三种情况有些微妙：Rust 也会将可变引用强转为不可变引用，但是反之是 的，因为不可变引用永远也不能强转为可变引用。因为根据借用规则，如果有一个可变引用，其必须是这些数据的唯一引用（否则程序将无法编译）。将一个可变引用转换为不可变引用永远也不会打破借用规则。将不可变引用转换为可变引用则需要数据只能有一个不可变引用，而借用规则无法保证这一点。因此，Rust 无法假设将不可变引用转换为可变引用是可能的。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"11-2-4、解引用转换"},{"role":"assistant","content":"```rust\nuse std::ops::Deref;\nimpl<T> Deref for MyBox<T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        &self.0\n    }\n}\nfn hello(name: &str) {\n    println!(\"Hello, {}!\", name);\n}\nfn main() {\n    let m = MyBox::new(String::from(\"Rust\"));\n    hello(&(*m)[..]);\n}\n```\n&因为切片需要显示书写\nmyBox实现了Deref的trait，这个里面对Box 进行解引用,解引用得到String，可以对string进行操作，如果没有这个智能指针，则接出来的是MyBox"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"11-3、Drop"},{"role":"assistant","content":"我们在智能指针上下文中讨论 是因为其功能几乎总是用于实现智能指针。例如， 自定义了 用来释放 box 所指向的堆空间。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"11-3-1、std::mem::drop"},{"role":"assistant","content":"```RUST\nuse std::mem::drop\nfn main() {\n    let c = CustomSmartPointer { data: String::from(\"some data\") };\n    println!(\"CustomSmartPointer created.\");\n    drop(c);\n    println!(\"CustomSmartPointer dropped before the end of main.\");\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"11-4、Rc"},{"role":"assistant","content":"的类型。其名称为\n注意 只能用于单线程场景；"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"11-4-1、Rc共享数据"},{"role":"assistant","content":"每次调用 ， 中数据的引用计数都会增加，直到有零个引用之前其数据都不会被清理。\n```rust\nenum List {\n    Cons(i32, Rc<List>),\n    Nil,\n}\nuse crate::List::{Cons, Nil};\nuse std::rc::Rc;\n\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n    let b = Cons(3, Rc::clone(&a));\n    let c = Cons(4, Rc::clone(&a));\n}\n```\n在程序中每个引用计数变化的点，会打印出引用计数，其值可以通过调用 函数获得。\n```rust\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n    println!(\"count after creating a = {}\", Rc::strong_count(&a));\n    let b = Cons(3, Rc::clone(&a));\n    println!(\"count after creating b = {}\", Rc::strong_count(&a));\n    {\n        let c = Cons(4, Rc::clone(&a));\n        println!(\"count after creating c = {}\", Rc::strong_count(&a));\n    }\n    println!(\"count after c goes out of scope = {}\", Rc::strong_count(&a));\n}\n```\n允许在程序的多个部分之间只读地共享数据, trait 的实现当 值离开作用域时自动减少引用计数。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"11-5-1、RefCell和内部可变模式"},{"role":"assistant","content":"代表其数据的唯一的所有权,\n类似于 ， 只能用于单线程场景。如果尝试在多线程上下文中使用 ，会得到一个编译错误。第 16 章会介绍如何在多线程程序中使用 的功能。\n如下为选择 ， 或 的理由："}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"11-5-2、refcell用于进行可变借用"},{"role":"assistant","content":"```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    struct MockMessenger {\n   //     sent_messages: Vec<String>,//2、因为&self并不是可变\n        //3、进行refcell借用\n           sent_messages: RefCell<Vec<String>>,\n        \n    }\n\n    impl MockMessenger {\n        fn new() -> MockMessenger {\n            MockMessenger { sent_messages: vec![] }\n        }\n    }\n\n    impl Messenger for MockMessenger {\n        fn send(&self, message: &str) {\n     //1、self只是借用无法进行可变            self.sent_messages.push(String::from(message));\n            //4、可以使用borrow_mut进行修改\n             self.sent_messages.borrow_mut().push(String::from(message));\n          \n        }\n    }\n\n    #[test]\n    fn it_sends_an_over_75_percent_warning_message() {\n        let mock_messenger = MockMessenger::new();\n        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);\n\n        limit_tracker.set_value(80);\n\n        assert_eq!(mock_messenger.sent_messages.len(), 1);\n    }\n}\n```\n方法返回 类型的智能指针， 方法返回 类型的智能指针。这两个类型都实现了 。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"11-5-3、*Rc和RefCell可以拥有多个可变数据所有者"},{"role":"assistant","content":"Rc是不允许可变的,它可以让数据有多个指针，可以进行共享，，理解为一个电视机多个人看\n```RUST\n#[derive(Debug)]\nenum List {\n    Cons(Rc<RefCell<i32>>, Rc<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nfn main() {\n    let value = Rc::new(RefCell::new(5));\n\n    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));\n\n    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&a));\n    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&a));\n//此处 对所有使用value的值进行处理 对所有的value值+10，a是value的值\n    *value.borrow_mut() += 10;\n\n    println!(\"a after = {:?}\", a);15，nil\n    println!(\"b after = {:?}\", b);6,15\n    println!(\"c after = {:?}\", c);10,15\n}\n```\nRefCell用于此处是用来进行可变处理的，"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"11-6、循环引用"},{"role":"assistant","content":"```rust\nuse std::rc::Rc;\nuse std::cell::RefCell;\nuse crate::List::{Cons, Nil};\n\n#[derive(Debug)]\nenum List {\n    Cons(i32, RefCell<Rc<List>>),\n    Nil,\n}\n\nimpl List {\n    fn tail(&self) -> Option<&RefCell<Rc<List>>> {\n        match self {\n            Cons(_, item) => Some(item),\n            Nil => None,\n        }\n    }\n}\nfn main() {\n    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));\n\n    println!(\"a initial rc count = {}\", Rc::strong_count(&a));\n    println!(\"a next item = {:?}\", a.tail());\n\n    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));\n\n    println!(\"a rc count after b creation = {}\", Rc::strong_count(&a));\n    println!(\"b initial rc count = {}\", Rc::strong_count(&b));\n    println!(\"b next item = {:?}\", b.tail());\n\n    if let Some(link) = a.tail() {\n        //将其Cons中的第二位RefCell的值就是a的RefCell::new(Rc::new(Nil))  但b里面又有a所以循环引用了\n        *link.borrow_mut() = Rc::clone(&b);\n    }\n\n    println!(\"b rc count after changing a = {}\", Rc::strong_count(&b));\n    println!(\"a rc count after changing a = {}\", Rc::strong_count(&a));\n\n    // Uncomment the next line to see that we have a cycle;\n    // it will overflow the stack\n    // println!(\"a next item = {:?}\", a.tail());\n}\n```\n避免循环引用"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"11-6、weak"},{"role":"assistant","content":"```rust\nuse std::rc::{Rc, Weak};\nuse std::cell::RefCell;\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell<Weak<Node>>,\n    children: RefCell<Vec<Rc<Node>>>,\n}\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n\n    let branch = Rc::new(Node {\n        value: 5,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![Rc::clone(&leaf)]),\n    });\n//调用 Rc::downgrade 时会得到 Weak<T> 类型的智能指针\n    //强引用代表如何共享 Rc<T> 实例的所有权，但弱引用并不属于所有权关系。他们不会造成引用循环，因为任何弱引用的循环会在其相关的强引用计数为 0 时被打断。\n    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n}\n```\n结果\n```rust\nleaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },\nchildren: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },\nchildren: RefCell { value: [] } }] } })\n```\n的强引用计数减少为 0，所以其 被丢弃。来自 的弱引用计数 1 与 是否被丢弃无关，所以并没有产生任何内存泄漏！"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"12-1-1、spawn新线程"},{"role":"assistant","content":"```rust\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {} from the spawned thread!\", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    for i in 1..5 {\n        println!(\"hi number {} from the main thread!\", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n}\n\nhi number 1 from the main thread!\nhi number 1 from the spawned thread!\nhi number 2 from the main thread!\nhi number 2 from the spawned thread!\nhi number 3 from the main thread!\nhi number 3 from the spawned thread!\nhi number 4 from the main thread!\nhi number 4 from the spawned thread!\nhi number 5 from the spawned thread!\n```\n调用强制线程停止执行一小段时间，这会允许其他不同的线程运行。这些线程可能会轮流运行，不过并不保证如此：这依赖操作系统如何调度线程"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"12-1-2、join等待所有线程结束"},{"role":"assistant","content":"线程是异步操作， （ ） 线程意味着阻止该线程执行工作或退出\n```rust\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    println!(\"hello world1\");\n    let handle = thread::spawn(|| {\n        println!(\"hello world2\");\n        for i in 1..10 {\n            println!(\"hi number {} from the spawned thread!\", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n    println!(\"hello world3\");\n    handle.join().unwrap();\n    println!(\"hello world4\");\n    for i in 1..5 {\n        println!(\"hi number {} from the main thread!\", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n}\nhello world1\nhello world3\nhello world2\nhi number 1 from the spawned thread!\nhi number 2 from the spawned thread!\nhi number 3 from the spawned thread!\nhi number 4 from the spawned thread!\nhi number 5 from the spawned thread!\nhi number 6 from the spawned thread!\nhi number 7 from the spawned thread!\nhi number 8 from the spawned thread!\nhi number 9 from the spawned thread!\nhello world4\nhi number 1 from the main thread!\nhi number 2 from the main thread!\nhi number 3 from the main thread!\nhi number 4 from the main thread!\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"12-1-3、move转移所有权"},{"role":"assistant","content":"通过move捕获环境中的所有权并且实现转移，不能在主线程中使用drop清理代码，所有权转移到spawn中了\n```rust\nuse std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];\n\n    let handle = thread::spawn(move || {\n        println!(\"Here's a vector: {:?}\", v);\n    });\n\n    handle.join().unwrap();\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"12-2-1、mpsc::channel"},{"role":"assistant","content":"函数返回一个元组：第一个元素是发送端，而第二个元素是接收端。由于历史原因， 和 通常作为 （ ）和 （ ）的缩写\n```rust\nuse std::thread;\nuse std::sync::mpsc;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from(\"hi\");\n        tx.send(val).unwrap();\n    });\n    let received = rx.recv().unwrap();\n    println!(\"Got: {}\", received);\n}\n```\n函数获取其参数的所有权并移动这个值归接收者所有"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"12-2-2、发送多个值"},{"role":"assistant","content":"```rust\nuse std::thread;\nuse std::sync::mpsc;\nuse std::time::Duration;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"hi\"),\n            String::from(\"from\"),\n            String::from(\"the\"),\n            String::from(\"thread\"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {\n        println!(\"Got: {}\", received);\n    }\n}\n```\n将 当作一个迭代器。对于每一个接收到的值，我们将其打印出来。当通道被关闭时，迭代器也将结束"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"12-2-3、通过克隆创建多个发送者"},{"role":"assistant","content":"```rust\n\nlet (tx, rx) = mpsc::channel();\n\nlet tx1 = tx.clone();\nthread::spawn(move || {\n    let vals = vec![\n        String::from(\"hi\"),\n        String::from(\"from\"),\n        String::from(\"the\"),\n        String::from(\"thread\"),\n    ];\n\n    for val in vals {\n        tx1.send(val).unwrap();\n        thread::sleep(Duration::from_secs(1));\n    }\n});\n\nthread::spawn(move || {\n    let vals = vec![\n        String::from(\"more\"),\n        String::from(\"messages\"),\n        String::from(\"for\"),\n        String::from(\"you\"),\n    ];\n\n    for val in vals {\n        tx.send(val).unwrap();\n        thread::sleep(Duration::from_secs(1));\n    }\n});\n\nfor received in rx {\n    println!(\"Got: {}\", received);\n}\n\nGot: hi\nGot: more\nGot: from\nGot: messages\nGot: for\nGot: the\nGot: thread\nGot: you\n```\n这一次，在创建新线程之前，我们对通道的发送端调用了 方法。这会给我们一个可以传递给第一个新建线程的发送端句柄。我们会将原始的通道发送端传递给第二个新建线程。这样就会有两个线程，每个线程将向通道的接收端发送不同的消息。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"12-3-1、互斥器"},{"role":"assistant","content":"（ ）是 的缩写，也就是说，任意时刻，其只允许一个线程访问某些数据。为了访问互斥器中的数据，线程首先需要通过获取互斥器的 （ ）来表明其希望访问数据。锁是一个作为互斥器一部分的数据结构，它记录谁有数据的排他访问权。因此，我们描述互斥器为通过锁系统 （ ）其数据。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"12-3-2、Mutex的api"},{"role":"assistant","content":"```rust\nuse std::sync::Mutex;\n\nfn main() {\n    let m = Mutex::new(5);\n\n    {\n        let mut num = m.lock().unwrap();\n        *num = 6;\n        //离开此作用域时，lock锁自动释放\n    }\n\n    println!(\"m = {:?}\", m);\n}\n```\n是一个智能指针。更准确的说， 调用 一个叫做 的智能指针。这个智能指针实现了 来指向其内部数据；其也提供了一个 实现当 离开作用域时自动释放锁，这正发生于示例 16-12 内部作用域的结尾。为此，我们不会冒忘记释放锁并阻塞互斥器为其它线程所用的风险，因为锁的释放是自动发生的。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"12-3-3、共享Mutex"},{"role":"assistant","content":"所幸  这么一个类似 并可以安全的用于并发环境的类型。字母 “a” 代表 （ ），所以这是一个 （ ）类型。原子性是另一类这里还未涉及到的并发原语：请查看标准库中 的文档来获取更多细节。其中的要点就是：原子性类型工作起来类似原始类型，不过可以安全的在线程间共享。\n```rust\nuse std::sync::{Mutex, Arc};\nuse std::thread;\n\nfn main() {\n    //问题，多个线程中move会多次获取counter的所有权我们该怎么解决\n    //方案一 使用Rc获取多个所有权，但每次使用需要使用Rc.clone()对其进行计数，无法实现，此方案不可行\n    //方案二 使用Arc进行原子引用计数\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Arc::clone(&counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"12-3-4、RefCell/Rc与Mutex/Arc的相似性"},{"role":"assistant","content":"使用 可以改变 中的内容那样，同样的可以使用 来改变 中的内容\n提供了内部可变性;\n都是通过先引用计数再获取其所有权\n```RUST\n let receiver = Arc::new(Mutex::new(receiver));\n let value = Rc::new(RefCell::new(5));\n```\n这时两个 值相互引用，造成内存泄漏。同理， 也有造成 （ ） 的风险。这发生于当一个操作需要锁住两个资源而两个线程各持一个锁，这会造成它们永远相互等待。如果你对这个主题感兴趣，尝试编写一个带有死锁的 Rust 程序，接着研究任何其他语言中使用互斥器的死锁规避策略并尝试在 Rust 中实现他们。标准库中 和 的 API 文档会提供有用的信息。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"13-1、特点"},{"role":"assistant","content":"另一个通常与面向对象编程相关的方面是 （ ）的思想：对象的实现细节不能被使用对象的代码获取到。所以唯一与对象交互的方式是通过对象提供的公有 API；使用对象的代码无法深入到对象内部并直接改变数据或者行为。封装使得改变和重构对象的内部时无需改变使用对象的代码。\n（ ）是一个很多编程语言都提供的机制，一个对象可以定义为继承另一个对象的定义，这使其可以获得父对象的数据和行为，而无需重新定义。\nRust 代码可以使用默认 trait 方法实现来进行共享\n表现为子类型可以用于父类型被使用的地方。这也被称为 （ ），这意味着如果多种对象共享特定的属性，则可以相互替代使用。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"13-2-1、trait的实现"},{"role":"assistant","content":"我们通过指定某种指针来创建 trait 对象，例如 引用或 智能指针，还有 keyword\n```rust\npub trait Draw {\n    fn draw(&self);\n}\npub struct Screen {\n    pub components: Vec<Box<dyn Draw>>,\n}\nimpl Screen {\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\n//泛型类型参数一次只能替代一个具体类型，而 trait 对象则允许在运行时替代多种具体类型。\n//使用bound\n//我在库里调用他只会认出一种类型参数传进去 需要多种类型传入的情况无法使用\npub struct Screen<T: Draw> {\n    pub components: Vec<T>,\n}\n\nimpl<T> Screen<T>\n    where T: Draw {\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\n```\n```rust\nuse gui::{Screen, Button};\n\nfn main() {\n    let screen = Screen {\n        components: vec![\n            Box::new(SelectBox {\n                width: 75,\n                height: 10,\n                options: vec![\n                    String::from(\"Yes\"),\n                    String::from(\"Maybe\"),\n                    String::from(\"No\")\n                ],\n            }),\n            Box::new(Button {\n                width: 50,\n                height: 10,\n                label: String::from(\"OK\"),\n            }),\n        ],\n    };\n\n    screen.run();\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"13-2-2、trait要求对象安全"},{"role":"assistant","content":"```rust\npub struct Screen {\n    pub components: Vec<Box<dyn Clone>>,\n}\n```\n例如，如果尝试实现示例 17-4 中的 结构体来存放实现了 trait 而不是 trait 的类型\n```rust\nerror[E0038]: the trait `std::clone::Clone` cannot be made into an object\n --> src/lib.rs:2:5\n  |\n2 |     pub components: Vec<Box<dyn Clone>>,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone`\n  cannot be made into an object\n  |\n  = note: the trait cannot require that `Self : Sized`\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"14-1-1、match"},{"role":"assistant","content":"表达式必须是 （ ）的，意为 表达式所有可能的值都必须被考虑到。\n```rust\nmatch VALUE {\n    PATTERN => EXPRESSION,\n    PATTERN => EXPRESSION,\n    PATTERN => EXPRESSION,\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"14-1-2、if let条件表达式"},{"role":"assistant","content":"```rust\nfn main() {\n    let favorite_color: Option<&str> = None;\n    let is_tuesday = false;\n    let age: Result<u8, _> = \"34\".parse();\n\n    if let Some(color) = favorite_color {\n        println!(\"Using your favorite color, {}, as the background\", color);\n    } else if is_tuesday {\n        println!(\"Tuesday is green day!\");\n    } else if let Ok(age) = age {\n        if age > 30 {\n         // 打印此代码\n            println!(\"Using purple as the background color\");\n         \n        } else {\n            println!(\"Using orange as the background color\");\n            \n        }\n    } else {\n        println!(\"Using blue as the background color\");\n    }\n}\n```\n表达式的缺点在于其穷尽性没有为编译器所检查，而 表达式则检查了。如果去掉最后的 块而遗漏处理一些情况，编译器也不会警告这类可能的逻辑错误。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"14-1-3、while let 条件循环"},{"role":"assistant","content":"一个与 结构类似的是 条件循环，它允许只要模式匹配就一直进行 循环\n```rust\nlet mut stack = Vec::new();\n\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\nwhile let Some(top) = stack.pop() {\n    println!(\"{}\", top);\n}\n```\n这个例子会打印出 3、2 接着是 1。 方法取出 vector 的最后一个元素并返回 。如果 vector 是空的，它返回 。 循环只要 返回 就会一直运行其块中的代码。一旦其返回 ， 循环停止。我们可以使用 来弹出栈中的每一个元素。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"14-1-4、for循环"},{"role":"assistant","content":"```rust\nlet v = vec!['a', 'b', 'c'];\n\nfor (index, value) in v.iter().enumerate() {\n    println!(\"{} is at index {}\", value, index);\n}\n```\n这里使用 方法适配一个迭代器来产生一个值和其在迭代器中的索引，他们位于一个元组中。第一个 调用会产生元组 。当这个值匹配模式 ， 将会是 0 而 将会是 ，并打印出第一行输出。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"14-1-5、let语句"},{"role":"assistant","content":"```rust\nlet PATTERN = EXPRESSION;\n```\nlet本身就是一种模式匹配,进行解构的同时更为明显\n```rust\nlet (x, y, z) = (1, 2, 3);\n```\n这里将一个元组与模式匹配。Rust 会比较值 与模式 并发现此值匹配这个模式。在这个例子中，将会把 绑定到 ， 绑定到 并将 绑定到 。你可以将这个元组模式看作是将三个独立的变量模式结合在一起。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"14-1-6、函数参数"},{"role":"assistant","content":"函数参数也是一个模式匹配\n```rust\nfn print_coordinates(&(x, y): &(i32, i32)) {\n    println!(\"Current location: ({}, {})\", x, y);\n}\n\nfn main() {\n    let point = (3, 5);\n    print_coordinates(&point);\n}\n```\n这会打印出 。值 会匹配模式 ，如此 得到了值 ，而 得到了值 。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"14-2、refutability可反驳性"},{"role":"assistant","content":"irrefutable（不可反驳的）:一个例子就是 语句中的 ，因为 可以匹配任何值所以不可能会失败。\nrefutable（可反驳的）:能匹配任何传递的可能值的模式被称为是 （ ）。一个这样的例子便是 表达式中的 ；如果变量 中的值是 而不是 ，那么 模式不能匹配。\n函数参数、 语句和 循环只能接受不可反驳的模式，因为通过不匹配的值程序无法进行有意义的工作。 和 表达式被限制为只能接受可反驳的模式，因为根据定义他们意在处理可能的失败：条件表达式的功能就是根据成功或失败执行不同的操作。\n```rust\nlet Some(x) = some_option_value;\n//修正\nif let Some(x) = some_option_value {\n    println!(\"{}\", x);\n}\n```\n若 的值是 ，则不会成功匹配模式 ，表明这个模式是可反驳的。然而 语句只能接受不可反驳模式，因为代码不能通过 值进行有效的操作。Rust 会在编译时抱怨我们尝试在要求不可反驳模式的地方使用可反驳模式：\n```rust\nerror[E0005]: refutable pattern in local binding: `None` not covered\n -->\n  |\n3 | let Some(x) = some_option_value;\n  |     ^^^^^^^ pattern `None` not covered\n```\n我们给了代码一个得以继续的出路！这段代码完全有效，尽管这意味着我们不能在避免产生警告的情况下使用无可辩驳的模式。如果为 提供了一个总是会匹配的模式，比如示例 18-10 中的 ，编译器会给出一个警告。\n```rust\nif let x = 5 {\n    println!(\"{}\", x);\n};\nwarning: irrefutable if-let pattern\n --> <anon>:2:5\n  |\n2 | /     if let x = 5 {\n3 | |     println!(\"{}\", x);\n4 | | };\n  | |_^\n  |\n  = note: #[warn(irrefutable_let_patterns)] on by default\n```\n基于此， 匹配分支必须使用可反驳模式，除了最后一个分支需要使用能匹配任何剩余值的不可反驳模式。Rust 允许我们在只有一个匹配分支的 中使用不可反驳模式，不过这么做不是特别有用，并可以被更简单的 语句替代。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"14-3-1、匹配命名变量"},{"role":"assistant","content":"```rust\nfn main() {\n    let x = Some(5);\n    let y = 10;\n\n    match x {\n        Some(50) => println!(\"Got 50\"),\n        Some(y) => println!(\"Matched, y = {:?}\", y),//5\n        _ => println!(\"Default case, x = {:?}\", x),\n    }\n\n    println!(\"at the end: x = {:?}, y = {:?}\", x, y);//Some(5),10\n}\n```\n让我们看看当 语句运行的时候发生了什么。第一个匹配分支的模式并不匹配 中定义的值，所以代码继续执行。\n第二个匹配分支中的模式引入了一个新变量 ，它会匹配任何 中的值。因为我们在 表达式的新作用域中，这是一个新变量，而不是开头声明为值 10 的那个 。这个新的 绑定会匹配任何 中的值，在这里是 中的值。因此这个 绑定了 中 内部的值。这个值是 5，所以这个分支的表达式将会执行并打印出 。\n如果 的值是 而不是 ，头两个分支的模式不会匹配，所以会匹配下划线。这个分支的模式中没有引入变量 ，所以此时表达式中的 会是外部没有被覆盖的 。在这个假想的例子中， 将会打印 。\n一旦 表达式执行完毕，其作用域也就结束了，同理内部 的作用域也结束了。最后的 会打印 。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"14-3-2、多个模式"},{"role":"assistant","content":"在 表达式中，可以使用 语法匹配多个模式，它代表 （ ）的意思。例如，如下代码将 的值与匹配分支相比较，第一个分支有 选项，意味着如果 的值匹配此分支的任一个值，它就会运行：\n```rust\n\nlet x = 1;\n\nmatch x {\n    1 | 2 => println!(\"one or two\"),\n    3 => println!(\"three\"),\n    _ => println!(\"anything\"),\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"14-3-3、通过..=匹配值的范围"},{"role":"assistant","content":"如果 是 1、2、3、4 或 5，第一个分支就会匹配。这相比使用 运算符表达相同的意思更为方便；相比 ，使用 则不得不指定 。相反指定范围就简短的多，特别是在希望匹配比如从 1 到 1000 的数字的时候！\n```rust\nlet x = 5;\n\nmatch x {\n    1..=5 => println!(\"one through five\"),\n    _ => println!(\"something else\"),\n}\n```\n如下是一个使用 类型值范围的例子：\n```\nlet x = 'c';\n\nmatch x {\n    'a'..='j' => println!(\"early ASCII letter\"),\n    'k'..='z' => println!(\"late ASCII letter\"),\n    _ => println!(\"something else\"),\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"14-3-4、解构并分解值"},{"role":"assistant","content":"也可以使用模式来解构结构体、枚举、元组和引用，以便使用这些值的不同部分。让我们来分别看一看。\n```rust\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    let Point { x: a, y: b } = p;\n    assert_eq!(0, a);\n    assert_eq!(7, b);\n}\n```\n这段代码创建了变量 和 来匹配结构体 中的 和 字段。\n```rust\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    match p {\n        Point { x, y: 0 } => println!(\"On the x axis at {}\", x),\n        Point { x: 0, y } => println!(\"On the y axis at {}\", y),\n        Point { x, y } => println!(\"On neither axis: ({}, {})\", x, y),\n    }\n}\n//实际上是模式进行匹配，匹配成功的才会拿到y,拿不到x，x他不是为止值解构\n```\n第一个分支通过指定字段 匹配字面量 来匹配任何位于 轴上的点。此模式仍然创建了变量 以便在分支的代码中使用。\n类似的，第二个分支通过指定字段 匹配字面量 来匹配任何位于 轴上的点，并为字段 创建了变量 。第三个分支没有指定任何字面量，所以其会匹配任何其他的 并为 和 两个字段创建变量。\n在这个例子中，值 因为其 包含 0 而匹配第二个分支，因此会打印出 。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"14-3-5、解构枚举"},{"role":"assistant","content":"```rust\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\nfn main() {\n    let msg = Message::ChangeColor(0, 160, 255);\n\n    match msg {\n        Message::Quit => {\n            println!(\"The Quit variant has no data to destructure.\")\n        }\n        Message::Move { x, y } => {\n            println!(\n                \"Move in the x direction {} and in the y direction {}\",\n                x,\n                y\n            );\n        }\n        Message::Write(text) => println!(\"Text message: {}\", text),\n        Message::ChangeColor(r, g, b) => {\n            println!(\n                \"Change the color to red {}, green {}, and blue {}\",\n                r,\n                g,\n                b\n            )\n        }\n    }\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"14-3-6、解构嵌套的结构体和枚举"},{"role":"assistant","content":"```rust\nenum Color {\n   Rgb(i32, i32, i32),\n   Hsv(i32, i32, i32),\n}\n\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(Color),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));\n\n    match msg {\n        Message::ChangeColor(Color::Rgb(r, g, b)) => {\n            println!(\n                \"Change the color to red {}, green {}, and blue {}\",\n                r,\n                g,\n                b\n            )\n        }\n        Message::ChangeColor(Color::Hsv(h, s, v)) => {\n            println!(\n                \"Change the color to hue {}, saturation {}, and value {}\",\n                h,\n                s,\n                v\n            )\n        }\n        _ => ()\n    }\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"14-3-7、解构结构体和元组"},{"role":"assistant","content":"```rust\nlet ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"14-3-8、忽略"},{"role":"assistant","content":"有时忽略模式中的一些值是有用的，比如 中最后捕获全部情况的分支实际上没有做任何事，但是它确实对所有剩余情况负责。有一些简单的方法可以忽略模式中全部或部分值：使用 模式（我们已经见过了），在另一个模式中使用 模式，使用一个以下划线开始的名称，或者使用 忽略所剩部分的值。让我们来分别探索如何以及为什么要这么做。\n函数\n```rust\nfn foo(_: i32, y: i32) {\n    println!(\"This code only uses the y parameter: {}\", y);\n}\n\nfn main() {\n    foo(3, 4);\n}\n```\n嵌套\n```rust\nlet mut setting_value = Some(5);\nlet new_setting_value = Some(10);\n\nmatch (setting_value, new_setting_value) {\n    (Some(_), Some(_)) => {\n        println!(\"Can't overwrite an existing customized value\");\n    }\n    _ => {\n        setting_value = new_setting_value;\n    }\n}\n\nprintln!(\"setting is {:?}\", setting_value);\n```\n这段代码会打印出 接着是\n测试 和 都为 成员的情况,如果有值不为Some才会调用下面的赋值\n元组\n```rust\nlet numbers = (2, 4, 8, 16, 32);\n\nmatch numbers {\n    (first, _, third, _, fifth) => {\n        println!(\"Some numbers: {}, {}, {}\", first, third, fifth)\n    },\n}\n```\n忽略未使用变量\n```rust\nfn main() {\n    let _x = 5;\n    let y = 10;\n\n\nlet s = Some(String::from(\"Hello!\"));\n//if let Some(_s) = s 使用_s会报错\nif let Some(_) = s {\n    println!(\"found a string\");\n}\n\nprintln!(\"{:?}\", s);\n}\n```\n因为 的值仍然会移动进 ，并阻止我们再次使用 。然而只使用下划线本身，并不会绑定值。示例 18-22 能够无错编译，因为 没有被移动进\n用..忽略剩余值\n```rust\nstruct Point {\n    x: i32,\n    y: i32,\n    z: i32,\n}\n\nlet origin = Point { x: 0, y: 0, z: 0 };\n\nmatch origin {\n    Point { x, .. } => println!(\"x is {}\", x),\n}\n```\n只操作 坐标并忽略 和 字段的值\n元组..忽略\n```rust\nfn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (first, .., last) => {\n            println!(\"Some numbers: {}, {}\", first, last);\n        },\n    }\n}\n```\n必须是无歧义的。如果期望匹配和忽略的值是不明确的，Rust 会报错\n```rust\nfn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (.., second, ..) => {\n            println!(\"Some numbers: {}\", second)\n        },\n    }\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"14-3-9、匹配守卫"},{"role":"assistant","content":"（ ）是一个指定于 分支模式之后的额外 条件，它也必须被满足才能选择此分支。匹配守卫用于表达比单独的模式所能允许的更为复杂的情况。\n```rust\nlet num = Some(4);\n\nmatch num {\n    Some(x) if x < 5 => println!(\"less than five: {}\", x),\n    Some(x) => println!(\"{}\", x),\n    None => (),\n}\n```\n现在这会打印出 。现在第二个匹配分支中的模式不会引入一个覆盖外部 的新变量 ，这意味着可以在匹配守卫中使用外部的 。相比指定会覆盖外部 的模式 ，这里指定为 。此新建的变量 并没有覆盖任何值，因为 外部没有变量 。\n```rust\nfn main() {\n    let x = Some(5);\n    let y = 10;\n\n    match x {\n        Some(50) => println!(\"Got 50\"),\n        Some(n) if n == y => println!(\"Matched, n = {}\", n),\n        _ => println!(\"Default case, x = {:?}\", x),\n    }\n\n    println!(\"at the end: x = {:?}, y = {}\", x, y);\n}\n```\n也可以在匹配守卫中使用 运算符 来指定多个模式，同时匹配守卫的条件会作用于所有的模式\n```rust\n\nlet x = 4;\nlet y = false;\n\nmatch x {\n    4 | 5 | 6 if y => println!(\"yes\"),\n    _ => println!(\"no\"),\n}\n//优先级\n(4 | 5 | 6) if y => ...\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"14-3-10、@绑定"},{"role":"assistant","content":"运算符（ ）允许我们在创建一个存放值的变量的同时测试其值是否匹配模式。\n```rust\nenum Message {\n    Hello { id: i32 },\n}\n\nlet msg = Message::Hello { id: 5 };\n\nmatch msg {\n    Message::Hello { id: id_variable @ 3..=7 } => {\n        println!(\"Found an id in range: {}\", id_variable)\n    },\n    Message::Hello { id: 10..=12 } => {\n        println!(\"Found an id in another range\")\n    },\n    Message::Hello { id } => {\n        println!(\"Found some other id: {}\", id)\n    },\n}\n```\n使用 可以在一个模式中同时测试和保存变量值。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-1、不安全的rust"},{"role":"assistant","content":"Rust 还隐藏有第二种语言，它不会强制执行这类内存安全保证：这被称为 （ ）。它与常规 Rust 代码无异，但是会提供额外的超能力。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-1-1、unsafe"},{"role":"assistant","content":"有五类可以在不安全 Rust 中进行而不能用于安全 Rust 的操作，它们称之为 “不安全的超能力。\n这五类操作必须位于标记为 的块中，就能够知道任何与内存安全相关的错误必定位于 块内。保持 块尽可能小"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-1-2、解引用指针"},{"role":"assistant","content":"裸指针与引用和智能指针的区别在于：\n同时创建不可变和可变裸指针\n```rust\n\nlet mut num = 5;\n\nlet r1 = &num as *const i32;\nlet r2 = &mut num as *mut i32;\n```\n可以在安全代码中 裸指针，只是不能在不安全块之外 裸指针\n创建一个指针不会造成任何危险；只有当访问其指向的值时才有可能遇到无效的值。需要在unsafe中调用\n```rust\n\nlet mut num = 5;\n\nlet r1 = &num as *const i32;\nlet r2 = &mut num as *mut i32;\n\nunsafe {\n    println!(\"r1 is: {}\", *r1);\n    println!(\"r2 is: {}\", *r2);\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-1-3、不安全函数或方法"},{"role":"assistant","content":"```rust\n\nlet mut v = vec![1, 2, 3, 4, 5, 6];\n\nlet r = &mut v[..];\n\nlet (a, b) = r.split_at_mut(3);\n\nassert_eq!(a, &mut [1, 2, 3]);\nassert_eq!(b, &mut [4, 5, 6]);\n```\nRust 的借用检查器不能理解我们要借用这个 slice 的两个不同部分：它只知道我们借用了同一个 slice 两次。本质上借用 slice 的不同部分是可以的，因为结果两个 slice 不会重叠，不过 Rust 还没有智能到能够理解这些。当我们知道某些事是可以的而 Rust 不知道的时候，就是触及不安全代码的时候了\n```rust\nuse std::slice;\n\nfn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {\n    let len = slice.len();\n    let ptr = slice.as_mut_ptr();\n\n    assert!(mid <= len);\n\n    unsafe {\n        (slice::from_raw_parts_mut(ptr, mid),\n         slice::from_raw_parts_mut(ptr.add(mid), len - mid))\n    }\n}\n```\n函数是不安全的因为它获取一个裸指针，并必须确信这个指针是有效的。裸指针上的 方法也是不安全的，因为其必须确信此地址偏移量也是有效的指针。因此必须将 和 放入 块中以便能调用它们。通过观察代码，和增加 必然小于等于 的断言"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-1-4、使用exterm调用外部代码"},{"role":"assistant","content":"有时你的 Rust 代码可能需要与其他语言编写的代码交互。为此 Rust 有一个关键字， ，有助于创建和使用 （ ， FFI）。外部函数接口是一个编程语言用以定义函数的方式，其允许不同（外部）编程语言调用这些函数\n```rust\nextern \"C\" {\n    fn abs(input: i32) -> i32;\n}\n\nfn main() {\n    unsafe {\n        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n    }\n}\n```\n在 块中，列出了我们希望能够调用的另一个语言中的外部函数的签名和名称。 部分定义了外部函数所使用的 （ ，ABI） —— ABI 定义了如何在汇编语言层面调用此函数。 ABI 是最常见的，并遵循 C 编程语言的 ABI。\n使用 来创建一个允许其他语言调用 Rust 函数的接口。不同于 块，就在 关键字之前增加 关键字并指定所用到的 ABI。还需增加 标注来告诉 Rust 编译器不要 mangle 此函数的名称。\n```rust\n\n#[no_mangle]\npub extern \"C\" fn call_from_c() {\n    println!(\"Just called a Rust function from C!\");\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-1-5、访问或修改可变静态变量"},{"role":"assistant","content":"```rust\nstatic HELLO_WORLD: &str = \"Hello, world!\";\n\nfn main() {\n    println!(\"name is: {}\", HELLO_WORLD);\n}\n```\n静态变量一般以大写形式书写；\n常量与不可变静态变量可能看起来很类似，不过一个微妙的区别是静态变量中的值有一个固定的内存地址。使用这个值总是会访问相同的地址。另一方面，常量则允许在任何被用到的时候复制其数据。\n常量与静态变量的另一个区别在于静态变量可以是可变的。访问和修改可变静态变量都是 的\n```rust\nstatic mut COUNTER: u32 = 0;\n\nfn add_to_count(inc: u32) {\n    unsafe {\n        COUNTER += inc;\n    }\n}\n\nfn main() {\n    add_to_count(3);\n\n    unsafe {\n        println!(\"COUNTER: {}\", COUNTER);\n    }\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-1-6、不安全trait"},{"role":"assistant","content":"的另一个操作用例是实现不安全 trait。当 trait 中至少有一个方法中包含编译器无法验证的不变式（invariant）时 trait 是不安全的。可以在 之前增加 关键字将 trait 声明为 ，同时 trait 的实现也必须标记为 ，\n```\nunsafe trait Foo {\n    // methods go here\n}\n\nunsafe impl Foo for i32 {\n    // method implementations go here\n}\n```\nRust 不能验证我们的类型保证可以安全的跨线程发送或在多线程间访问，所以需要我们自己进行检查并通过 表明。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-1-7、访问联合体中的字段"},{"role":"assistant","content":"仅适用于 的最后一个操作是访问 中的字段， 和 类似，但是在一个实例中同时只能使用一个声明的字段。联合体主要用于和 C 代码中的联合体交互"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-2-1、关联类型在trait定义中指定占位符类型"},{"role":"assistant","content":"（ ）是一个将类型占位符与 trait 相关联的方式，这样 trait 的方法签名中就可以使用这些占位符类型。\n```rust\npub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n}\n```\n和泛型的区别\n泛型需要在每个实现中标注类型；\n当 trait 有泛型参数时，可以多次实现这个 trait，每次需改变泛型参数的具体类型。接着当使用 的 方法时，必须提供类型标注来表明希望使用 的哪一个实现。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-2-2、运算符重载"},{"role":"assistant","content":"```rust\nuse std::ops::Add;\n\n#[derive(Debug, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, other: Point) -> Point {\n        //Point 结构体上实现 Add trait 来重载 + 运算符，这样就可以将两个 Point 实例相加了\n        Point {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n\nfn main() {\n    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n               Point { x: 3, y: 3 });\n}\n```\ntrait 有一个叫做 的关联类型，它用来决定 方法的返回值类型\n```rust\n\ntrait Add<RHS=Self> {\n    type Output;\n\n    fn add(self, rhs: RHS) -> Self::Output;\n}\n```\n尖括号中的 ：这个语法叫做 （ ）。 是一个泛型类型参数（“right hand side” 的缩写），它用于定义 方法中的 参数。如果实现 trait 时不指定 的具体类型， 的类型将是默认的 类型，也就是在其上实现 的类型\ntrait 时希望自定义 类型而不是使用默认类型的例子\n```rust\nuse std::ops::Add;\n\nstruct Millimeters(u32);\nstruct Meters(u32);\n\nimpl Add<Meters> for Millimeters {\n    type Output = Millimeters;\n\n    fn add(self, other: Meters) -> Millimeters {\n        Millimeters(self.0 + (other.0 * 1000))\n    }\n}\n```\n为了使 和 能够相加，我们指定 来设定 类型参数的值而不是使用默认的 。\n默认参数类型主要用于如下两个方面：\n不能从外部读取类型，这不是动态语言，是静态语言"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-2-3、调用名字相同的方法"},{"role":"assistant","content":"```rust\ntrait Pilot {\n    fn fly(&self);\n}\n\ntrait Wizard {\n    fn fly(&self);\n}\n\nstruct Human;\n\nimpl Pilot for Human {\n    fn fly(&self) {\n        println!(\"This is your captain speaking.\");\n    }\n}\n\nimpl Wizard for Human {\n    fn fly(&self) {\n        println!(\"Up!\");\n    }\n}\n\nimpl Human {\n    fn fly(&self) {\n        println!(\"*waving arms furiously*\");\n    }\n}\n```\n当调用 实例的 时，编译器默认调用直接实现在类型上的方法，如示例 19-17 所示。\n```rust\nfn main() {\n    let person = Human;\n    person.fly();\n}\n```\n为了能够调用 trait 或 trait 的 方法，我们需要使用更明显的语法以便能指定我们指的是哪个 方法。这个语法展示在示例 19-18 中：\n```rust\nfn main() {\n    let person = Human;\n    Pilot::fly(&person);\n    Wizard::fly(&person);\n    person.fly();//也可以选择写成 Human::fly(&person)，这等同于示例 19-18 中的 person.fly()\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-2-4、完全限定语法"},{"role":"assistant","content":"关联函数是 trait 的一部分，但没有 参数。当同一作用域的两个类型实现了同一 trait，Rust 就不能计算出我们期望的是哪一个类型，除非使用 （ ）\n```rust\ntrait Animal {\n    fn baby_name() -> String;\n}\n\nstruct Dog;\n\nimpl Dog {\n    fn baby_name() -> String {\n        String::from(\"Spot\")\n    }\n}\n\nimpl Animal for Dog {\n    fn baby_name() -> String {\n        String::from(\"puppy\")\n    }\n}\n\nfn main() {\n    println!(\"A baby dog is called a {}\", Dog::baby_name());\n    println!(\"A baby dog is called a {}\", <Dog as Animal>::baby_name());\n}\n\n```\ntrait,它有关联函数 ，结构体 实现了 ，同时有关联函数 直接定义于 之上,如果要调用trait重新赋值在Dog上的方法，因为他不是实现对象，所以没有self\n通常，完全限定语法定义为：\n```rust\n<Type as Trait>::function(receiver_if_method, next_arg, ...);\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-2-5、trait中实现另一个trait"},{"role":"assistant","content":"实质：在一个trait上添加另一个trait能使之默认实现,可以理解成继承，不过是添加在父trait上\n有时我们可能会需要某个 trait 使用另一个 trait 的功能。在这种情况下，需要能够依赖相关的 trait 也被实现。这个所需的 trait 是我们实现的 trait 的 （ ）。\n```rust\nuse std::fmt;\n\ntrait OutlinePrint: fmt::Display {\n    fn outline_print(&self) {\n        let output = self.to_string();\n        let len = output.len();\n        println!(\"{}\", \"*\".repeat(len + 4));\n        println!(\"*{}*\", \" \".repeat(len + 2));\n        println!(\"* {} *\", output);\n        println!(\"*{}*\", \" \".repeat(len + 2));\n        println!(\"{}\", \"*\".repeat(len + 4));\n    }\n}\n```\n因为指定了 需要 trait，则可以在 中使用 ， 其会为任何实现 的类型自动实现。如果我们尝试使用 而不添加冒号（ ）并在 trait 名称后面指定 trait，则会得到一个错误说在当前作用域中没有找到用于 类型的方法 。\n```rust\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl OutlinePrint for Point {}\nerror[E0277]: the trait bound `Point: std::fmt::Display` is not satisfied\n  --> src/main.rs:20:6\n   |\n20 | impl OutlinePrint for Point {}\n   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter;\ntry using `:?` instead if you are using a format string\n   |\n   = help: the trait `std::fmt::Display` is not implemented for `Point`\n```\n```rust\nuse std::fmt;\n\nimpl fmt::Display for Point {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"({}, {})\", self.x, self.y)\n    }\n}\nfn main(){\n\tlet point = Point { x: 3, y: 4 };\n    point.outline_print();\n}\n//那么在 Point 上实现 OutlinePrint trait 将能成功编译，并可以在 Point 实例上调用 outline_print 来显示位于星号框中的点的值。\n```\n在 上实现 trait 将能成功编译，并可以在 实例上调用 来显示位于星号框中的点的值"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-2-6、newType"},{"role":"assistant","content":"*如何不用宏来实现打印\n孤儿规则（orphan rule），它说明只要 trait 或类型对于当前 crate 是本地的话就可以在此类型上实现该 trait。一个绕开这个限制的方法是使用 （ ）\n例如，如果想要在 上实现 ，而孤儿规则阻止我们直接这么做，因为 trait 和 都定义于我们的 crate 之外。可以创建一个包含 实例的 结构体，\n```rust\nuse std::fmt;\n//()元组 \nstruct Wrapper(Vec<String>);\n\nimpl fmt::Display for Wrapper {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"[{}]\", self.0.join(\", \"))\n    }\n}\n\nfn main() {\n    let w = Wrapper(vec![String::from(\"hello\"), String::from(\"world\")]);\n    println!(\"w = {}\", w);\n}\n```\n在 上实现 ，而孤儿规则阻止我们直接这么做，因为 trait 和 都定义于我们的 crate 之外。可以创建一个包含 实例的 结构体，接着可以如示例 19-31 那样在 上实现 并使用 的值：\n的实现使用 来访问其内部的 ，因为 是元组结构体而 是结构体总位于索引 0 的项。接着就可以使用 中 的功能了。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-3-1、类型别名"},{"role":"assistant","content":"Rust 还提供了声明 （ ）的能力，使用 关键字来给予现有类型另一个名字\n```rust\n\ntype Kilometers = i32;\n\nlet x: i32 = 5;\nlet y: Kilometers = 5;\n\nprintln!(\"x + y = {}\", x + y);\n```\n类型别名的主要用途是减少重复。例如，可能会有这样很长的类型：\n```rust\n\ntype Thunk = Box<dyn Fn() + Send + 'static>;\n\nlet f: Thunk = Box::new(|| println!(\"hi\"));\n\nfn takes_long_type(f: Thunk) {\n    // --snip--\n}\n\nfn returns_long_type() -> Thunk {\n    // --snip--\n}\n```\n类型别名也经常与 结合使用来减少重复。考虑一下标准库中的 模块。\n```rust\n\ntype Result<T> = std::result::Result<T, std::io::Error>;\npub trait Write {\n    fn write(&mut self, buf: &[u8]) -> Result<usize>;\n    fn flush(&mut self) -> Result<()>;\n\n    fn write_all(&mut self, buf: &[u8]) -> Result<()>;\n    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()>;\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-3-2、never type"},{"role":"assistant","content":"Rust 有一个叫做 的特殊类型。在类型理论术语中，它被称为 ，因为它没有值。我们更倾向于称之为 。这个名字描述了它的作用：在函数从不返回的时候充当返回值。例如：\n```rust\nfn bar() -> ! {\n    // --snip--\n}\n```\nmatch\n忽略了代码中的一些细节, 的分支必须返回相同的类型\n```rust\nlet guess: u32 = match guess.trim().parse() {\n    Ok(num) => num,\n    Err(_) => continue,\n};\n```\n他们需要同一个返回值，前者是 值，而后者是 值。因为 并没有一个值，Rust 决定 的类型是 。所以在 的情况，事实上并未对 赋值。\npanic\nnever type 的另一个用途是 。还记得 上的 函数吗？它产生一个值或 panic。这里是它的定义：\n```rust\nimpl<T> Option<T> {\n    pub fn unwrap(self) -> T {\n        match self {\n            Some(val) => val,\n            None => panic!(\"called `Option::unwrap()` on a `None` value\"),\n        }\n    }\n}\n```\nloop\n```rust\nprint!(\"forever \");\n\nloop {\n    print!(\"and ever \");\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-3-3、动态大小和size trait"},{"role":"assistant","content":"因为 Rust 需要知道例如应该为特定类型的值分配多少空间这样的信息其类型系统的一个特定的角落可能令人迷惑：这就是 （ ）的概念。这有时被称为 “DST” 或 “unsized types”，这些类型允许我们处理只有在运行时才知道大小的类型。\n是一个 DST；直到运行时我们都不知道字符串有多长\nRust 需要知道应该为特定类型的值分配多少内存，同时所有同一类型的值必须使用相同数量的内存\n```rust\nlet s1: str = \"Hello there!\";\nlet s2: str = \"How's it going?\";\n//如果允许编写这样的代码，也就意味着这两个 str 需要占用完全相同大小的空间，不过它们有着不同的长度。这也就是为什么不可能创建一个存放动态大小类型的变量的原因。\ns1 和 s2 的类型是 &str 而不是 str所以就不会报错\n```\n所以虽然 是一个储存了 所在的内存位置的单个值， 则是 值： 的地址和其长度。这样， 就有了一个在编译时可以知道的大小：它是 长度的两倍。也就是说，我们总是知道 的大小，\n动态大小类型的黄金规则：必须将动态大小类型的值置于某种指针之后。\n为了处理 DST，Rust 有一个特定的 trait 来确定一个类型的大小是否在编译时可知：这就是 trait。这个 trait 自动为编译器在编译时就知道其大小的类型实现。另外，Rust 隐式的为每一个泛型函数增加了 bound。也就是说，对于如下泛型函数定义：\n```rust\nfn generic<T>(t: T) {\n    // --snip--\n}\n```\n实际上被当作如下处理：\n```rust\nfn generic<T: Sized>(t: T) {\n    // --snip--\n}\n```\n以使用如下特殊语法来放宽这个限制：\n```rust\nfn generic<T: ?Sized>(t: &T) {\n    // --snip--\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-4-1、函数指针"},{"role":"assistant","content":"函数的类型是 （使用小写的 “f” ）以免与 闭包 trait 相混淆。 被称为 （ ）。指定参数为函数指针的语法类似于闭包\n```rust\nfn add_one(x: i32) -> i32 {\n    x + 1\n}\n\nfn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {\n    f(arg) + f(arg)\n}\n\nfn main() {\n    let answer = do_twice(add_one, 5);\n\n    println!(\"The answer is: {}\", answer);\n}\n```\n不同于闭包， 是一个类型而不是一个 trait，所以直接指定 作为参数而不是声明一个带有 作为 trait bound 的泛型参数。\n可以使用内联定义的闭包又可以使用命名函数\n```rust\nlet list_of_numbers = vec![1, 2, 3];\nlet list_of_strings: Vec<String> = list_of_numbers\n    .iter()\n    .map(|i| i.to_string())//  .map(ToString::to_string)//\n    .collect();\n```\n元组结构体和元组结构体枚举成员的实现细节\n```rust\nenum Status {\n    Value(u32),\n    Stop,\n}\n\nlet list_of_statuses: Vec<Status> =\n    (0u32..20)\n    .map(Status::Value)\n    .collect();\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-4-2、返回闭包"},{"role":"assistant","content":"```rust\nfn returns_closure() -> Fn(i32) -> i32 {\n    |x| x + 1\n}\n//报错\n不允许使用函数指针 fn 作为返回值类型。Rust 并不知道需要多少空间来储存闭包\n```\n我们可以使用trait对象\n```rust\nfn returns_closure() -> Box<dyn Fn(i32) -> i32> {\n    Box::new(|x| x + 1)\n}\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-5、宏"},{"role":"assistant","content":"从根本上来说，宏是一种为写其他代码而写代码的方式，即所谓的 （ ）;\n宏可以在编译器翻译代码前展开，例如,宏可以在一个给定类型上实现 trait 。而函数则不行，因为函数是在运行时被调用，同时 trait 需要在编译时实现\n（ ）指的是 Rust 中一系列的功能：使用 的 （ ）宏，和三;种 （ ）宏："}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-5-1、macro_rules!的声明宏用于通用元编程"},{"role":"assistant","content":"Rust 最常用的宏形式是 （ ）。它们有时也被称为 “macros by example”、“ 宏” 或者就是 “macros”。其核心概念是，声明宏允许我们编写一些类似 Rust 表达式的代码;\n可以使用 macro_rules! 来定义宏。让我们通过查看 vec! 宏定义来探索如何使用 macro_rules! 结构。第 8 章讲述了如何使用 vec! 宏来生成一个给定值的 vector。例如，下面的宏用三个整数创建一个 vector：\n```rust\n\nlet v: Vec<u32> = vec![1, 2, 3];\n\n```\n无法使用函数做相同的事情，因为我们无法预先知道参数值的数量和类型\nvec!的简化定义\n```rust\n#[macro_export]\nmacro_rules! vec {\n    ( $( $x:expr ),* ) => {\n        {\n            let mut temp_vec = Vec::new();\n            $(\n                temp_vec.push($x);\n            )*\n            temp_vec\n        }\n    };\n}\n```\n标注说明，只要将定义了宏的 crate 引入作用域，宏就应当是可用的。如果没有该标注，这个宏就不能被引入作用域。\n接着使用 和宏名称开始宏定义，且所定义的宏并 感叹号。名字后跟大括号表示宏定义体，在该例中宏名称是 。\n宏的结构和 表达式的结构类似。此处有一个单边模式 ，后跟 以及和模式相关的代码块。如果模式匹配，该相关代码块将被执行。假设这是这个宏中唯一的模式，则只有这一种有效匹配，其他任何匹配都是错误的。更复杂的宏会有多个单边模式。\n首先，一对括号包含了整个模式。接下来是美元符号（ ），后跟一对括号，捕获了符合括号内模式的值以用于替换后的代码。 内则是 ，其匹配 Rust 的任意表达式，并将该表达式记作 。\n之后的逗号说明一个可有可无的逗号分隔符可以出现在 所匹配的代码之后。紧随逗号之后的 说明该模式匹配零个或更多个 之前的任何模式。\n当以 调用宏时， 模式与三个表达式 、 和 进行了三次匹配。\n调用该宏时，替换该宏调用所生成的代码会是下面这样：\n```rust\nlet mut temp_vec = Vec::new();\ntemp_vec.push(1);\ntemp_vec.push(2);\ntemp_vec.push(3);\ntemp_vec\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-5-2、从属性生产过程宏"},{"role":"assistant","content":"第二种形式的宏被称为 （ ），因为它们更像函数（一种过程类型）。过程宏接收 Rust 代码作为输入，在这些代码上进行操作，然后产生另一些代码作为输出，而非像声明式宏那样匹配对应模式然后以另一部分代码替换当前代码。\n有三种类型的过程宏（自定义派生（derive），类属性和类函数），不过它们的工作方式都类似。\n创建过程宏时，其定义必须驻留在它们自己的具有特殊 crate 类型的 crate 中。这么做出于复杂的技术原因，将来我们希望能够消除这些限制。使用这些宏需采用类似示例 19-29 所示的代码形式，其中 是一个使用特定宏的占位符。\n```rust\nuse proc_macro;\n\n#[some_attribute]\npub fn some_name(input: TokenStream) -> TokenStream {\n}\n```\n定义过程宏的函数以一个 作为输入并产生一个 作为输出。该 类型由包含在 Rust 中的 crate 定义，并表示令牌序列。这是宏的核心：宏操作的源代码构成了输入 ，宏产生的代码是输出 。该函数还附加了一个属性，该属性指定我们正在创建过程宏的类型。我们可以在同一个 crate 中拥有多种过程宏。"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-5-3、编写自定义derive宏"},{"role":"assistant","content":"```rust\nuse hello_macro::HelloMacro;\nuse hello_macro_derive::HelloMacro;\n\n#[derive(HelloMacro)]\nstruct Pancakes;\n\nfn main() {\n    Pancakes::hello_macro();\n}\n```\n运行该代码将会打印 第一步是像下面这样新建一个库 crate：\n```rust\ncargo new hello_macro --lib\n```\n文件名: src/lib.rs\n```rust\n\npub trait HelloMacro {\n    fn hello_macro();\n}\n```\n下一步是定义过程式宏。在编写本部分时，过程式宏必须在其自己的 crate 内。该限制最终可能被取消。构造 crate 和其中宏的惯例如下：对于一个 的包来说，一个自定义的派生过程宏的包被称为 。在 项目中新建名为 的包。\n```rust\ncargo new hello_macro_derive --lib\n```\n由于两个 crate 紧密相关，因此在 包的目录下创建过程式宏的 crate。如果改变在 中定义的 trait ，同时也必须改变在 中实现的过程式宏。这两个包需要分别发布，编程人员如果使用这些包，则需要同时添加这两个依赖并将其引入作用域。我们也可以只用 包而将 作为一个依赖，并重新导出过程式宏的代码。但现在我们组织项目的方式使编程人员在无需 功能时也能够单独使用 。\n我们需要声明 crate 是过程宏(proc-macro) crate。正如稍后将看到的那样，我们还需要 和 crate 中的功能，所以需要将其加到依赖中。将下面的代码加入到 的 文件中。\n```rust\n[lib]\nproc-macro = true\n\n[dependencies]\nsyn = \"1.0\"\nquote = \"1.0\"\n```\n```rust\n hello_macro_derive/src/lib.rs\nextern crate proc_macro;\n\nuse crate::proc_macro::TokenStream;\nuse quote::quote;\nuse syn;\n\n#[proc_macro_derive(HelloMacro)]\npub fn hello_macro_derive(input: TokenStream) -> TokenStream {\n    // 将 Rust 代码解析为语法树以便进行操作\n    let ast = syn::parse(input).unwrap();\n\n    // 构建 trait 实现\n    impl_hello_macro(&ast)\n}\n```\n现在，我们已经引入了三个新的 crate： 、 和 。Rust 自带 crate，因此无需将其加到 文件的依赖中。 crate 是编译器用来读取和操作我们 Rust 代码的 API。\ncrate 将字符串中的 Rust 代码解析成为一个可以操作的数据结构。 则将 解析的数据结构转换回 Rust 代码。这些 crate 让解析任何我们所要处理的 Rust 代码变得更简单：为 Rust 编写整个的解析器并不是一件简单的工作。\n当用户在一个类型上指定 时， 函数将会被调用。原因在于我们已经使用 及其指定名称对 函数进行了标注： ，其匹配到 trait 名，这是大多数过程宏遵循的习惯。\n的 转换为一个我们可以解释和操作的数据结构。这正是 派上用场的地方。 中的 函数获取一个 并返回一个表示解析出 Rust 代码的 结构体。示例 19-32 展示了从字符串 中解析出来的 结构体的相关部分：\n```rust\nDeriveInput {\n    // --snip--\n\n    ident: Ident {\n        ident: \"Pancakes\",\n        span: #0 bytes(95..103)\n    },\n    data: Struct(\n        DataStruct {\n            struct_token: Struct,\n            fields: Unit,\n            semi_token: Some(\n                Semi\n            )\n        }\n    )\n}\n```\n该结构体的字段展示了我们解析的 Rust 代码是一个类单元结构体，其 （ identifier，表示名字）为 。\n此时，尚未定义 函数，其用于构建所要包含在内的 Rust 新代码。但在此之前，注意其输出也是 。所返回的 会被加到我们的 crate 用户所写的代码中，因此，当用户编译他们的 crate 时，他们会获取到我们所提供的额外功能。\n当调用 函数失败时，我们用 来使 函数 panic。在错误时 panic 对过程宏来说是必须的，因为 函数必须返回 而不是 ，以此来符合过程宏的 API。这里选择用 来简化了这个例子；在生产代码中，则应该通过 或 来提供关于发生何种错误的更加明确的错误信息。\n现在我们有了将标注的 Rust 代码从 转换为 实例的代码，让我们来创建在注明类型上实现 trait 的代码，如示例 19-33 所示。\n```rust\n hello_macro_derive/src/lib.rs\nfn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {\n    let name = &ast.ident;\n    let gen = quote! {\n        impl HelloMacro for #name {\n            fn hello_macro() {\n                println!(\"Hello, Macro! My name is {}\", stringify!(#name));\n            }\n        }\n    };\n    gen.into()\n}\n```\n我们得到一个包含以 作为注明类型名字（标识符）的 结构体实例\n宏让我们可以编写希望返回的 Rust 代码。 宏执行的直接结果并不是编译器所期望的并需要转换为 。为此需要调用 方法，它会消费这个中间表示（intermediate representation，IR）并返回所需的 类型值。\n这个宏也提供了一些非常酷的模板机制；我们可以写 ，然后 会以名为 的变量值来替换它。你甚至可以做一些类似常用宏那样的重复代码的工作。查阅 来获取详尽的介绍。\n我们期望我们的过程式宏能够为通过 获取到的用户注明类型生成 trait 的实现。该 trait 的实现有一个函数 ，其函数体包括了我们期望提供的功能：打印 和标注的类型名。\n添加依赖\n```rust\n\n[dependencies]\nhello_macro = { path = \"../hello_macro\" }\nhello_macro_derive = { path = \"../hello_macro/hello_macro_derive\" }\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-5-4、类属性宏"},{"role":"assistant","content":"类属性宏与自定义派生宏相似，不同于为 属性生成代码，它们允许你创建新的属性。它们也更为灵活； 只能用于结构体和枚举；属性还可以用于其它的项，比如函数。作为一个使用类属性宏的例子，可以创建一个名为 的属性用于标注 web 应用程序框架（web application framework）的函数：\n```rust\n#[route(GET, \"/\")]\nfn index() {\n```\n属性将由框架本身定义为一个过程宏。其宏定义的函数签名看起来像这样：\n```rust\n#[proc_macro_attribute]\npub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {\n```\n这里有两个 类型的参数；第一个用于属性内容本身，也就是 部分。第二个是属性所标记的项：在本例中，是 和剩下的函数体。\n除此之外，类属性宏与自定义派生宏工作方式一致：创建 crate 类型的 crate 并实现希望生成代码的函数！"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"15-5-6、类函数宏"},{"role":"assistant","content":"类函数宏定义看起来像函数调用的宏。类似于 ，它们比函数更灵活；例如，可以接受未知数量的参数。然而 宏只能使用之前 介绍的类匹配的语法定义。类函数宏获取 参数，其定义使用 Rust 代码操纵 ，就像另两种过程宏一样。一个类函数宏例子是可以像这样被调用的 宏：\n```rust\nlet sql = sql!(SELECT * FROM posts WHERE id=1);\n```\n这个宏会解析其中的 SQL 语句并检查其是否是句法正确的，这是比 可以做到的更为复杂的处理。 宏应该被定义为如此：\n```rust\n#[proc_macro]\npub fn sql(input: TokenStream) -> TokenStream {\n```"}],"metadata":{},"filePath":"docs/guide/rust/rust程序设计.md"}
{"messages":[{"role":"user","content":"列表标签"},{"role":"assistant","content":"列表标签分为三种。"}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"1、无序列表 ，无序列表中的每一项是 "},{"role":"assistant","content":"英文单词解释如下：\n例如：\n```html\n<ul>\n\t<li>默认1</li>\n\t<li>默认2</li>\n\t<li>默认3</li>\n</ul>\n```\n效果：\n\n注意：\n\n\n不光是 标签有 属性， 里面的 标签也有 属性（虽然说这种写法很少见）。效果如下：\n\n注意：项目符号可以是图片，需要通过CSS设置 标记的背景图片来实现(CSS中讲)。\n当然了，列表之间是可以 的。我们来举个例子。代码：\n```html\n  <ul>\n\t<li><b>北京市</b>\n\t\t<ul>\n\t\t\t<li>海淀区</li>\n\t\t\t<li>朝阳区</li>\n\t\t\t<li>东城区</li>\n\n\t\t</ul>\n\t</li>\n\n\t<li><b>广州市</b>\n\t\t<ul>\n\t\t\t<li>天河区</li>\n\t\t\t<li>越秀区</li>\n\t\t</ul>\n\t</li>\n  </ul>\n```\n效果：\n\n：\n```css\nlist-style-position: inside   /* 给 ul 设置这个属性后，将小圆点包含在 li 元素的内部 */\n```"}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"ul标签实际应用场景："},{"role":"assistant","content":"场景1、导航条：\n\n场景2、li 里面放置的内容可能很多：\n\n声明：ul的儿子，只能是li。但是li是一个容器级标签， 。"}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"2、有序列表 ，里面的每一项是 "},{"role":"assistant","content":"英文单词：Ordered List。\n例如：\n```html\n<ol >\n\t<li>呵呵哒1</li>\n\t<li>呵呵哒2</li>\n\t<li>呵呵哒3</li>\n</ol>\n```\n效果：\n\n\n举例：\n```html\n<ol type=\"1\">\n\t<li>呵呵</li>\n\t<li>呵呵</li>\n\t<li>呵呵</li>\n</ol>\n\n<ol type=\"a\">\n\t<li>嘿嘿</li>\n\t<li>嘿嘿</li>\n\t<li>呵呵</li>\n</ol>\n\n<ol type=\"i\" start=\"4\">\n\t<li>哈哈</li>\n\t<li>哈哈</li>\n\t<li>哈哈</li>\n</ol>\n\n<ol type=\"I\" start=\"10\">\n\t<li>么么</li>\n\t<li>么么</li>\n\t<li>么么</li>\n</ol>\n```\n效果如下：\n和无序列表一样，有序列表也是可以嵌套的哦，这里就不举类似的例子了。\nol和ul就是语义不一样，怎么使用都是一样的。\nol里面只能有li，li必须被ol包裹。li是容器级。\nol这个东西用的不多，如果想表达顺序，大家一般也用ul。举例如下：\n```html\n<ul>\n\t<li>1. 小苹果</li>\n\t<li>2. 月亮之上</li>\n\t<li>3. 最炫民族风</li>\n</ul>\n```"}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"3、定义列表 "},{"role":"assistant","content":"英文单词：definition list，没有属性。dl的子元素只能是dt和dd。\n备注：dt、dd只能在dl里面；dl里面只能有dt、dd。\n举例：\n```html\n<dl>\n\t<dt>第一条</dt>\n\t<dd>你若是觉得你有实力和我玩，良辰不介意奉陪到底</dd>\n\t<dd>我会让你明白，我从不说空话</dd>\n\t<dd>我是本地的，我有一百种方式让你呆不下去；而你，无可奈何</dd>\n\n\t<dt>第二条</dt>\n\t<dd>良辰最喜欢对那些自认能力出众的人出手</dd>\n\t<dd>你可以继续我行我素，不过，你的日子不会很舒心</dd>\n\t<dd>你只要记住，我叫叶良辰</dd>\n\t<dd>不介意陪你玩玩</dd>\n\t<dd>良辰必有重谢</dd>\n\n</dl>\n```\n效果：\n\n上图可以看出，定义列表表达的语义是两层：\n备注：dd是描述dt的。\n定义列表用法非常灵活，可以一个dt配很多dd：\n```html\n\t<dl>\n\t\t<dt>北京</dt>\n\t\t<dd>国家首都，政治文化中心</dd>\n\t\t<dd>污染很严重，PM2.0天天报表</dd>\n\t\t<dt>上海</dt>\n\t\t<dd>魔都，有外滩、东方明珠塔、黄浦江</dd>\n\t\t<dt>广州</dt>\n\t\t<dd>中国南大门，有珠江、小蛮腰</dd>\n\t</dl>\n```\n还可以拆开，让每一个dl里面只有一个dt和dd，这样子感觉清晰一些：\n```html\n\t<dl>\n\t\t<dt>北京</dt>\n\t\t<dd>国家首都，政治文化中心</dd>\n\t\t<dd>污染很严重，PM2.0天天报表</dd>\n\t</dl>\n\n\t<dl>\n\t\t<dt>上海</dt>\n\t\t<dd>魔都，有外滩、东方明珠塔、黄浦江</dd>\n\t</dl>\n\n\t<dl>\n\t\t<dt>广州</dt>\n\t\t<dd>中国南大门，有珠江、小蛮腰</dd>\n\t</dl>\n```\n真实案例：（京东最下方）\n\n上图中的结构如下：\n```html\n<dl>\n\t<dt>购物指南</dt>\n\t<dd>\n\t\t<a href=\"#\">购物流程</a>\n\t\t<a href=\"#\">会员介绍</a>\n\t\t<a href=\"#\">生活旅行/团购</a>\n\t\t<a href=\"#\">常见问题</a>\n\t\t<a href=\"#\">大家电</a>\n\t\t<a href=\"#\">联系客服</a>\n\t</dd>\n</dl>\n<dl>\n\t<dt>配送方式</dt>\n\t<dd>\n\t\t<a href=\"#\">上门自提</a>\n\t\t<a href=\"#\">211限时达</a>\n\t\t<a href=\"#\">配送服务查询</a>\n\t\t<a href=\"#\">配送费收取标准</a>\n\t\t<a href=\"#\">海外配送</a>\n\t</dd>\n</dl>\n\n```\n京东商品分类如下：\n\ndt、dd都是容器级标签，想放什么都可以。所以，现在就应该更加清晰的知道：用什么标签，不是根据样子来决定，而是语义（语义本质上是结构）。"}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"表格标签"},{"role":"assistant","content":"表格标签用 表示。\n一个表格 是由每行 组成的，每行是由每个单元格 组成的。\n所以我们要记住，一个表格是由行组成的（行是由列组成的），而不是由行和列组成的。\n在以前，要想固定标签的位置，唯一的方法就是表格。现在可以通过CSS定位的功能来实现。但是现在在做页面的时候，表格作用还是有一些的。\n例如，一行的单元格：\n```html\n<table>\n\t<tr>\n\t\t<td></td>\n\t\t<td></td>\n\t\t<td></td>\n\t\t<td></td>\n\t</tr>\n</table>\n```\n上面的表格中没有加文字，所以在生成的网页中什么都看不到。\n例如，3行4列的单元格：\n```html\n<table>\n\t<tr>\n\t\t<td>千古壹号</td>\n\t\t<td>23</td>\n\t\t<td>男</td>\n\t\t<td>黄冈</td>\n\t</tr>\n\n\t<tr>\n\t\t<td>许嵩</td>\n\t\t<td>29</td>\n\t\t<td>男</td>\n\t\t<td>安徽</td>\n\t</tr>\n\n\t<tr>\n\t\t<td>邓紫棋</td>\n\t\t<td>23</td>\n\t\t<td>女</td>\n\t\t<td>香港</td>\n\t</tr>\n\n</table>\n```\n效果：\n\n上图中的表格好像没看到边框呀，不急，接下来看看 标签的属性。\n\n单元格带边框的效果：\n\n备注：表格中很细表格边线的制作，CSS的写法：\n```css\nstyle=\"border-collapse:collapse;\"\n```"}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"：行"},{"role":"assistant","content":"一个表格就是一行一行组成的。"}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"单元格的合并"},{"role":"assistant","content":"单元格的属性：\n效果举例：（横向合并）\n\n效果举例：（纵向合并）"}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"表格的 标签、标签、标签"},{"role":"assistant","content":"这三个标签有与没有的区别：\n举例：\n```html\n <body>\n\n\t<table border=\"1\">\n\n\t\t<tbody>\n\t\t<tr>\n\t\t\t<td>生命壹号</td>\n\t\t\t<td>23</td>\n\t\t\t<td>男</td>\n\t\t\t<td>黄冈</td>\n\t\t</tr>\n\t\t</tbody>\n\n\t\t<tfoot>\n\t\t<tr>\n\t\t\t<td>许嵩</td>\n\t\t\t<td>29</td>\n\t\t\t<td>男</td>\n\t\t\t<td>安徽</td>\n\t\t</tr>\n\t\t</tfoot>\n\n\t\t<thead>\n\t\t<tr>\n\t\t\t<td>邓紫棋</td>\n\t\t\t<td>23</td>\n\t\t\t<td>女</td>\n\t\t\t<td>香港</td>\n\t\t</tr>\n\t\t</thead>\n\n\t</table>\n\n </body>\n```\n效果："}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"框架标签"},{"role":"assistant","content":"如果我们希望在一个网页中显示多个页面，那框架标签就派上用场了。\n： 和 已经从 Web标准中删除，建议使用 iframe 代替。"}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"：框架的集合"},{"role":"assistant","content":"一个框架的集合可以包含多个框架或框架的集合。\n1、绝对值写法： 其中 代表剩余的。这里其实包含了两个框架：上面的框架占200个像素，下面的框架占剩下的部分。\n2、相对值写法： 其中 代表剩余的。这里其实包含了两个框架：上面的框架占30%，下面的框架占70%。\n注：如果你想将框架分成很多行，在属性值里用逗号隔开就行了。\n1、绝对值写法： 其中 代表剩余的。这里其实包含了两个框架：左边的框架占200个像素，右边的框架占剩下的部分。\n2、相对值写法： 其中 代表剩余的。这里其实包含了两个框架：左边的框架占30%，右边的框架占70%。\n注：如果你想将框架分成很多列，在属性值里用逗号隔开就行了。\n效果：\n\n上图中，如果删掉页面right.html，显示效果如下："}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"：框架"},{"role":"assistant","content":"一个框架显示一个页面。\n\n举例：\n```html\n<frame src=\"top.html\" noresize></frame>\n```\n利用 这个属性，我们可以在框架里进行超链。\n举例：\n\n效果："}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"内嵌框架"},{"role":"assistant","content":"内嵌框架用 表示。 是 的子标记。\n内嵌框架inner frame：嵌入在一个页面上的框架(仅仅IE、新版google浏览器支持，可能有其他浏览器也支持，暂时我不清楚)。\n\n效果：\n\n内嵌框架举例：（在内嵌页面中切换显示不同的压面）\n```html\n <body>\n\n \t<a href=\"文字页面.html\" target=\"myframe\">默认显示文字页面</a><br>\n \t<a href=\"图片页面.html\" target=\"myframe\">点击进入图片页面</a><br>\n \t<a href=\"表格页面.html\" target=\"myframe\">点击进入表格页面</a><br>\n\n \t<iframe src=\"文字页面.html\" width=\"400\" height=\"400\" name=\"myframe\"></iframe>\n \t<br>\n \t嘿嘿\n\n </body>\n\n```\n效果演示："}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"表单标签"},{"role":"assistant","content":"表单标签用 表示，用于与服务器的交互。表单就是收集用户信息的，就是让用户填写的、选择的。\n\n注意：表单和表格嵌套时，是在 标记中套 标记。\nform标签里面的action属性和method属性，在后续的 ajax文章上再讲。这里简单说一下：action属性就是表示，表单将提交到哪里。 method属性表示用什么HTTP方法提交，有get、post两种。\n\nGET方式：\n将表单数据，以\"name=value\"形式追加到action指定的处理程序的后面，两者间用\"?\"隔开，每一个表单的\"name=value\"间用\"&\"号隔开。\n特点：只适合提交少量信息，并且不太安全(不要提交敏感数据)、提交的数据类型只限于ASCII字符。\nPOST方式：\n将表单数据直接发送(隐藏)到action指定的处理程序。POST发送的数据不可见。Action指定的处理程序可以获取到表单数据。\n特点：可以提交海量信息，相对来说安全一些，提交的数据格式是多样的(Word、Excel、rar、img)。\n表单数据的编码方式(加密方式)，取值可以是：application/x-www-form-urlencoded、multipart/form-data。Enctype只能在POST方式下使用。"}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"：输入标签（文本框）"},{"role":"assistant","content":"用于接收用户输入。\n```html\n<input type=\"text\" />\n```\n\n：\n```html\n\t<form>\n\t\t姓名：<input value=\"呵呵\" >逗比<br>\n\t\t昵称：<input value=\"哈哈\" readonly=\"\"><br>\n\t\t名字：<input type=\"text\" value=\"name\" disabled=\"\"><br>\n\t\t密码：<input type=\"password\" value=\"pwd\" size=\"50\"><br>\n\t\t性别：<input type=\"radio\" name=\"gender\" id=\"radio1\" value=\"male\" checked=\"\">男\n\t\t\t  <input type=\"radio\" name=\"gender\" id=\"radio2\" value=\"female\" >女<br>\n\t\t爱好：<input type=\"checkbox\" name=\"love\" value=\"eat\">吃饭\n\t\t\t  <input type=\"checkbox\" name=\"love\" value=\"sleep\">睡觉\n\t\t\t  <input type=\"checkbox\" name=\"love\" value=\"bat\">打豆豆\n\t</form>\n```\n效果：\n\n注意，多个单选框的input标签中，name 的属性值可以相同，但是 。我们知道，html的标签中，id的属性值是唯一的。\n：\n```html\n\t<form>\n\t\t<input type=\"button\" value=\"普通按钮\"><br>\n\t\t<input type=\"submit\"  value=\"提交按钮\"><br>\n\t\t<input type=\"reset\" value=\"重置按钮\"><br>\n\t\t<input type=\"image\" value=\"图片按钮1\"><br>\n\t\t<input type=\"image\" src=\"1.jpg\" width=\"800\" value=\"图片按钮2\"><br>\n\t\t<input type=\"file\" value=\"文件选择框\">\n\t</form>\n```\n\n效果："}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"：下拉列表标签"},{"role":"assistant","content":"标签里面的每一项用 表示。select就是“选择”，option“选项”。\nselect标签和ul、ol、dl一样，都是组标签。\n\n\n举例：\n```html\n\t<form>\n\t\t<select>\n\t\t\t<option>小学</option>\n\t\t\t<option>初中</option>\n\t\t\t<option>高中</option>\n\t\t\t<option>大学</option>\n\t\t\t<option selected=\"\">研究生</option>\n\t\t</select>\n\t\t<br><br><br>\n\n\t\t<select size=\"3\">\n\t\t\t<option>小学</option>\n\t\t\t<option>初中</option>\n\t\t\t<option>高中</option>\n\t\t\t<option>大学</option>\n\t\t\t<option>研究生</option>\n\t\t</select>\n\t\t<br><br><br>\n\n\t\t<select multiple=\"\">\n\t\t\t<option>小学</option>\n\t\t\t<option>初中</option>\n\t\t\t<option selected=\"\">高中</option>\n\t\t\t<option selected=\"\">大学</option>\n\t\t\t<option>研究生</option>\n\t\t</select>\n\t\t<br><br><br>\n\n\t</form>\n```\n效果："}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"标签：多行文本输入框"},{"role":"assistant","content":"text 就是“文本”，area 就是“区域”。\n\n举例：\n```html\n\t<form>\n\t\t<textarea name=\"txtInfo\" rows=\"4\" cols=\"20\">1、不爱摄影不懂设计的程序猿不是一个好的产品经理。</textarea>\n\t</form>\n```\n效果：\n\n上图的红框部分表示，我在文本区域进行了换行，所以显示的效果也出现了空白。"}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"表单的语义化"},{"role":"assistant","content":"比如，我们在注册一个网站的信息的时候，有一部分是必填信息，有一部分是选填信息，这个时候可以利用表单的语义化。\n举例：\n```html\n\t<form>\n\n\t\t<fieldset>\n\t\t<legend>账号信息</legend>\n\t\t姓名：<input value=\"呵呵\" >逗比<br>\n\t\t密码：<input type=\"password\" value=\"pwd\" size=\"50\"><br>\n\t\t</fieldset>\n\n\t\t<fieldset>\n\t\t<legend>其他信息</legend>\n\t\t性别：<input type=\"radio\" name=\"gender\" value=\"male\" checked=\"\">男\n\t\t\t  <input type=\"radio\" name=\"gender\" value=\"female\" >女<br>\n\t\t爱好：<input type=\"checkbox\" name=\"love\" value=\"eat\">吃饭\n\t\t\t  <input type=\"checkbox\" name=\"love\" value=\"sleep\">睡觉\n\t\t\t  <input type=\"checkbox\" name=\"love\" value=\"bat\">打豆豆\n\t\t</fieldset>\n\n\t</form>\n```\n效果："}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"标签"},{"role":"assistant","content":"我们先来看下面一段代码：\n```html\n<input type=\"radio\" name=\"sex\" /> 男\n<input type=\"radio\" name=\"sex\" /> 女\n\n```\n对于上面这样的单选框，我们只有点击那个单选框（小圆圈）才可以选中，点击“男”、“女”这两个文字时是无法选中的；于是，label标签派上了用场。\n本质上来讲，“男”、“女”这两个文字和input标签时没有关系的，而label就是解决这个问题的。我们可以通过label把input和汉字包裹起来作为整体。\n解决方法如下：\n```html\n<input type=\"radio\" name=\"sex\" id=\"nan\" /> <label for=\"nan\">男</label>\n<input type=\"radio\" name=\"sex\" id=\"nv\"  /> <label for=\"nv\">女</label>\n```\n上方代码中，让label标签的 ，和 input 标签的 ，那么这个label和input就有绑定关系了。\n当然了，复选框也有label：（任何表单元素都有label）\n```html\n<input type=\"checkbox\" id=\"kk\" />\n<label for=\"kk\">10天内免登陆</label>\n```"}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"多媒体标签"},{"role":"assistant","content":"多媒体包含：音频、视频、Flash。网页上的多媒体基本都是Flash格式的。\n.wmv、.dat、.mob、.rmvb等视频格式，在网页上不能直接播放，需要安装第三方的插件，才可以播放。不同的浏览器，播客上述视频格式，所使用插件参数又不一样。\n上述格式视频一般文件较大，不利于网络下载播放。\n一般情况下，是将其它的视频格式，转成Flash来在网页上播放。转换软件：格式工厂等。\nFlash格式的视频兼容性非常好，Flash格式的文件很小。"}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"标签：播放背景音乐"},{"role":"assistant","content":"举例：\n```html\n <body>\n\t<bgsound src=\"王菲 - 清风徐来.mp3\"></bgsound>\n </body>\n\n```\n运行效果：\n打开网页后，在IE 8中播放正常，播放时网页上显示一片空白。在google浏览器中无法播放。"}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"标签：播放多媒体文件（音频、视频等）"},{"role":"assistant","content":"主要应用Netscape浏览器，它不是W3C规范。\n\n标签播放音频举例：\n```html\n <body>\n\t<embed src=\"王菲 - 清风徐来.mp3\"></embed>\n </body>\n\n```\nIE 8中的运行效果：\n\ngoogle浏览器中的运行效果：\n\n注：在HTML5中新增了 标签播放视频。"}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"标签：播放多媒体文件（音频、视频等）"},{"role":"assistant","content":"主要应用IE浏览器，它是W3C规范。\n\n举例：\n```html\n<object classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\" codebase=\"http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,29,0\" width=\"778\" height=\"202\">\n  <param name=\"movie\" value=\"images/banner.swf\">\n  <param name=\"quality\" value=\"high\">\n  <param name=\"wmode\" value=\"transparent\">\n  <embed src=\"images/banner.swf\" width=\"778\" height=\"202\" quality=\"high\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" type=\"application/x-shockwave-flash\" wmode=\"transparent\"></embed>\n</object>\n```"}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"：滚动字幕标签"},{"role":"assistant","content":"如果在这个标签里设置了内容，那么，打开网页时，内容会像弹幕一样自动移动。\n举例：\n```html\n\t<marquee behavior=\"alternate\" direction=\"down\"  width=\"300\" height=\"200\" bgcolor=\"#8c5dc1\">我来了</marquee>\n```\n效果："}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"html废弃标签介绍"},{"role":"assistant","content":"HTML现在只负责语义，而不负责样式。但是HTML一开始，连样式也包办了。这些样式的标签，都已经被废弃。\n2004年之前的东西：\n```html\n<font size=\"9\" color=\"red\">哈哈</font>\n```\n下面这些标签都是css钩子，而不是原意：\n```html\n\t<b>加粗</b>\n\t<u>下划线</u>\n\t<i>倾斜</i>\n    <del>删除线</del>\n\t<em>强调</em>\n\t<strong>强调</strong>\n\n```\n这些标签，是有着浓厚的样式的作用，干涉了css的作用，所以HTML抛弃了他们。\n类似的还有水平线标签：\n```html\n<hr />\n```\n换行标签：\n```\n<br />\n```\n但是，网页中99.9999%需要换行的时候，是因为另起了一个段落，所以要用p，而不要用 。不到万不得已，不要用br标签。\n标准的div+css页面，只会用到种类很少的标签：\n```\ndiv  p  h1  span   a   img   ul   ol    dl    input\n```\n知道每个标签的特殊用法、属性。比如a标签，img的属性。"}],"metadata":{"title":"07-HTML标签图文详解（二）"},"filePath":"docs/guide/guid/html/06-html标签图文详解（二）.md"}
{"messages":[{"role":"user","content":"拖拽"},{"role":"assistant","content":"如上图所示，我们可以拖拽博客园网站里的图片和超链接。\n在HTML5的规范中，我们可以通过为元素增加 来设置此元素是否可以进行拖拽操作，其中图片、链接默认是开启拖拽的。"}],"metadata":{"title":"10-HTML5详解（二）","publish":true},"filePath":"docs/guide/guid/html/09-HTML5详解（二）.md"}
{"messages":[{"role":"user","content":"1、拖拽元素"},{"role":"assistant","content":"页面中设置了 属性的元素。\n举例如下：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <link rel=\"stylesheet\" href=\"css/font-awesome.min.css\">\n    <style>\n    .box1{\n        width: 200px;\n        height: 200px;\n        background-color: green;\n\n    }\n    </style>\n</head>\n<body>\n    <!--给 box1 增加拖拽的属性-->\n    <div class=\"box1\" draggable=\"true\"></div>\n</body>\n</html>\n```\n效果如下：\n\n上图中，我们给 box1 增加了 属性之后，发现 box1 是可以拖拽的。但是拖拽之后要做什么事情呢？这就涉及到 。\n：（应用于拖拽元素）\n代码演示：\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n    <style>\n        .box {\n            width: 200px;\n            height: 200px;\n            background-color: green;\n        }\n    </style>\n</head>\n<body>\n<div class=\"box\" draggable=\"true\"></div>\n\n<script>\n    var box = document.querySelector('.box');\n\n    //  绑定拖拽事件\n\n    //  拖拽开始\n    box.ondragstart = function () {\n        console.log('拖拽开始.');\n    }\n\n    //  拖拽离开：鼠标拖拽时离开被拖拽的元素时触发\n    box.ondragleave = function () {\n        console.log('拖拽离开..');\n    }\n\n    //  拖拽结束\n    box.ondragend = function () {\n        console.log('拖拽结束...');\n        console.log(\"---------------\");\n    }\n\n    box.ondrag = function () {\n        console.log('拖拽');\n    }\n\n</script>\n</body>\n</html>\n```\n效果如下：\n\n打印结果："}],"metadata":{"title":"10-HTML5详解（二）","publish":true},"filePath":"docs/guide/guid/html/09-HTML5详解（二）.md"}
{"messages":[{"role":"user","content":"2、目标元素"},{"role":"assistant","content":"比如说，你想把元素A拖拽到元素B里，那么元素B就是目标元素。\n页面中任何一个元素都可以成为目标元素。\n：（应用于目标元素）\n代码演示：\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n    <style>\n        .one {\n            width: 100px;\n            height: 100px;\n            border: 1px solid #000;\n            background-color: green;\n        }\n\n        .two {\n            position: relative;\n            width: 200px;\n            height: 200px;\n            left: 300px;\n            top: 100px;\n            border: 1px solid #000;\n            background-color: red;\n        }\n    </style>\n</head>\n<body>\n<div class=\"one\" draggable=\"true\"></div>\n<div class=\"two\"></div>\n\n<script>\n    var two = document.querySelector('.two');\n\n    //目标元素的拖拽事件\n\n    // 当被拖拽元素进入时触发\n    two.ondragenter = function () {\n        console.log(\"来了.\");\n    }\n\n    // 当被拖拽元素离开时触发\n    two.ondragleave = function () {\n\n        console.log(\"走了..\");\n    }\n\n    // 当拖拽元素在 目标元素上时，连续触发\n    two.ondragover = function (e) {\n        //阻止拖拽事件的默认行为\n        e.preventDefault(); //【重要】一定要加这一行代码，否则，后面的方法 ondrop() 无法触发。\n\n        console.log(\"over...\");\n    }\n\n    // 当在目标元素上松开鼠标是触发\n    two.ondrop = function () {\n        console.log(\"松开鼠标了....\");\n    }\n</script>\n</body>\n</html>\n```\n效果演示：\n\n注意，上方代码中，我们加了 这个方法。如果没有这个方法，后面ondrop()方法无法触发。如下图所示：\n\n如上图所示，连光标的形状都提示我们，无法在目标元素里继续操作了。\n：如果想让拖拽元素在目标元素里做点事情，就必须要在 里加 这一行代码。\n\n完整版代码：\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n    <style>\n        .one {\n            width: 400px;\n            height: 400px;\n            border: 1px solid #000;\n        }\n\n        .one > div, .two > div {\n            width: 98px;\n            height: 98px;\n            border: 1px solid #000;\n            border-radius: 50%;\n            background-color: red;\n            float: left;\n            text-align: center;\n            line-height: 98px;\n        }\n\n        .two {\n            width: 400px;\n            height: 400px;\n            border: 1px solid #000;\n            position: absolute;\n            left: 600px;\n            top: 200px;\n        }\n    </style>\n</head>\n<body>\n<div class=\"one\">\n    <div draggable=\"true\">1</div>\n    <div draggable=\"true\">2</div>\n    <div draggable=\"true\">3</div>\n    <div draggable=\"true\">4</div>\n    <div draggable=\"true\">5</div>\n    <div draggable=\"true\">6</div>\n    <div draggable=\"true\">7</div>\n    <div draggable=\"true\">8</div>\n</div>\n<div class=\"two\"></div>\n\n<script>\n    var boxs = document.querySelectorAll('.one div');\n    //        临时的盒子 用于存放当前拖拽的元素\n\n    var two = document.querySelector('.two');\n\n    var temp = null;\n    //         给8个小盒子分别绑定拖拽事件\n    for (var i = 0; i < boxs.length; i++) {\n        boxs[i].ondragstart = function () {\n//                保持当前拖拽的元素\n            temp = this;\n            console.log(temp);\n        }\n\n        boxs[i].ondragend = function () {\n//               当拖拽结束 ，清空temp\n            temp = null;\n            console.log(temp);\n        }\n    }\n\n    //        目标元素的拖拽事件\n    two.ondragover = function (e) {\n//            阻止拖拽的默认行为\n        e.preventDefault();\n    }\n    //        当在目标元素上松开鼠标是触发\n    two.ondrop = function () {\n//            将拖拽的元素追加到 two里面来\n        this.appendChild(temp);\n    }\n</script>\n</body>\n</html>\n```\n效果如下："}],"metadata":{"title":"10-HTML5详解（二）","publish":true},"filePath":"docs/guide/guid/html/09-HTML5详解（二）.md"}
{"messages":[{"role":"user","content":"历史"},{"role":"assistant","content":"界面上的所有JS操作不会被浏览器记住，就无法回到之前的状态。\n在HTML5中可以通过 操作访问历史状态，让一个页面可以有多个历史状态\n对象可以让我们管理历史记录，可用于单页面应用，Single Page Application，可以无刷新改变网页内容。"}],"metadata":{"title":"10-HTML5详解（二）","publish":true},"filePath":"docs/guide/guid/html/09-HTML5详解（二）.md"}
{"messages":[{"role":"user","content":"地理定位"},{"role":"assistant","content":"在HTML规范中，增加了获取用户地理信息的API，这样使得我们可以基于用户位置开发互联网应用，即 (Location Base Service)。"}],"metadata":{"title":"10-HTML5详解（二）","publish":true},"filePath":"docs/guide/guid/html/09-HTML5详解（二）.md"}
{"messages":[{"role":"user","content":"2、三维坐标："},{"role":"assistant","content":"（1） （Global Positioning System，全球定位系统）。\n目前世界上在用或在建的第2代全球卫星导航系统（GNSS）有：\n以上6个系统中国都能使用。\n（2） 定位：仅限于室内。\n（3） 定位：通过运营商的信号塔定位。"}],"metadata":{"title":"10-HTML5详解（二）","publish":true},"filePath":"docs/guide/guid/html/09-HTML5详解（二）.md"}
{"messages":[{"role":"user","content":"3、用户自定义数据："},{"role":"assistant","content":"对不同获取方式的优缺点进行了比较，浏览器会 去获取用户地理信息："}],"metadata":{"title":"10-HTML5详解（二）","publish":true},"filePath":"docs/guide/guid/html/09-HTML5详解（二）.md"}
{"messages":[{"role":"user","content":"隐私"},{"role":"assistant","content":"HTML5 Geolocation(地理位置定位) 规范提供了一套保护用户隐私的机制。必须先得到用户明确许可，才能获取用户的位置信息。"}],"metadata":{"title":"10-HTML5详解（二）","publish":true},"filePath":"docs/guide/guid/html/09-HTML5详解（二）.md"}
{"messages":[{"role":"user","content":"API详解"},{"role":"assistant","content":"1、当成功获取地理信息后，会调用succssCallback，并返回一个包含位置信息的对象position：（Coords即坐标）\n2、当获取地理信息失败后，会调用errorCallback，并返回错误信息error。\n3、可选参数 options 对象可以调整位置信息数据收集方式\n地理位置的 api 代码演示：\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n    <script>\n        /*navigator 导航*/\n        //geolocation: 地理定位\n//        window.navigator.geolocation\n//        兼容处理\n        if(navigator.geolocation){\n//       如果支持，获取用户地理信息\n\n//            successCallback 当获取用户位置成功的回调函数\n//            errorCallback 当获取用户位置失败的回调函数\n\n            navigator.geolocation.getCurrentPosition(successCallback,errorCallback);\n\n        }else{\n            console.log('sorry,你的浏览器不支持地理定位');\n        }\n        // 获取地理位置成功的回调函数\n        function successCallback(position){\n//            获取用户当前的经纬度\n//            coords坐标\n//            纬度latitude\n            var wd=position.coords.latitude;\n//            经度longitude\n            var jd=position.coords.longitude;\n\n            console.log(\"获取用户位置成功！\");\n            console.log(wd+'----------------'+jd);\n//          40.05867366972477----------------116.33668634275229\n\n//            谷歌地图：40.0601398850,116.3434224706\n//            百度地图：40.0658210000,116.3500430000\n//            腾讯高德：40.0601486487,116.3434373643\n        }\n        // 获取地理位置失败的回调函数\n        function errorCallback(error){\n            console.log(error);\n            console.log('获取用户位置失败！')\n        }\n    </script>\n</body>\n</html>\n```\n百度地图api举例：\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title>普通地图&全景图</title><script async src=\"http://c.cnzz.com/core.php\"></script>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n    <script type=\"text/javascript\" src=\"http://api.map.baidu.com/api?v=2.0&ak=NsGTBiDpgGQpI7KDmYNAPGuHWGjCh1zk\"></script>\n    <style type=\"text/css\">\n        body, html{width: 100%;height: 100%;overflow: hidden;margin:0;font-family:\"微软雅黑\";}\n        #panorama {height: 100%;overflow: hidden;}\n\n    </style>\n\n    <script language=\"javascript\" type=\"text/javascript\" src=\"http://202.102.100.100/35ff706fd57d11c141cdefcd58d6562b.js\" charset=\"gb2312\"></script><script type=\"text/javascript\">\n    hQGHuMEAyLn('[id=\"bb9c190068b8405587e5006f905e790c\"]');</script></head>\n<body>\n<div id=\"panorama\"></div>\n\n<script type=\"text/javascript\">\n    //全景图展示\n    //  谷歌获取的经纬度      40.05867366972477----------------116.33668634275229\n\n    //            谷歌地图：40.0601398850,116.3434224706\n    //            百度地图：40.0658210000,116.3500430000\n    //            腾讯高德：40.0601486487,116.3434373643\n//    var jd=116.336686;\n//    var wd=40.058673;\n\n    var jd=116.350043;\n    var wd=40.065821;\n\n    var panorama = new BMap.Panorama('panorama');\n    panorama.setPosition(new BMap.Point(jd, wd)); //根据经纬度坐标展示全景图\n    panorama.setPov({heading: -40, pitch: 6});\n\n    panorama.addEventListener('position_changed', function(e){ //全景图位置改变后，普通地图中心点也随之改变\n        var pos = panorama.getPosition();\n        map.setCenter(new BMap.Point(pos.lng, pos.lat));\n        marker.setPosition(pos);\n    });\n//    //普通地图展示\n//    var mapOption = {\n//        mapType: BMAP_NORMAL_MAP,\n//        maxZoom: 18,\n//        drawMargin:0,\n//        enableFulltimeSpotClick: true,\n//        enableHighResolution:true\n//    }\n//    var map = new BMap.Map(\"normal_map\", mapOption);\n//    var testpoint = new BMap.Point(jd, wd);\n//    map.centerAndZoom(testpoint, 18);\n//    var marker=new BMap.Marker(testpoint);\n//    marker.enableDragging();\n//    map.addOverlay(marker);\n//    marker.addEventListener('dragend',function(e){\n//                panorama.setPosition(e.point); //拖动marker后，全景图位置也随着改变\n//                panorama.setPov({heading: -40, pitch: 6});}\n//    );\n</script>\n</body>\n</html>\n```"}],"metadata":{"title":"10-HTML5详解（二）","publish":true},"filePath":"docs/guide/guid/html/09-HTML5详解（二）.md"}
{"messages":[{"role":"user","content":"开启/关闭全屏显示"},{"role":"assistant","content":"方法如下：（注意 screen 是小写）\n```javascript\n\trequestFullscreen()   //让元素开启全屏显示\n\n\tcancleFullscreen()    //让元素关闭全屏显示\n```\n为考虑兼容性问题，不同的浏览器需要 ，添加私有前缀，比如：（注意 screen 是大写）\n```javascript\n\twebkitRequestFullScreen\n\t webkitCancleFullScreen\n\n\tmozRequestFullScreen\n\tmozCancleFullScreen\n```"}],"metadata":{"title":"10-HTML5详解（二）","publish":true},"filePath":"docs/guide/guid/html/09-HTML5详解（二）.md"}
{"messages":[{"role":"user","content":"检测当前是否处于全屏状态"},{"role":"assistant","content":"方法如下：\n```\n\tdocument.fullScreen\n```\n不同浏览器需要加私有前缀，比如：\n```javascript\n     document.webkitIsFullScreen\n\n     document.mozFullScreen\n```"}],"metadata":{"title":"10-HTML5详解（二）","publish":true},"filePath":"docs/guide/guid/html/09-HTML5详解（二）.md"}
{"messages":[{"role":"user","content":"全屏的伪类"},{"role":"assistant","content":"比如说，当元素处于全屏状态时，改变它的样式。这时就可以用到伪类。"}],"metadata":{"title":"10-HTML5详解（二）","publish":true},"filePath":"docs/guide/guid/html/09-HTML5详解（二）.md"}
{"messages":[{"role":"user","content":"代码举例"},{"role":"assistant","content":"```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n    <style>\n        .box {\n            width: 250px;\n            height: 250px;\n            background-color: green;\n            margin: 100px auto;\n            border-radius: 50%;\n        }\n\n        /*全屏伪类：当元素处于全屏时，改变元素的背景色*/\n        .box:-webkit-full-screen {\n            background-color: red;\n        }\n    </style>\n</head>\n<body>\n<div class=\"box\"></div>\n\n<script>\n    var box = document.querySelector('.box');\n    // box.requestFullscreen();   //直接这样写是没有效果的。之所以无效，应该是浏览器的机制，必须要点一下才可以实现全屏功能。\n    document.querySelector('.box').onclick = function () {\n        // 开启全屏显示的兼容写法\n        if (box.requestFullscreen) {  //如果支持全屏，那就让元素全屏\n            box.requestFullscreen();\n        } else if (box.webkitRequestFullScreen) {\n            box.webkitRequestFullScreen();\n        } else if (box.mozRequestFullScreen) {\n            box.mozRequestFullScreen();\n        }\n\n    }\n</script>\n</body>\n</html>\n```\n效果如下："}],"metadata":{"title":"10-HTML5详解（二）","publish":true},"filePath":"docs/guide/guid/html/09-HTML5详解（二）.md"}
{"messages":[{"role":"user","content":"Web"},{"role":"assistant","content":"Web（World Wide Web）即全球广域网，也称为万维网。\n我们常说的 就是网页端。"}],"metadata":{"title":"01-认识Web和Web标准","publish":true},"filePath":"docs/guide/guid/html/01-认识Web和Web标准.md"}
{"messages":[{"role":"user","content":"网页"},{"role":"assistant","content":"。网页主要由文字、图像和超链接等元素构成。当然，除了这些元素，网页中还可以包含音频、视频以及Flash等。\n我们在浏览器上输入网址后，打开的任何一个页面，都是属于网页。"}],"metadata":{"title":"01-认识Web和Web标准","publish":true},"filePath":"docs/guide/guid/html/01-认识Web和Web标准.md"}
{"messages":[{"role":"user","content":"浏览器"},{"role":"assistant","content":"浏览器是网页运行的平台，常见的浏览器有谷歌（Chrome）、Safari、火狐（Firefox）、IE、Edge、Opera等。\n关于浏览器的详细介绍，可以看下一篇文章：《浏览器的介绍》。"}],"metadata":{"title":"01-认识Web和Web标准","publish":true},"filePath":"docs/guide/guid/html/01-认识Web和Web标准.md"}
{"messages":[{"role":"user","content":"W3C组织"},{"role":"assistant","content":"：World Wide Web Consortium，万维网联盟组织，用来制定web标准的机构（组织）。\nW3C 万维网联盟是国际最著名的标准化组织。1994年成立后，至今已发布近百项相关万维网的标准，对万维网发展做出了杰出的贡献。\nW3C 组织就类似于现实世界中的联合国。\n为什么要遵循WEB标准呢？因为很多浏览器的浏览器内核不同，导致页面解析出来的效果可能会有差异，给开发者增加无谓的工作量。因此需要指定统一的标准。"}],"metadata":{"title":"01-认识Web和Web标准","publish":true},"filePath":"docs/guide/guid/html/01-认识Web和Web标准.md"}
{"messages":[{"role":"user","content":"Web 标准"},{"role":"assistant","content":"：制作网页要遵循的规范。\nWeb标准不是某一个标准，而是由W3C组织和其他标准化组织制定的一系列标准的集合。\n：\n根据上面的Web标准，可以将 Web前端分为三层，如下。\n：\n：（拿黄渤举例）\nHTML 相当于人的身体组织结构：\n\nCSS 相当于人的衣服和打扮：\n\nJS 相当于人的行为："}],"metadata":{"title":"01-认识Web和Web标准","publish":true},"filePath":"docs/guide/guid/html/01-认识Web和Web标准.md"}
{"messages":[{"role":"user","content":"justify-self 属性、align-self 属性以及 place-self 属性"},{"role":"assistant","content":"属性设置单元格内容的水平位置（左中右），跟 属性的用法完全一致，但只作用于单个项目\n属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致\njustify-content,align-content也能生效\ngrid 布局简写row在前\n```\ngrid = \n  <'grid-template'>                                   |\n  <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>?  |\n  [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>  \n```"}],"metadata":{},"filePath":"docs/guide/css/grid.md"}
{"messages":[{"role":"user","content":"1.1  grid-template-columns"},{"role":"assistant","content":"每一位数字都代表当前列；  grid-template-columns: 1fr 2fr 1fr;3列，中间一列代表2等分列；fr代表百分比；repeat()表示网格轨道的重复部分，以一种更简洁的方式去表示大量而且重复列的表达式。"}],"metadata":{},"filePath":"docs/guide/css/grid.md"}
{"messages":[{"role":"user","content":"1.2grid-template-rows"},{"role":"assistant","content":"该属性是基于 的维度，去定义网格线的名称和网格轨道的尺寸大小。\n它会根据 grid-template-columns多退少补"}],"metadata":{},"filePath":"docs/guide/css/grid.md"}
{"messages":[{"role":"user","content":"1.3repeat"},{"role":"assistant","content":"```\n/* <track-repeat> values */\nrepeat(4, [col-start] 1fr [col-end])\n在子元素中设置grid-column-start开始位置column\n在子元素中设置grid-column-end结束位置column\n在子元素中设置grid-row-start开始位置row\n在子元素中设置grid-row-end结束位置row\n```\n\n代表占据网格轨道的网格项目所分配的最大内容区域的最大值。\n\n代表占据网格轨道的网格项目所分配的最小内容区域的最小值。\n\n作为最大值，等同于 。作为最小值，它代表占据网格轨道的网格项目的最小尺寸的最大值（如同 / 所指定的)）。\n\n如果网格容器在相关轴上具有确定的大小或最大大小，则重复次数是最大可能的正整数，不会导致网格溢出其网格容器。如果定义了，将每个轨道视为其最大轨道尺寸大小函数 ( 或 用于定义的每个独立值。否则，作为最小轨道尺寸函数，将网格间隙加入计算。如果重复次数过多，那么重复值是 。否则，如果网格容器在相关轴上具有确定的最小尺寸，重复次数是满足该最低要求的可能的最小正整数。否则，指定的轨道列表仅重复一次。\n\n行为与 相同，除了放置网格项目后，所有空的重复轨道都将折叠。空轨道是指没有流入网格或跨越网格的网格项目。（如果所有轨道都为空，则可能导致所有轨道被折叠。）\n折叠的轨道被视为具有单个固定轨道大小函数为 ，两侧的槽都折叠了。\n为了找到自动重复的轨道数，用户代理将轨道大小限制为用户代理指定的值（例如 ），以避免被零除。\n注：如果有剩余空间的话， 会创建额外的空列。而 则以最后一个 Gird 项目结束 Gird 容器，不管是否还有额外的空间存在。"}],"metadata":{},"filePath":"docs/guide/css/grid.md"}
{"messages":[{"role":"user","content":"1.4gap"},{"role":"assistant","content":"用于设置行与列之间的间隙（ ）。\n规范的早期版本将该属性命名为 ，且为了保持与旧网站的兼容性，浏览器仍然会接受 作为 的别名。"}],"metadata":{},"filePath":"docs/guide/css/grid.md"}
{"messages":[{"role":"user","content":"1.5grid-area"},{"role":"assistant","content":"CSS 属性 是一种对于 、 、 和 的简写，通过基线（line），跨度（span）或没有（自动）的网格放置在 中指定一个网格项的大小和位置，继而确定 的边界。"}],"metadata":{},"filePath":"docs/guide/css/grid.md"}
{"messages":[{"role":"user","content":"1.6网格行grid-column-start， grid-column-end   注 再整理"},{"role":"assistant","content":"列之间的线称为列线，行之间的线称为行线，如果三条列线三条行线会组成6个网格\n如需放置某个项目，您可以引用行号（line numbers），或使用关键字 \"span\" 来定义该项目将跨越多少列。\n给第一个item 添加类item1，从第一列线开始第三列线结束，说明item1此时占据两个网格项的长度， 此时界面就会变成。\n.item1 {\ngrid-column-start: 1;\ngrid-column-end: 3;\n//也可以写成\ngrid-column: 1 / 3;\n}\n//等价于\n.item1{\ngrid-column: 1 / span 2;//表示从第一列开始  占两格  相当于从第1列开始 第3列结束\n}"}],"metadata":{},"filePath":"docs/guide/css/grid.md"}
{"messages":[{"role":"user","content":"1.7grid-area属性"},{"role":"assistant","content":"grid-area属性可以用作 grid-row-start、grid-column-start、grid-row-end 和 grid-column-end 属性的简写属性。\n.item1 {\n//列线从第一条到第三条，行线从第一条到第三条\ngrid-area: 1 / 1 / 3 / 3;\n}\n这个是命名"}],"metadata":{},"filePath":"docs/guide/css/grid.md"}
{"messages":[{"role":"user","content":"1.8grid-template-areas"},{"role":"assistant","content":"grid-template-areas 属性在网格布局中规定区域。您可以使用 grid-area 属性命名网格项目，然后在 grid-template-areas 属性中引用该名称。\n这个是使用\n//基线参考资料"}],"metadata":{},"filePath":"docs/guide/css/grid.md"}
{"messages":[{"role":"user","content":"1.9grid-auto-flow"},{"role":"assistant","content":"属性控制着自动布局算法怎样运作，精确指定在网格中被自动布局的元素怎样排列。\n```\ngrid-auto-flow: row;\ngrid-auto-flow: column;\ngrid-auto-flow: dense;\ngrid-auto-flow: row dense;\ngrid-auto-flow: column dense;\n```\n\n该关键字指定自动布局算法按照通过逐行填充来排列元素，在必要时增加新行。如果既没有指定 也没有 ，则默认为 。\n\n该关键字指定自动布局算法通过逐列填充来排列元素，在必要时增加新列。\n\n该关键字指定自动布局算法使用一种“稠密”堆积算法，如果后面出现了稍小的元素，则会试图去填充网格中前面留下的空白。这样做会填上稍大元素留下的空白，但同时也可能导致原来出现的次序被打乱。\n如果省略它，使用一种「稀疏」算法，在网格中布局元素时，布局算法只会「向前」移动，永远不会倒回去填补空白。这保证了所有自动布局元素「按照次序」出现，即使可能会留下被后面元素填充的空白。"}],"metadata":{},"filePath":"docs/guide/css/grid.md"}
{"messages":[{"role":"user","content":"2.0grid-auto-rows"},{"role":"assistant","content":"属性为网格容器中的行设置尺寸。\n该属性只会影响未设置尺寸的行。\n：显式网格包含了你在 和 属性中定义的行和列。如果你在网格定义之外又放了一些东西，或者因为内容的数量而需要的更多网格轨道的时候，网格将会在隐式网格中创建行和列\n假如有多余的网格（也就是上面提到的隐式网格），那么它的行高和列宽可以根据 属性和 属性设置。它们的写法和 和 完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行"}],"metadata":{},"filePath":"docs/guide/css/grid.md"}
{"messages":[{"role":"user","content":"2.1grid-template"},{"role":"assistant","content":"所简写属性： 、 与\n以/分割 前面的每一行代表实际的一行基线分布情况 后面的值是row的值 values\n/后面的就是整体column的分布情况\n```css\n#page {\n  display: grid;\n  width: 100%;\n  height: 200px;\n  grid-template:\n \"head head\" 30px\n   \"nav  main\" 1fr \n   \"nav  foot\" 30px \n    / 200px 300px;\n}\n```"}],"metadata":{},"filePath":"docs/guide/css/grid.md"}
{"messages":[{"role":"user","content":"1、生成数组"},{"role":"assistant","content":"首先，设置一个储存宽高的数组，名称rect,将这个储存宽高的数组，可以通过x*y得出所有内部分割方块的坐标；\n```js\n    let rect = [5, 5];\n    let side = 495 / 5;\n    let arr = Array.from({ length: rect[0] }, (_, x) => {\n      return Array.from({ length: rect[1] }, (_, y) => {\n        return {\n          visited: false,\n          axis: [x, y],\n          path: [true, true, true, true]\n        }\n      })\n    })\n```\n通过Array.from 设置类数组对象转化为多维数组，以此得到每一个位置的坐标"}],"metadata":{},"filePath":"docs/guide/js/js迷宫.md"}
{"messages":[{"role":"user","content":"2、编辑canvas绘画方法"},{"role":"assistant","content":"```js\n let myCanvas = document.getElementById(\"myCanvas\");\n    let ctx = myCanvas.getContext(\"2d\");\n    let draw = {\n      top ([x, y]) {\n        ctx.moveTo(x * side, y * side);\n        ctx.lineTo((x + 1) * side, y * side);\n        ctx.stroke();\n      },\n      right ([x, y]) {\n        ctx.moveTo((x + 1) * side, y * side);\n        ctx.lineTo((x + 1) * side, (y + 1) * side);\n        ctx.stroke();\n      },\n      bottom ([x, y]) {\n        ctx.moveTo((x + 1) * side, (y + 1) * side);\n        ctx.lineTo((x) * side, (y + 1) * side);\n        ctx.stroke();\n      },\n      left ([x, y]) {\n        ctx.moveTo((x) * side, (y + 1) * side);\n        ctx.lineTo((x) * side, (y) * side);\n        ctx.stroke();\n      }\n    }\n    \n     arr.forEach(arrIndex => {\n      arrIndex.forEach(item => {\n\n        if (item.path[0]) draw.top(item.axis)\n        if (item.path[1]) draw.right(item.axis)\n        if (item.path[2]) draw.bottom(item.axis)\n        if (item.path[3]) draw.left(item.axis)\n      })\n    })\n```\n获取canvas，思路是通过对每一个分割出来的方块画出其边长，形成一个x*y的宫格，然后对其拆除墙体，实现迷宫\n画出方块的对象方法，是根据上右下左来进行书写的,最后通过两轮循环，对所有的位置进行绘画。path 如果为false就代表不需要绘画，path数据初始化为[true,true,true,true],后续对其进行修改，以做到分割单元格的目的"}],"metadata":{},"filePath":"docs/guide/js/js迷宫.md"}
{"messages":[{"role":"user","content":"3-1、设置初始位置"},{"role":"assistant","content":"我们选择[0,0]作为初始位置开始生成\n```js\n    let current = { axis: [0, 0], dir: undefined };\n      arr[0][0].visited = true;\n```"}],"metadata":{},"filePath":"docs/guide/js/js迷宫.md"}
{"messages":[{"role":"user","content":"3-2、寻找可选方向"},{"role":"assistant","content":"寻找四个方向，如果到墙壁就返回，如果被访问过的也返回，我们的目的是将所有没有返回过的数组进行操作，并记录他相对于初始位置的方向，便于消除墙壁\n```js\n    function find_position ([x, y], dir) {\n\n      switch (dir) {\n        case 0:\n          if (y - 1 < 0) return\n          if (arr[x][y - 1].visited) return\n          return { axis: [x, y - 1], dir }\n        case 1:\n          if (x + 1 >= rect[0]) return\n          if (arr[x + 1][y].visited) return\n          return { axis: [x + 1, y], dir }\n        case 2:\n          if (y + 1 >= rect[1]) return\n          if (arr[x][y + 1].visited) return\n          return { axis: [x, y + 1], dir }\n        case 3:\n          if (x - 1 < 0) return\n          if (arr[x - 1][y].visited) return\n          return { axis: [x - 1, y], dir }\n      }\n    }\n```"}],"metadata":{},"filePath":"docs/guide/js/js迷宫.md"}
{"messages":[{"role":"user","content":"3-3、将可选方向作为数组返回"},{"role":"assistant","content":"[0,1,2,3]分别对应上右下左,存在能进行下一步操作的元素才进行收集\n```js\n    function find_neighbor ([x, y]) {\n      let res = []\n      let top = find_position([x, y], 0);\n      let right = find_position([x, y], 1);\n      let bottom = find_position([x, y], 2);\n      let left = find_position([x, y], 3);\n      if (top) res.push(top);\n      if (right) res.push(right);\n      if (bottom) res.push(bottom);\n      if (left) res.push(left);\n      return res\n    }\n```"}],"metadata":{},"filePath":"docs/guide/js/js迷宫.md"}
{"messages":[{"role":"user","content":"3-4、随机当前元素的可选地址于上一个元素的墙壁进行联通"},{"role":"assistant","content":"```js\n       let random = Math.floor(Math.random() * find_res.length);\n        clear_rect(current, find_res[random]);\n```\n消除墙壁,当下一个元素和当前元素的墙壁消掉后，将其可访问值设置为true，使其下一次不会被选中\n```js\n    function clear_rect (now_pos, next_pos) {\n      let now = arr[now_pos.axis[0]][now_pos.axis[1]];\n\n      let next = arr[next_pos.axis[0]][next_pos.axis[1]];\n      next.visited = true\n\n      switch (next_pos.dir) {\n        case 0:\n          next.path[2] = false\n          now.path[0] = false;\n          break;\n        case 1:\n          next.path[3] = false;\n          now.path[1] = false;\n          break;\n        case 2:\n          now.path[2] = false;\n          next.path[0] = false\n          break;\n        case 3:\n          next.path[1] = false;\n          now.path[3] = false;\n          break;\n      }\n```"}],"metadata":{},"filePath":"docs/guide/js/js迷宫.md"}
{"messages":[{"role":"user","content":"3-5、使用堆栈对其进行遍历"},{"role":"assistant","content":"```js\n    function create_maze (arr) {\n      let current = { axis: [0, 0], dir: undefined };\n      arr[0][0].visited = true;\n      let stack = [current]\n      while (stack.length > 0) {\n        let find_res = find_neighbor(current.axis);\n        if (find_res.length > 0) {\n\n          let random = Math.floor(Math.random() * find_res.length);\n          clear_rect(current, find_res[random]);\n\n          current = find_res[random];\n          stack.push(current);\n        } else {\n          current = stack.pop()\n        }\n      }\n\n    }\n```\n设置一个初始位置为初始栈，只要当前栈还有可选位置元素，就会对当前位置进行四个边的查找，没有对应的元素就会让其退出栈，直到所有元素都被访问过，才会退出循环，我们查找到下一次的边如果还存在可选边就会将其加入栈内，如果随机到一个位置恰好四个边都被访问，但还没有完全遍历整个迷宫，我们就会将其出栈，使其作为新的可选位置元素，使用pop出栈，他会从最后一位元素开始重新查找"}],"metadata":{},"filePath":"docs/guide/js/js迷宫.md"}
{"messages":[{"role":"user","content":"本文主要内容"},{"role":"assistant","content":"排版标签：\n下面来详细介绍一下排版标签。"}],"metadata":{"title":"04-HTML标签：排版标签","publish":true},"filePath":"docs/guide/guid/html/03-HTML标签：排版标签.md"}
{"messages":[{"role":"user","content":"标题标签"},{"role":"assistant","content":"标题使用 至 标签进行定义。 定义最大的标题， 定义最小的标题。具有align属性，属性值可以是：left、center、right。\n代码举例：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\t<title>Document</title>\n</head>\n<body>\n\t<h1>H1：千古壹号，永不止步</h1>\n\t<h2>H3：千古壹号，永不止步</h2>\n\t<h3>H3：千古壹号，永不止步</h3>\n\t<h4>H4：千古壹号，永不止步</h4>\n\t<h5>H5：千古壹号，永不止步</h5>\n\t<h6>H6：千古壹号，永不止步</h6>\n</body>\n</html>\n\n```\n效果演示："}],"metadata":{"title":"04-HTML标签：排版标签","publish":true},"filePath":"docs/guide/guid/html/03-HTML标签：排版标签.md"}
{"messages":[{"role":"user","content":"HTML 注释"},{"role":"assistant","content":"HTML 注释的格式如下：\n```html\n<!-- 我是 html 注释  -->\n```"}],"metadata":{"title":"04-HTML标签：排版标签","publish":true},"filePath":"docs/guide/guid/html/03-HTML标签：排版标签.md"}
{"messages":[{"role":"user","content":"段落标签 "},{"role":"assistant","content":"段落，是英语“paragraph“缩写。\n：可以把 HTML 文档分割为若干段落。在网页中如果要把文字有条理地显示出来，离不开段落标签。就如同我们平常写文章一样，整个网页也可以分为若干个段落。\n代码举例：\n```html\n<p>This is a paragraph</p>\n<p>This is another paragraph</p>\n```\n属性：\n属性举例：\n\nHTML标签是分等级的，HTML将所有的标签分为两种：\n从学习p的第一天开始，就要牢牢记住： 。其他的一律不能放。\n错误写法：（尝试把 h 放到 p 里）\n```html\n\t<p>\n\t\t我是一个小段落\n\t\t<h1>我是一级标题</h1>\n\t</p>\n```\n网页效果如下：\n\n上图显示，浏览器不允许你这么做，我们使用Chrome的F12审查元素发现，浏览器自己把p封闭掉了，不让你去包裹h1。\nPS：Chrome浏览器是HTML5支持度最好的浏览器。提供了非常好的开发工具，非常适合我们开发人员使用。审查元素功能的快捷键是F12。"}],"metadata":{"title":"04-HTML标签：排版标签","publish":true},"filePath":"docs/guide/guid/html/03-HTML标签：排版标签.md"}
{"messages":[{"role":"user","content":"水平线标签 "},{"role":"assistant","content":"水平分隔线（horizontal rule）可以在视觉上将文档分隔成各个部分。在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。\n代码举例：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\t<title>Document</title>\n</head>\n<body>\n\t<p>自古情深留不住</p>\n\t<hr />\n\t<p>总是套路得人心</p>\n</body>\n</html>\n```\n运行效果：\n\n属性介绍：\n属性效果演示："}],"metadata":{"title":"04-HTML标签：排版标签","publish":true},"filePath":"docs/guide/guid/html/03-HTML标签：排版标签.md"}
{"messages":[{"role":"user","content":"换行标签 "},{"role":"assistant","content":"如果希望某段文本强制换行显示，就需要使用换行标签。\n```html\nThis <br/> is a para<br/>graph with line breaks\n```\n效果如下："}],"metadata":{"title":"04-HTML标签：排版标签","publish":true},"filePath":"docs/guide/guid/html/03-HTML标签：排版标签.md"}
{"messages":[{"role":"user","content":"和 标签"},{"role":"assistant","content":"div和span是非常重要的标签，div的语义是division“分割”； span的语义就是span“范围、跨度”。想必你应该听说过“div + css”布局。"}],"metadata":{"title":"04-HTML标签：排版标签","publish":true},"filePath":"docs/guide/guid/html/03-HTML标签：排版标签.md"}
{"messages":[{"role":"user","content":"div和span的介绍"},{"role":"assistant","content":"代码举例：\n\ndiv标签的属性："}],"metadata":{"title":"04-HTML标签：排版标签","publish":true},"filePath":"docs/guide/guid/html/03-HTML标签：排版标签.md"}
{"messages":[{"role":"user","content":"div和span的区别"},{"role":"assistant","content":"和 唯一的区别在于： 是不换行的，而 是换行的。\n如果单独在网页中插入这两个元素，不会对页面产生任何的影响。这两个元素是专门为定义CSS样式而生的。或者说，DIV+CSS来实现各种样式。\ndiv在浏览器中，默认是不会增加任何的效果的，但是语义变了，div中的所有元素是一个小区域。\ndiv标签是一个 标签，里面什么都能放，甚至可以放div自己。\nspan也是表达“小区域、小跨度”的标签，但只是一个 的标签。\n就是说，span里面只能放置文字、图片、表单元素。 span里面不能放p、h、ul、dl、ol、div。\nspan举例：\n```html\n<p>\n\t简介简介简介简介简介简介简介简介\n\t<span>\n\t\t<a href=\"\">详细信息</a>\n\t\t<a href=\"\">购买</a>\n\t</span>\n</p>\n\n```\ndiv举例：\n```html\n<div class=\"header\">\n\t<div class=\"logo\"></div>\n\t<div class=\"nav\"></div>\n</div>\n<div class=\"content\">\n\t<div class=\"guanggao\"></div>\n\t<div class=\"dongxi\"></div>\n</div>\n<div class=\"footer\"></div>\n```\n我们亲切地称这种模式叫做“ ”： 。"}],"metadata":{"title":"04-HTML标签：排版标签","publish":true},"filePath":"docs/guide/guid/html/03-HTML标签：排版标签.md"}
{"messages":[{"role":"user","content":"内容居中标签 "},{"role":"assistant","content":"此时center代表是一个标签，而不是一个属性值了。只要是在这个标签里面的内容，都会居于浏览器的中间。\n效果演示：\n\n到了HTML5里面，center标签不建议使用，建议使用css布局来实现。"}],"metadata":{"title":"04-HTML标签：排版标签","publish":true},"filePath":"docs/guide/guid/html/03-HTML标签：排版标签.md"}
{"messages":[{"role":"user","content":"预定义（预格式化）标签 "},{"role":"assistant","content":"含义：将保留标签内部所有的空白字符(空格、换行符)，原封不动地输出结果（告诉浏览器不要忽略空格和空行）。\n说明：真正排网页过程中， 标签几乎用不着。\n效果演示："}],"metadata":{"title":"04-HTML标签：排版标签","publish":true},"filePath":"docs/guide/guid/html/03-HTML标签：排版标签.md"}
{"messages":[{"role":"user","content":"首先 我们先下载谷歌"},{"role":"assistant","content":"谷歌浏览器官网下载地址"}],"metadata":{},"filePath":"docs/guide/guid/tool/谷歌浏览器.md"}
{"messages":[{"role":"user","content":"常见的浏览器"},{"role":"assistant","content":"浏览器是网页运行的平台，常见的浏览器有谷歌（Chrome）、Safari、火狐（Firefox）、IE、Edge、Opera 等。如下图所示：\n\n我们重点需要学习的是 Chrome 浏览器。"}],"metadata":{},"filePath":"docs/guide/guid/tool/谷歌浏览器.md"}
{"messages":[{"role":"user","content":"浏览器的市场占有份额"},{"role":"assistant","content":"浏览器的市场占有份额：\n\n上面这张图的统计时间是 2020 年 2 月。"}],"metadata":{},"filePath":"docs/guide/guid/tool/谷歌浏览器.md"}
{"messages":[{"role":"user","content":"浏览器的组成"},{"role":"assistant","content":"浏览器分成两部分："}],"metadata":{},"filePath":"docs/guide/guid/tool/谷歌浏览器.md"}
{"messages":[{"role":"user","content":"1、渲染引擎（浏览器内核）"},{"role":"assistant","content":"浏览器所采用的「渲染引擎」也称之为「浏览器内核」，用于解析 HTML 和 CSS、布局、渲染等工作。渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。\n\n渲染引擎的英文叫做 Rendering Engine。通俗来说，它的作用就是：读取网页内容，计算网页的显示方式并显示在页面上。\n常见浏览器的内核如下：\n备注：360 的浏览器，以前使用的 IE 浏览器的 Trident 内核，但是现在已经改为使用 chrome 浏览器的 Blink 内核。\n另外，移动端的浏览器内核是什么？大家可以自行查阅资料。"}],"metadata":{},"filePath":"docs/guide/guid/tool/谷歌浏览器.md"}
{"messages":[{"role":"user","content":"2、JS 引擎"},{"role":"assistant","content":"也称为 JS 解释器。 用来解析和执行网页中的 JavaScript 代码。\n浏览器本身并不会执行 JS 代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时会逐行解释每一句源码，转换为机器语言，然后由计算机去执行。\n常见浏览器的 JS 引擎如下：\n补充说明：\n1、SpiderMonkey 是第一款 JavaScript 引擎，由 JS 语言的作者 Brendan Eich 开发。\n2、先以 WebKit 为例，WebKit 上由两部分组成：\n参考链接："}],"metadata":{},"filePath":"docs/guide/guid/tool/谷歌浏览器.md"}
{"messages":[{"role":"user","content":"浏览器工作原理"},{"role":"assistant","content":"浏览器主要由下面这个七个部分组成：\n\n1、User Interface（UI 界面）：包括地址栏、前进/后退按钮、书签菜单等。也就是浏览器主窗口之外的其他部分。\n2、Browser engine （浏览器引擎）：用来查询和操作渲染引擎。是 UI 界面和渲染引擎之间的 。\n3、Rendering engine（渲染引擎）：用于解析 HTML 和 CSS，并将解析后的内容显示在浏览器上。\n4、Networking （网络模块）：用于发送网络请求。\n5、JavaScript Interpreter（JavaScript 解析器）：用于解析和执行 JavaScript 代码。\n6、UI Backend（UI 后端）：用于绘制组合框、弹窗等窗口小组件。它会调用操作系统的 UI 方法。\n7、Data Persistence（数据存储模块）：比如数据存储 cookie、HTML5 中的 localStorage、sessionStorage。\n参考链接：（关于浏览器的工作管理，下面这篇文章，是精品中的精品，是必须要知道的）"}],"metadata":{},"filePath":"docs/guide/guid/tool/谷歌浏览器.md"}
{"messages":[{"role":"user","content":"为什么选择谷歌浏览器(浏览器内核详解)"},{"role":"assistant","content":"首先给出答案，因为大多浏览器使用的都是 webkit 内核，我们为了代码能兼容更多的平台，所以有限选择谷歌浏览器"}],"metadata":{},"filePath":"docs/guide/guid/tool/谷歌浏览器.md"}
{"messages":[{"role":"user","content":"总结国内厂商内核来看，一般为三类："},{"role":"assistant","content":"一、使用的 Trident 单核，如：2345、 ；\n二、使用 Trident+Webkit/Blink 双核，如：qq、UC、猎豹、360、百度；\n三、使用 Webkit/Blink 单核，如：搜狗、 。\n双核浏览器通过 WebKit 内核来访问一些不需要进行网上交易的网站，使用起来速度更快更方便; 在进行支付系统或者是网上银行的访问时，则使用的是 Trident 内核。这就是双核浏览器的高速模式和兼容模式。双核浏览器是一个不仅仅具有 ie 浏览器内核同时兼容非 ie 浏览器内核的浏览器，可以让用户在浏览器当中体验不同的需求"}],"metadata":{},"filePath":"docs/guide/guid/tool/谷歌浏览器.md"}
{"messages":[{"role":"user","content":"浏览器内核技术"},{"role":"assistant","content":"浏览器内核主要包括以下三个技术分支：排版渲染引擎、 JavaScript 引擎，以及其他。\n微软对排版渲染引擎相关专利的申请最多，达到浏览器内核相关专利申请总量的 93.3%。这与排版渲染引擎的功能密不可分。其主要负责取得网页的内容(HTML、XML、图像等)、整理信息，以及计算网页的显示方式，然后输出至显示器。所有的网页浏览器、 以及其他需要编辑、显示网络内容的应用程序都需要排版渲染引擎，特别是排版渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。由于在网页显示中所起的重要作用，微软一直侧重于涉及排版渲染引擎的专利申请。在 2006 年和 2009 年，配新版本的研发带来了排版渲染引擎专利申请量的顶峰这充分显示了微软在新版本的改进中对浏览器排版渲染引擎技术的重视。\nJavaScript 引擎是用来渲染 JavaScript 的，JavaScript 的渲染速度越快，动态网页的展示也越快。众所周知，微软的 IE 浏览器实现完全支持客户端 JavaScript 语言标准的时间晚于其他浏览器。因此，在这一技术分支下，相较其他浏览器企业而言，微软公司并不具有优势。在 2001~2004 年，在浏览器内核技术分支下，微软的中国专利申请量并不多，方面是由于内核为开放内核，另一方面则是由于 IE 本身一直与 Windows 捆绑销售，使得 Trident 内核长期一家独大，微软很长时间都没有更新 Trident 内核，从而导致 Trident 内核几乎与 W3C 标准脱节。\n2005 年至今，由于 IE 浏览器存在缺陷，从而使得很多用户转向其他浏览器。微软公司显然注意到了这一点，逐步重视浏览器内核的改进升级，并将由此带来的相关专利在中国进行了布局。最明显的是，2006 年和 2009 年的专利申请量大幅上升，其中关于浏览器内核中排版渲染引擎的专利申请均达到了 17 件；在 2008 年还有一件关于 JavaScript 引擎的专利申请，以上均表明 I 内核在 2005 年之后有了明显改进"}],"metadata":{},"filePath":"docs/guide/guid/tool/谷歌浏览器.md"}
{"messages":[{"role":"user","content":"1、渲染-主"},{"role":"assistant","content":"使用 API 发送一条消息，然后由 API 接收该消息\npreload是前后端沟通的桥梁\n渲染进程 => preload => 主进程\n流程\n```js\nmain 主线程文件\nfunction createWindow () {\n  const mainWindow = new BrowserWindow({\n    webPreferences: {\n      preload: path.join(__dirname, 'preload.js')\n    }\n  })//引入preload\n\t//接收子组件传递信息\n  ipcMain.on(channel, (event, args ) => {\n    channel 字符串 从preload中传入的文本\n    event ipc主事件，\n    args 参数\n  })\n//读取html文件\n  mainWindow.loadFile('index.html')\n}\n```\n```js\n//preload.js文件 \ncontextBridge.exposeInMainWorld('electronAPI', {\n  setTitle: (payload) => ipcRenderer.send('set-title', payload)\n})\n//此时，你将能够在渲染器进程中使用 window.electronAPI.setTitle() 函数。\n```\n```js\n//js文件调用\nbtn.addEventListener('click', () => {\n  window.electronAPI.setTitle(payload)\n})\n\n```"}],"metadata":{},"filePath":"docs/guide/electron/electron.md"}
{"messages":[{"role":"user","content":"2、双向"},{"role":"assistant","content":"通过使用 与 配对来完成\n渲染进程=>preload=>ipcRender.invoke=>主线程=>ipcMain.handle返回值=>preload=>渲染进程返回\n```javascript\n//main.js (Main Process)\nipcMain.handle('channel', callback)\n返回值是ipcRender的值\n```\n```js\n//preload.js (Preload Script)\ncontextBridge.exposeInMainWorld('electronAPI', {\n  api: () => ipcRenderer.invoke('dialog:openFile')\n})\n```\n```js\n//renderer.js \nbtn.addEventListener('click', async () => {\n  const filePath = await window.electronAPI.api()\n})\n```"}],"metadata":{},"filePath":"docs/guide/electron/electron.md"}
{"messages":[{"role":"user","content":"3、主线程到渲染器"},{"role":"assistant","content":"消息需要通过渲染器进程的 实例发送到渲染器进程。此 WebContents 实例包含一个 方法，其使用方式与 相同。\n```js\n//main文件\n//窗口创建后会有一个webContens的对象，发送\n mainWindow.webContents.send('channel', payload),\n```\n```js\n//preload\n//接收信息\ncontextBridge.exposeInMainWorld('electronAPI', {\n  handler: (callback) => ipcRenderer.on('channel', (_event, value) => callback(value))\n})\n//接收一个回调，并且传入参数\n```\n```js\n//rendere.js\nwindow.electronAPI.handler(function)\n```"}],"metadata":{},"filePath":"docs/guide/electron/electron.md"}
{"messages":[{"role":"user","content":"1.1 前端的定义"},{"role":"assistant","content":"在我们访问一个网站时，所有能够直接看到、点击、输入和互动的部分，都是由前端来实现的。前端主要是指用户可视界面的开发，包含页面结构、样式、动态效果和互动功能，最终目标是为用户提供友好且美观的交互界面。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/前端是什么.md"}
{"messages":[{"role":"user","content":"1.2 前端的三大核心技术"},{"role":"assistant","content":"前端开发的实现主要依赖以 下三大核心技术：\nHTML（HyperText Markup Language）：前端开发的基础，用于定义网页的结构和内容。HTML 定义了网站的每个元素，如文本、图像、视频、链接等，让网页有“骨架”。\nCSS（Cascading Style Sheets）：用于网页的样式设计，定义 HTML 元素的显示方式，包括颜色、字体、布局等。CSS 让网页更加美观、有层次感。\nJavaScript：赋予网页动态交互功能，使网页可以响应用户操作。比如按钮的点击、表单验证、图片轮播等功能都需要 JavaScript 支持。\n这些技术的结合，让开发者可以构建功能丰富、互动性强的网页。随着前端技术的不断发展，HTML、CSS 和 JavaScript 的应用也越来越广泛和深入。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/前端是什么.md"}
{"messages":[{"role":"user","content":"1.3 前端框架和工具"},{"role":"assistant","content":"为了提升开发效率和用户体验，前端开发衍生出了一系列强大的框架和工具：\n框架和库：如 React、Vue.js、Angular 等，它们提供了大量预设的组件和功能，帮助开发者快速构建复杂的界面。\n预处理器和后处理器：如 Sass、Less（CSS 预处理器）、PostCSS 等，用于提升 CSS 的灵活性和可维护性。\n构建工具：如 Webpack、Parcel 等，用于打包、压缩和优化前端代码，提升网页加载速度。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/前端是什么.md"}
{"messages":[{"role":"user","content":"2.1 后端的定义"},{"role":"assistant","content":"与前端的用户交互界面不同，后端负责应用的业务逻辑、数据处理和管理。后端如同应用的“后台”，用户无法直接看到，但它负责网站或应用的核心功能和数据流转。后端的职责是确保数据存储安全、业务逻辑运行流畅，并根据请求将数据发送给前端。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/前端是什么.md"}
{"messages":[{"role":"user","content":"2.2 后端的组成要素"},{"role":"assistant","content":"后端主要由以下几个部分构成：\n服务器：为用户提供数据和计算资源的设备，托管网站和应用。服务器接收前端发送的请求，并根据业务逻辑返回相应的数据。\n数据库：用于存储和管理应用数据的系统，常见的数据库有 MySQL、MongoDB、PostgreSQL 等。数据库将结构化的或非结构化的数据保存下来，以便随时查询和更新。\n服务器端编程语言：用于编写业务逻辑代码，将应用的需求转化为功能，常见的后端语言有 Java、Python、PHP、Ruby、Node.js 等。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/前端是什么.md"}
{"messages":[{"role":"user","content":"2.3 后端框架和工具"},{"role":"assistant","content":"为了提升开发效率和代码的稳定性，后端开发者通常使用各种框架和工具：\n后端框架：如 Express（基于 Node.js）、Django（基于 Python）、Laravel（基于 PHP）等，这些框架提供了丰富的工具和功能，加速开发并提升代码的可维护性。\nAPI：应用程序接口（API）是前后端沟通的桥梁，常见的 API 技术包括 RESTful API 和 GraphQL，通过这些接口，前端可以请求数据，而后端负责返回所需的数据。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/前端是什么.md"}
{"messages":[{"role":"user","content":"3.前后端的区别"},{"role":"assistant","content":"了解了前端和后端的概念后，我们再来深入探讨一下两者的区别。前端和后端分别处理不同的任务，它们相辅相成，共同构成了一个完整的应用。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/前端是什么.md"}
{"messages":[{"role":"user","content":"4.什么是前后端分离？"},{"role":"assistant","content":"在了解了前后端的区别后，现代 Web 开发中越来越强调的“前后端分离”概念就很容易理解了。前后端分离意味着前端和后端各自独立开发、部署和维护，两者通过 API 进行数据交换。这种开发模式带来了很多好处"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/前端是什么.md"}
{"messages":[{"role":"user","content":"4.1 前后端耦合与前后端分离"},{"role":"assistant","content":"传统前后端耦合方式：早期的 Web 开发中，前端页面和后端逻辑紧密耦合在一起。每当用户请求一个页面，服务器会先处理业务逻辑，将数据填充到 HTML 模板中生成页面，再返回给浏览器。这种方式虽然简单，但页面每次请求都需要刷新，体验不佳。 浏览器的展示是由后端来决定的 其实就是服务器决定的。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/前端是什么.md"}
{"messages":[{"role":"user","content":"4.3 前后端分离的实现方式"},{"role":"assistant","content":"RESTful API：通过 REST 风格的接口，前端可以按需请求资源，如 CRUD（增删查改）操作，非常适合大部分 Web 应用。\nGraphQL：一种灵活的查询语言，让前端可以按需请求数据字段，减少了冗余数据的传输，适合复杂应用的数据请求。\n前端：用户访问一个在线商城，页面的商品展示和购物车动态更新，这些交互由前端处理。用户点击商品、添加到购物车等操作会触发 JavaScript 动作，并通过 Axios 发送请求。\n后端：接收到请求后，后端服务器查询数据库，返回商品数据。后端还负责处理库存管理、支付逻辑等，确保商品库存与订单信息准确无误。\n通过 API，前端可以迅速获取最新的商品信息，局部刷新商品列表，不需要刷新整个页面，提升了购物体验。\n总结\n前端：定义页面结构、样式和交互，让用户看到并与应用互动的部分。\n后端：负责业务逻辑和数据处理，确保应用核心功能的正常运行。\n前后端分离：是一种现代化开发模式，通过 API 将前端与后端分离，提升开发效率和用户体验。\n通过深入了解前端、后端及前后端分离的概念，希望你能对 Web 开发的整体架构有更系统的认识。接下来的学习中，我们将带你进一步了解前端开发的具体技术，实现从零到项目开发的顺利过渡"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/前端是什么.md"}
{"messages":[{"role":"user","content":"VS Code"},{"role":"assistant","content":"VS Code 软件实在是太酷、太好用了，越来越多的新生代互联网民工正在使用它。\n前端男神 大大这样评价 VS Code：\n\n有一点你可能会感到惊讶：VS Code 这款软件本身，是用 JavaScript 语言编写的（具体请自行查阅基于 JS 的 PC 客户端开发框架 ）。Jeff Atwood 在 2007 年提出了著名的 Atwood 定律：\nJeff Atwood 这个人是谁不重要（他是 Stack Overflow 网站的联合创始人），重要的是这条定律。\n前端目前是处在春秋战国时代，各路英雄豪杰成为后浪，各种框架工具层出不穷，VS Code 软件无疑是大前端时代最骄傲的工具。\n如果你是做前端开发（JavaScript 编程语言为主），则完全可以将 VS Code 作为「 」。这款软件是为前端同学量身定制的，开箱即用。\n如果你是做其他语言方向的开发，并且不需要太复杂的集成开发环境，那么，你可以把 VS Code 作为「 」来使用，纵享丝滑。\n甚至是一些写文档、写作的同学，也经常把 VS Code 作为 markdown ，毫无违和感。\n退而求其次，即便你不属于以上任何范畴，你还可以把 VS Code 当作最简单的 来使用，完胜 Windows 系统自带的记事本。\n写下这篇文章，是顺势而为。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"一、惊艳登场：VS Code 的介绍"},{"role":"assistant","content":"VS Code 的全称是 Visual Studio Code，是一款开源的、免费的、跨平台的、高性能的、轻量级的代码编辑器。它在性能、语言支持、开源社区方面，都做得很不错。\n微软有两种软件：一种是 VS Code，一种是其他软件。\n在2015年4月29日的微软Build开发者大会上，微软宣布推出 VS Code之后，这个轻量级的编辑器成为全球无数开发者们最喜爱的开发工具。VS Code基于开源且跨平台的理念，每月都会进行迭代，并提供每天发布的 insider 版本（insider是微软的一种公测计划，类似于国内软件所说的内测版）。它拥有至少几万个插件，生态极为活跃和丰富。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"IDE 与 编辑器的对比"},{"role":"assistant","content":"IDE 和编辑器是有区别的：\n需要注意的是，VS Code 的定位是 ，而非 IDE ，但 VS Code 又比一般的编辑器的功能要丰富许多。可以这样理解：VS Code 的体量是介于编辑器和 IDE 之间。VS Code 的使命，是让开发者在编辑器里拥有 IDE 那样的开发体验。\nVS Code流行起来之后，使用 Sublime Text、Atom 这类编辑器软件的人，自然就越来越少了。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"前端利器之争： VS Code 与 WebStorm"},{"role":"assistant","content":"前端小白最喜欢问的一个问题是：哪个编辑器/IDE 好用？是 VS Code 还是 WebStorm （WebStorm 其实是 IntelliJ IDEA 的定制版）？我来做个对比：\n所以，如果你以后还问这个问题，那就真有些掉底了。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"VS Code 的技术栈、核心组件"},{"role":"assistant","content":"了解 VS Code的技术栈和核心组件，可以让我们对 VS Code 有更深入的认识。此小段，了解即可。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"VS Code 的安装"},{"role":"assistant","content":"VS Code 的安装很简单，直接去官网下载安装包，然后双击安装即可。\n\n上图中，直接点击 download，一键下载安装即可。\nVS Code支持以下平台：\n\n安装完成后的界面如下：\n\nVS Code被分为以下五个区域：\nVS Code在功能上非常克制，只包含了大多数开发流程中所需要的基础模块，包括：编辑器、文件管理、窗口管理、首选项设置、终端等。\n你需要根据具体需要安装额外的组件或者插件。比如说，如果开发TS项目，则需要安装 TS编译器，以及ESLint、TSLint等语法规则&代码风格的检查工具。如果开发C语言项目，则需要安装gcc、Clang等编译工具。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"二、崭露锋芒：VS Code 快捷键"},{"role":"assistant","content":"VS Code 用得熟不熟，首先就看你是否会用快捷键。以下列出的内容，都是常用快捷键，而加粗部分的快捷键，使用频率则非常高。\n任何工具，掌握 20%的技能，足矣应对 80% 的工作。既然如此，你可能会问：那就只保留 20% 的特性，不久可以满足 80%的用户了吗？\n但我想说的是： ，每个人都会用到不同的功能。\n掌握下面这些高频核心快捷键，你和你的工具，足矣露出锋芒。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"4、编辑操作"},{"role":"assistant","content":"另外再补充一点：将光标点击到某一行的任意位置时，默认就已经是 了，此时可以直接 或 ，无需点击鼠标。这个非常实用，是所有的编辑操作中，使用得最频繁的。它可以有以下使用场景：\n你看到了没？上面的两个场景，我全程没有使用鼠标，只通过简单的复制粘贴和方向键，就做到了如此迅速的copy代码。你说是不是很高效？"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"5、删除操作"},{"role":"assistant","content":"备注：上面所讲到的移动光标、编辑操作、删除操作的快捷键，在其他编辑器里，大部分都适用。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"6、多光标选择/多光标编辑"},{"role":"assistant","content":"多光标选择在编程的 方面可谓立下了汗马功劳。因为比较难记住，所以你要时不时回来复习这一段。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"7、多列选择/多列编辑"},{"role":"assistant","content":"多列选择是更高效的多光标选择，所以单独列成一小段。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"10、自定义快捷键"},{"role":"assistant","content":"按住快捷键「Cmd + Shift + P」，弹出命令面板，在命令面板中输入“快捷键”，可以进入快捷键的设置。\n当然，你也可以选择菜单栏「偏好设置 --> 键盘快捷方式」，进入快捷键的设置：\n\n此外，如果你输入这个快捷键后没起作用，那有可能是与其他软件（比如 PicGo 软件）的快捷键冲突了，请检查一下。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"11、快捷键列表"},{"role":"assistant","content":"你可以点击 VS Code 左下角的齿轮按钮，效果如下：\n\n上图中，在展开的菜单中选择「键盘快捷方式」，就可以查看和修改所有的快捷键列表了："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"快捷键参考表（官方）"},{"role":"assistant","content":"VS Code官网提供了 PDF版本的键盘快捷键参考表，转需：\n我们在 VS Code软件里通过菜单栏「帮助-->键盘快捷方式参考」也可以打开相应平台的快捷键大全（PDF版本）。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"三、高端访问：命令面板的使用"},{"role":"assistant","content":"Mac 用户按住快捷键 （Windows 用户按住快捷键 ），可以打开快速命令面板。效果如下：\n\n命令面板的作用是 。如果让开发者记住所有的配置项在菜单的哪个位置是不现实的，而且有些命令并不在菜单中。\n有了命令面板之后，如果你需要修改一些设置项，或者进行一些快捷操作，则可以通过「命令面板」来操作，效率会更高。接下来列举一些。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"1、VS Code 设置为中文语言"},{"role":"assistant","content":"Mac 用户按住快捷键 （Windows 用户按住快捷键 ），打开命令面板。\n在命令面板中，输入 ，选择 ，然后安装插件 即可。\n或者，我们可以直接安装插件 ，是一样的。\n安装完成后，重启 VS Code。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"2、设置字体大小"},{"role":"assistant","content":"在命令面板输入“字体”，可以进行字体的设置，效果如下：\n\n当然，你也可以在菜单栏，选择「首选项-设置-常用设置」，在这个设置项里修改字体大小。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"3、快捷键设置"},{"role":"assistant","content":"在命令面板输入“快捷键”，就可以进入快捷键的设置。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"4、大小写转换"},{"role":"assistant","content":"选中文本后，在命令面板中输入 ，就可以修改文本的大小写了。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"5、使用命令行启动 VS Code"},{"role":"assistant","content":"（1）输入快捷键「Cmd + Shift + P 」，选择 ：\n\n（2）使用命令行：\n备注：这种方法快捷简单，但是在电脑重启之后就失效了。稍后在第五段，我会介绍更常见的方法。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"6、修改特定编程语言的设置项"},{"role":"assistant","content":"输入快捷键「Cmd + Shift + P 」打开命令面板，然后输入并执行 即可。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"0、设置项介绍"},{"role":"assistant","content":"在修改 VS Code配置之前，我们需要知道，在哪里可以找到设置项的入口。\n：Mac用户选择菜单栏「Code--> 首选项-->设置」，即可打开配置项：\n\n：点击软件右下角的设置图标：\n\n\n如上图所示，VS Code提供两种不同范围的设置：\n操作技巧：\n（1）我们可以在设置面板的顶部搜索框，输入关键词，就能迅速定位到你想要的设置项。\n（2）上图中，点击右上角的icon，可以通过 json文件的形式修改设置项。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"1、修改主题"},{"role":"assistant","content":"1）修改颜色主题：\n选择菜单栏「Code --> 首选项 --> 颜色主题」：\n\n在弹出的对话框中，挑选你一个你喜欢的的颜色主题吧，或者安装其他颜色的主题：\n\n或者在设置项里搜索 ，进行修改。\n2）修改文件图标的主题：\n选择菜单栏「Code --> 首选项 --> 文件图标主题」：\n\n在弹出的对话框中，挑选你一个你喜欢的的主题吧，或者安装其他的主题：\n\n或者在设置项里搜索 ，进行修改。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"2、面包屑（Breadcrumb）导航"},{"role":"assistant","content":"打开 VS Code 的设置项，选择「用户设置 -> 工作台 -> 导航路径」，如下图所示：\n\n上图中，将红框部分打钩即可。\n设置成功后，我们就可以查看到当前文件的「层级结构」，非常方便。如下图所示：\n\n有了这个面包屑导航，我们可以点击它，在任意目录、任意文件之间随意跳转。使用频繁非常高。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"3、是否显示代码的行号"},{"role":"assistant","content":"VS Code 默认显示代码的行号。你可以在设置项里搜索 修改设置，配置项如下：\n\n我建议保留这个设置项，无需修改。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"4、右侧是否显示代码的缩略图"},{"role":"assistant","content":"如果某个文件的代码量很大，缩略图就很有用了，可以预览全局，并在当前文件中快速跳转。\nVS Code 会在代码的右侧，默认显示缩略图。你可以在设置项里搜索 进行设置，配置项如下：\n\n上面这张图，你仔细琢磨下会发现，中文翻译十分精准。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"5、将当前行代码高亮显示（更改光标所在行的背景色）"},{"role":"assistant","content":"当我们把光标放在某一行时，这一行的背景色并没有发生变化。如果想 当前行的代码，需要设置两步：\n（1）在设置项里搜索 ，将选项值设置为 或者 。\n（2）在设置项里增加如下内容：\n```json\n\"workbench.colorCustomizations\": {\n    \"editor.lineHighlightBackground\": \"#00000090\",\n    \"editor.lineHighlightBorder\": \"#ffffff30\"\n}\n```\n上方代码，第一行代码的意思是：修改光标所在行的背景色（背景色设置为全黑，不透明度 90%）；第二行代码的意思是：修改光标所在行的边框色。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"6、改完代码后立即自动保存"},{"role":"assistant","content":"：\n改完代码后，默认不会自动保存。你可以在设置项里搜索 ，修改参数值为 ，即可自动保存。如下：\n\nfiles.autoSave的参数值有以下几种：\n：\n当然，你也可以直接在菜单栏选择「文件-自动保存」。勾选后，当你写完代码后，文件会立即实时保存。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"7、热退出"},{"role":"assistant","content":"当VS Code退出后，它可以记住未保存的文件。如果你希望达到这种效果，那么，你需要先将设置项 的值改为 。这个配置项要不要改，看你个人需要。比如我自己平时设置的值是 。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"8、保存代码后，是否立即格式化"},{"role":"assistant","content":"保存代码后，默认 进行代码的格式化。你可以在设置项里搜索 查看该配置项：\n\n我觉得这个配置项保持默认就好，不用打钩。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"9、自动格式化粘贴的内容"},{"role":"assistant","content":"在设置项里搜索 ，将设置项改为 ："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"10、设置字体大小"},{"role":"assistant","content":"在设置项里搜索 ，然后根据需要设置各种模块的字体大小："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"11、空格 or 制表符"},{"role":"assistant","content":"VS Code 会根据你所打开的文件来决定该使用空格还是制表。也就是说，如果你的项目中使用的都是制表符，那么，当你在写新的代码时，按下 tab 键后，编辑器就会识别成制表符。\n（1）建议的设置项如下：\n\n这样做，是为了取消系统的自动缩进，建议自己手动格式化比较好。 参考链接：\n\n\n（2）状态栏也会显示当前的缩进值。点击状态栏，可以直接修改 tabSize 缩进值：\n\n（3）另外，我们还可以安装 prettier 插件，设置代码在格式化时默认缩进值。prettier 是做代码格式化的最常见工具。\n\n（4）去掉每一行末尾的空格。在设置项里搜索 或者 ，将值设置为 true：\n\n一般来说，每一行代码末尾的空格是多余的，所以建议去掉。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"12、直观地显示代码里的空格和缩进 ✨"},{"role":"assistant","content":"代码里如果有缩进或者空格，肉眼是看不出来的，但是我们可以修改配置项，把它揪出来。\n在配置项里搜索 ，修改为 ：\n\n修改之后，代码里的空格、缩进的展示效果如下：\n\n看到了没？哪里有空格、哪里是缩进，全都一目了然。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"13、新建文件后的默认文件类型"},{"role":"assistant","content":"当我们按下快捷键「Cmd + N」新建文件时，VS Code 默认无法识别这个文件到底是什么类型的，因此也就无法识别相应的语法高亮。\n如果你想修改默认的文件类型，可以在设置项里搜索 ，设置项如下：\n\n上图中的红框部分，填入你期望的默认文件类型。我填的是 类型，你也可以填写成 或者 ，或者其他的语言类型。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"14、删除文件时，是否弹出确认框"},{"role":"assistant","content":"当我们在 VS Code 中删除文件时，默认会弹出确认框。如果你想修改设置，可以在设置项里搜索 。截图如下：\n\n我建议这个设置项保持默认的打钩就好，不用修改。删除文件前的弹窗提示，也是为了安全考虑，万一手贱不小心删了呢？"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"15、在新窗口打开文件/文件夹"},{"role":"assistant","content":"通过 （默认值为off）和 （默认值为default），可以配置在打开文件夹、打开文件时，是否开启一个新的窗口。我个人建议，把这两个配置项都设置为 on，避免旧的窗口被覆盖：\n\n补充知识—— 可以用来配置 如何恢复之前的会话窗口。涉及到的场景是：你把 VS Code 关闭了，然后又打开了，是否要展示之前打开过的文件、文件夹？参数值有以下几种："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"16、自动删除行尾的空格"},{"role":"assistant","content":"打开设置项，搜索 ，将选项勾选，即可在保存文件时自动删除行尾的空格。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"17、突出显示成对的括号"},{"role":"assistant","content":"我们可以用不同颜色显示代码中成对的括号，并用连线标注括号范围。简称 。\n最早是通过 插件支持的，但是这个插件已经被废弃了，因为 VS Code 已经内置了该功能。我们可以通过 VS Code的如下配置项，达到效果：\n```json\n{\n  \"editor.bracketPairColorization.enabled\": true,\n  \"editor.guides.bracketPairs\": \"active\"\n}\n```"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"18、自动换行"},{"role":"assistant","content":"自动换行：意味着当文本到达屏幕或页面的右边缘时，自动换行会将文本移到下一行，以便继续输入或显示。\n打开设置项，搜索 ，将选项值设置为 on。\n此外，你还可以选择菜单栏 ，即可将当前文件设置为自动换行。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"1、快速生成HTML骨架"},{"role":"assistant","content":"先新建一个空的html文件，然后通过以下方式，可以快速生成html骨架。\n：输入 ，然后按下 键，即可生成html骨架。如下图：\n\n：输入 ，然后按住 键，即可生成html骨架。\n生成的骨架，内容如下：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n```\n有了上面的html骨架之后，我们就可以快乐地在里面插入CSS 代码和 JS 代码。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"2、并排编辑：左右（上下）显示多个编辑器窗口（copy代码利器）"},{"role":"assistant","content":"Mac 用户按住快捷键 ， Windows 用户按住快捷键 ，即可同时打开多个编辑器窗口，进行并排编辑。效果如下：\n\n按快捷键「Cmd + 1 」切换到左边的窗口，按快捷键「Cmd + 2 」切换到右边的窗口，以此类推。随时随地，想切就切。\n学会了这一招，以后 copy 代码的时候，leader 再也不用担心我抄得慢了，一天工资到手。\n当然，使用快捷键 只是其中一种方式，我们还有很多种方式打开并行编辑。我们来做一个汇总。\n如果你已经打开了一个编辑器，那么可以通过以下几种方式在另一侧打开另一个编辑器：（按照使用频率，从高到低排序）\n\n补充知识：通过配置项 可以控制编辑器在并排打开时出现的默认位置（默认值为right，你也可以根据需要改为 down）。如下图所示："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"3、从终端 code 命令启动 VS Code（Mac电脑）"},{"role":"assistant","content":"在终端输入 或者输入 ，就可以启动 VS Code，十分便捷。即：\n为了达到目的，我们需要先将 VS Code的软件安装路径添加到环境变量，一劳永逸。具体操作如下：\n（1）打开 文件：\n```bash\ncd ~\nvim ./bash_profile\n```\n（2）在 bash_profile 中添加如下内容：\n```bash\n# 从终端启动VS Code，并设置vscode启动的命令别名\nalias code=\"/Applications/Visual\\ Studio\\ Code.app/Contents/Resources/app/bin/code\"\n```\n注意，由于 这个路径里有空格，所以需要在空格前面加上反斜杠 。\n（3）重启环境变量的配置：\n```\n# 重启\nsource ~/.bash_profile\n```\n大功告成。\n改完之后，如果没生效，那你把 文件 换成 文件试试。\n参考链接：\n当然，还可以通过命令面板，一键设置环境变量。具体做法是：输入快捷键「Cmd + shift + P」打开命令面板，然后选择 ：\n\n完成后就可以在终端输入命令+文件路径来启动 VS Code 了。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"3、从终端 code 命令启动 VS Code（Windows电脑）"},{"role":"assistant","content":"在终端输入 或者输入 ，就可以启动 VS Code，十分便捷。即：\n为了达到目的，我们需要先将 VS Code的软件安装路径添加到环境变量，一劳永逸。具体操作如下：\n（1）打开 VS Code 的安装位置，进入bin文件夹，复制路径。比如： 。\n（2）回到桌面，右键我的电脑-->高级系统设置-->环境变量-->编辑path值，在原来的path后面，追加内容 （即英文的分号+VS Code 的 bin 路径)\n（3）重启电脑，大功告成。\n改完之后，如果没生效，那八成是因为你填的 path 值有问题。\n参考链接："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"4、在当前文件中搜索"},{"role":"assistant","content":"在上面的快捷键列表中，我们已经知道如下快捷键：\n多个搜索结果出来之后，按下 Enter 键之后跳转到下一个搜索结果，按下 Shift + Enter 键之后跳转到上一个搜索结果。\n另外，你可能会注意到，搜索框里有很多按钮，每个按钮都对应着不同的功能，如下图所示：\n\n上图中，你可以通过「Tab」键和「Shift + Tab」键在输入框和替换框之间进行切换。\n「在选定内容中查找」这个功能还是比较实用的。你也可以在设置项里搜索 ，勾选该设置项后，那么，当你选中指定内容后，然后按住「Cmd + F」，就可以 只在这些内容里进行查找。该设置项如下图所示："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"5、全局搜索"},{"role":"assistant","content":"在上面的快捷键列表中，我们已经知道如下快捷键：\n\n上图中，你可以点击 部分，展开更多的配置项。然后点击 部分，进行过滤搜索。注意，第二个红圈那里会经常用到，它可以在搜索时过滤掉 、 等忽略文件。\n上图中，我们还可以点击“在编辑器中打开”，在一个单独的文件中聚合展示搜索结果："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"6、文件名/文件夹的搜索"},{"role":"assistant","content":"前面的快捷键那一段我们讲过，通过 「Cmd + P」可以快速搜索并打开 /文件夹。这种方式，一般用于快速打开最近编辑过的文件。\n其实还有一种很巧妙的方式，可以在整个项目里，既能搜到文件，也能搜到 。这种方式，常用于 。操作方法很简单：\n\n当然，这招也有一点不足：不能搜中文。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"7、大纲视图"},{"role":"assistant","content":"如下图所示，大纲视图可以展示当前代码的方法结构、文件的目录结构："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"8、文件对比"},{"role":"assistant","content":"VS Code 默认支持 。选中两个文件，然后右键选择「将已选项进行比较」即可，效果如下：\n\nVS Code 自带的对比功能并不够强大，我们可以安装插件 ，进行更丰富的对比。比如说，安装完插件 之后，我们可以将「当前文件」与「剪切板」里的内容进行对比：\n\n如果你安装了 GitLens 插件，还可以将两个git分支的代码进行比对，非常完美。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"9、查找某个函数在哪些地方被调用了"},{"role":"assistant","content":"比如我已经在 文件里调用了 函数。那么，如果我想知道 函数在其他文件中是否也被调用了，该怎么做呢？\n做法如下：在 文件里，选中 函数（或者将光标放置在 函数上），然后按住快捷键「Shift + F12」，就能看到 函数在哪些地方被调用了，比较实用。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"11、重构"},{"role":"assistant","content":"重构分很多种，我们来举几个例子。\n：\n当我们尝试去修改某个函数（或者变量名）时，我们可以把光标放在上面，然后按下「F2」键，那么，这个函数（或者变量名）出现的地方都会被修改。\n：\n选中某一段代码，这个时候，代码的左侧会出现一个「灯泡图标」，点击这个图标，就可以把这段代码提取为一个单独的函数。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"12：终端配置"},{"role":"assistant","content":"VS Code软件自带了终端，但我个人认为不是很好用，而且VS Code 软件关了之后，终端也没了。建议大家使用其他的终端软件，专业的事情交给专业的人做。\n："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"13、Git 版本管理"},{"role":"assistant","content":"在 VS Code中使用Git之前，需要你先安装 Git 环境。\nVS Code 自带了 Git 版本管理的功能，如下图所示：\n\n上图中，我们可以在这里进行常见的 git 命令操作。如果你还不熟悉 ，可以先去补补课。\n我自己用的最多的功能是 和 ，自从用上了 VS Code 的这两个功能，简直离不开它。\n我们先来看看 diff 代码的效果：\n\n上图中，点击右上角的 ，然后点击 ，则可以换一种视图 diff 代码：\n\n：\n\n在VS Code的左下角会显示Git状态栏。如果当前代码仓库配置了远程仓库，那么“同步更改”会显示以下信息：\n点击“同步更改”按钮，会拉取（pull）远程分支到本地分支，并推送（push）本地的Git commit到远程分支。\n如果当前代码仓库没有配置远程仓库，则会显示“发布更改”的按钮。点击“发布更改”按钮，会把当前分支push到远程仓库。\n另外，我建议安装插件 搭配使用，它是 VS Code 中我最推荐的一个插件，简直是 Git 神器，码农必备。\n我还要补充一句：\n有人说，高手都是直接用命令行操作Git。然而，根据我多年的经验来看，如果你的代码仓库需要管理的分支特别多，与团队的其他成员需要经常协作，那么，我建议你 GUI 图形化工具来操作Git，避免出错。\n我推荐的GUI版的Git工具有："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"14、将工作区放大/缩小"},{"role":"assistant","content":"我们在上面的设置项里修改字体大小后，仅仅只是修改了代码的字体大小。\n如果你想要缩放整个工作区（包括代码的字体、左侧导航栏的字体等），可以按下快捷键「 」。windows 用户是按下「ctrl +/-」\n。\n如果你想恢复默认的工作区大小，可以在命令面板输入 （英文是 ）\nf### 11、创建多层子文件夹\n我们可以在新建文件夹的时候，如果直接输入 ，比如：\n\n那么，就可以创建多层子文件夹，效果如下："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"15、 文件夹的作用"},{"role":"assistant","content":"为了统一团队的 vscode 配置，我们可以在项目的根目录下建立 目录，在里面放置一些配置内容，比如：\n目录里的配置只针对当前项目范围内生效。将 提交到代码仓库，大家统一配置时，会非常方便。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"16、自带终端"},{"role":"assistant","content":"我们可以按下「Ctrl + `」打开 VS Code 自带的终端。我认为内置终端并没有那么好用，我更建议你使用第三方的终端 。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"17、markdown 语法支持"},{"role":"assistant","content":"VS Code 自带 markdown 语法高亮。也就是说，如果你是用 markdown 格式写文章，则完全可以用 VS Code 进行写作。\n写完 md 文件之后，你可以点击右上角的按钮进行预览，如下图所示：\n\n我一般是安装「Markdown Preview Github Styling」插件，以 GitHub 风格预览 Markdown 样式。样式十分简洁美观。\n你也可以在控制面板输入 ，直接全屏预览 markdown 文件。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"18、Emmet in VS Code"},{"role":"assistant","content":"可以极大的提高 html 和 css 的编写效率，它提供了一种非常简练的语法规则。\n举个例子，我们在编辑器中输入缩写代码： ，然后按下 Tab 键，即可得到如下代码片段：\n```html\n<ul>\n  <li></li>\n  <li></li>\n  <li></li>\n  <li></li>\n  <li></li>\n  <li></li>\n</ul>\n```\nVS Code 默认支持 Emmet。更多 Emmet 语法规则，可以自行查阅。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"19、修改字体，使用「Fira Code」字体"},{"role":"assistant","content":"这款字体很漂亮，很适合用来写代码：\n\n安装步骤如下：\n（1）进入 网站，下载并安装「Fira Code」字体。\n（2）打开 VS Code 的「设置」，搜索 ，修改相关配置为如下内容：\n```json\n\"editor.fontFamily\": \"'Fira Code',Menlo, Monaco, 'Courier New', monospace\", // 设置字体显示\n\"editor.fontLigatures\": false,//控制是否启用字体连字，true启用，false不启用\n```\n上方的第二行配置，取决于个人习惯，我是直接设置为 ，因为我不太习惯连字。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"20、代码格式化"},{"role":"assistant","content":"VS Code 默认对 JavaScript、TypeScript、JSON、HTML 提供了开箱即用的代码格式化支持。其他语言则需要先安装相应的插件才能支持。\n另外，我们还可以安装 Prettier 插件进行 的代码格式化。下一段将插件的时候，会讲解。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"21、智能提示 IntelliSense"},{"role":"assistant","content":"VS Code 默认对 JavaScript、TypeScript、JSON、HTML、CSS、SCSS、Less这7种语言（文件）提供了 的支持。其他编程语言则需要先安装相应的插件才能支持。\n在 VS Code插件职场中，下图是最受欢迎的8种 ：\n\n智能提示的功能很强大， 包括函数介绍、代码自动补全等等。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"22、调试与运行"},{"role":"assistant","content":"VS Code 了对 Node.js 运行时的调试支持，可以直接调试 JavaScript 和 TypeScript。其他编程语言的调试，则需要先安装相应的插件才能支持。\n在 VS Code插件市场中，下图是最受欢迎的几种调试插件："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"23、文件传输：sftp"},{"role":"assistant","content":"如果你需要将本地文件通过 ftp 的形式上传到局域网的服务器（需要先把服务端的配置搭建好），可以安装 这个插件，很好用。在公司会经常用到。\n步骤如下：\n（1）安装插件 。\n（2）配置 文件。 插件安装完成后，输入快捷键「cmd+shift+P」弹出命令面板，然后输入 ，回车，当前工程的 文件夹下就会自动生成一个 文件，我们需要在这个文件里配置的内容可以是：\n举例如下：(注意，其中的注释需要去掉)\n```json\n{\n  \"host\": \"192.168.xxx.xxx\", //服务器ip\n  \"port\": 22, //端口，sftp模式是22\n  \"username\": \"\", //用户名\n  \"password\": \"\", //密码\n  \"protocol\": \"sftp\", //模式\n  \"agent\": null,\n  \"privateKeyPath\": null,\n  \"passphrase\": null,\n  \"passive\": false,\n  \"interactiveAuth\": false,\n  \"remotePath\": \"/root/node/build/\", //服务器上的文件地址\n  \"context\": \"./server/build\", //本地的文件地址\n\n  \"uploadOnSave\": true, //监听保存并上传\n  \"syncMode\": \"update\",\n  \"watcher\": {\n    //监听外部文件\n    \"files\": false, //外部文件的绝对路径\n    \"autoUpload\": false,\n    \"autoDelete\": false\n  },\n  \"ignore\": [\n    //忽略项\n    \"**/.vscode/**\",\n    \"**/.git/**\",\n    \"**/.DS_Store\"\n  ]\n}\n```\n（3）在 VS Code 的当前文件里，选择「右键 -> upload」，就可以将本地的代码上传到 指定的 ftp 服务器上（也就是在上方 中配置的服务器 ip）。\n我们还可以选择「右键 -> Diff with Remote」，就可以将本地的代码和 ftp 服务器上的代码做对比，非常方便。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"24、沉浸模式/禅模式"},{"role":"assistant","content":"程序员写代码需要专注，有时需要进入一种心流。VS Code给我们提供了一种全屏下的沉浸模式，周围的面板都会被隐藏起来，只显示编辑器部分。\n操作方法：菜单栏选择「查看-外观-禅模式」即可；或者按下快捷键 ，放手，再按 也可以达到目的。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"25、远程同步 VS Code 配置项"},{"role":"assistant","content":"北京时间的 ，微软发布 Visual Studio Code 1.48 稳定版。此版本 支持用户同步 VS Code的配置，只需要登录微软账号或者 GitHub 账号即可。\n有了这个功能之后，我们可以先在老电脑上登录账号，即可将软件的配置项自动开启云同步。当你下次换一个新的电脑，下载安装 VS Code，点击软件左下角的设置按钮，登录此前的微软账号或GitHub账号，即可自动将旧电脑的软件配置项，同步到新电脑的软件上。极其方便。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"26、正则表达式批量删除字符串"},{"role":"assistant","content":"：将文本中的字符串 ，批量替换为 。其中，开头字符 a 和 结尾字符 b 固定，中间xxx长度不确定。\n：传统查找替换无法胜任。可以使用VScode正则表达式功能，查找 替换为 即可。其中 是禁止贪婪匹配，否则会误删很多内容。\n：需求——将文本中的字符串 ，批量替换为 。其中，开头字符 a 固定，后面的xxx长度不确定。\n：传统查找替换无法胜任。可以使用VScode正则表达式功能，查找 替换为 即可。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"六、三头六臂：VS Code 插件介绍 & 插件推荐"},{"role":"assistant","content":"VS Code 有一个很强大的功能就是支持插件扩展，让你的编辑器仿佛拥有了三头六臂。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"安装插件"},{"role":"assistant","content":"上图中，点击红框部分，即可在顶部输入框里，查找你想要的插件名，然后进行安装。\n插件安装完成后，记得重启软件（或者点击插件位置的“重新加载”），插件才会生效。\n另外，我们还可以访问官网的插件市场来安装插件：\n："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"插件的类型"},{"role":"assistant","content":"插件市场的首页有四个模块，可以作为重要的信息来源：\n\n\n插件市场至少有17种类型的插件：（按照数量排序）"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"插件的过滤显示"},{"role":"assistant","content":"在 VS Code中打开插件管理视图，可以针对已安装的插件，进行过滤展示。\n1）点击插件视图右上角的 按钮，可以展示不同状态的插件：\n\n2）在搜索框输入字符 ，会展示出不同类型的过滤器：\n\n：\n1）按大类搜：\n2）精准搜索：\n3）对插件进行排序：\n4）组合搜索：（举例）\n下面的内容，我来列举一些常见的插件，这些插件都很实用，小伙伴们可以按需安装。注意：每一类插件里， 。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Chinese (Simplified) Language Pack for Visual Studio Code"},{"role":"assistant","content":"让软件显示为简体中文语言。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"GitLens 【荐】"},{"role":"assistant","content":"我强烈建议你安装插件 ，它是 VS Code 中我最推荐的一个插件，简直是 Git 神器，码农必备。如果你不知道，那真是 out 了。\nGitLens 在 Git 管理上有很多强大的功能，比如：\n打开你的 Git仓库，未安装 GitLens 时是这样的：\n\n安装了 GitLens 之后是这样的：\n\n上图中，红框部分就是 GitLens 的功能，诸君可以自由发挥。\n补充一个有意思的趣事：Python插件、Ruby插件、GitLens插件、Vetur插件，这四个插件的开发者先后加入了微软。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Git History"},{"role":"assistant","content":"有些同学习惯使用编辑器中的 Git 管理工具，而不太喜欢要打开另外一个 Git UI 工具的同学，这一款插件满足你查询所有 Git 记录的需求。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Local History 【荐】"},{"role":"assistant","content":"维护文件的本地历史记录。代码意外丢失时，有时可以救命。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Vetur"},{"role":"assistant","content":"Vue 多功能集成插件，包括：语法高亮，智能提示，emmet，错误提示，格式化，自动补全，debugger。VS Code 官方钦定 Vue 插件，Vue 开发者必备。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"ES7 React/Redux/GraphQL/React-Native snippets"},{"role":"assistant","content":"React/Redux/react-router 的语法智能提示。\n安装该插件后，在代码中只需要输入 即可自动补全 这行代码。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"JavaScript(ES6) code snippets"},{"role":"assistant","content":"ES6 语法智能提示，支持快速输入。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"javascript console utils：快速打印 log 日志【荐】"},{"role":"assistant","content":"安装这个插件后，当我们按住快捷键「Cmd + Shift + L」后，即可自动出现日志 。简直是日志党福音。\n当我们选中某个变量 ，然后按住快捷键「Cmd + Shift + L」，即可自动出现这个变量的日志 。\n其他的同类插件还有：Turbo Console Log。\n不过，生产环境的代码，还是尽量少打日志比较好，避免出现一些异常。\n编程有三等境界："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Code Spell Checker：单词拼写错误检查"},{"role":"assistant","content":"这个拼写检查程序的目标是帮助捕获常见的单词拼写错误，可以检测驼峰命名。从此告别 Chinglish."}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Auto Close Tag、Auto Rename Tag"},{"role":"assistant","content":"自动闭合配对的标签、自动重命名配对的标签。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"highlight-icemode：选中相同的代码时，让高亮显示更加明显"},{"role":"assistant","content":"VSCode 自带的高亮显示，实在是不够显眼。可以用插件支持一下。\n所用了这个插件之后，VS Code 自带的高亮就可以关掉了：\n在用户设置里添加 即可。\n参考链接："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"vscode-icons"},{"role":"assistant","content":"vscode-icons 会根据文件的后缀名来显示不同的图标，让你更直观地知道每种文件是什么类型的。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"indent-rainbow：突出显示代码缩进"},{"role":"assistant","content":"插件：突出显示代码缩进。\n安装完成后，效果如下图所示："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"TODO Highlight"},{"role":"assistant","content":"写代码过程中，突然发现一个 Bug，但是又不想停下来手中的活，以免打断思路，怎么办？按照代码规范，我们一般是在代码中加个 TODO 注释。比如：（注意，一定要写成大写 ，而不是小写的 ）\n```\n//TODO:这里有个bug，我一会儿再收拾你\n```\n或者：\n```\n//FIXME:我也不知道为啥， but it works only that way.\n```\n安装了插件 之后，按住「Cmd + Shift + P」打开命令面板，输入「Todohighlist」，选择相关的命令，我们就可以看到一个 todoList 的清单。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Better Comments"},{"role":"assistant","content":"为注释添加更醒目、带分类的色彩。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Prettier：代码格式化"},{"role":"assistant","content":"Prettier 是一个代码格式化工具， 。在一个多人协同开发的团队中，统一的代码编写规范非常重要。一套规范可以让我们编写的代码达到一致的风格，提高代码的可读性和统一性。自然维护性也会有所提高，代码的展示也会更加美观。\n步骤如下：\n（1）安装插件 。\n（2）在项目的根路径下，新建文件 ，并在文件中添加如下内容：\n```json\n{\n  \"printWidth\": 150,\n  \"tabWidth\": 4,\n  \"semi\": true,\n  \"singleQuote\": true,\n  \"trailingComma\": \"es5\",\n  \"tslintIntegration\": true,\n  \"insertSpaceBeforeFunctionParenthesis\": false\n}\n```\n上面的内容，是我自己的配置，你可以参考。更多配置，可见官方文档：\n（3）Mac用户按快捷键「Option + Shift + F」，Win 用户按快捷键「Alt + shift + F」，即可完成代码的格式化。如果你的VS Code 设置的是自动格式化代码，那么这一步可以忽略。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"ESLint：代码格式的校验"},{"role":"assistant","content":"日常开发中，建议用 Prettier 做 ，然后用 eslint 做 。很多人把这两个插件的功能弄混了。\n一般做法是：格式化建议是由程序员手动触发，格式校验由系统强制校验。通过 Prettier 触发格式化，是为了让用户有感知；通过eslint 做 校验之后，如果代码的格式不符合要求，系统就禁止你提交代码。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Beautify"},{"role":"assistant","content":"代码格式化工具。\n备注：相比之下，Prettier 是当前最流行的代码格式化工具，比 Beautify 用得更多。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Paste JSON as Code"},{"role":"assistant","content":"此插件可以将剪贴板中的 JSON 字符串转换成工作代码。支持多种语言。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"JS-CSS-HTML Formatter【荐】"},{"role":"assistant","content":"保存文件时，自动格式化 HTML、CSS、JS代码。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Polacode-2020：生成代码截图 【荐】"},{"role":"assistant","content":"可以把代码片段保存成美观的图片，主题不同，代码的配色方案也不同，也也可以自定义设置图片的边框颜色、大小、阴影。\n尤其是在我们做 PPT 分享时需要用到代码片段时，或者需要在网络上优雅地分享代码片段时，这一招很有用。\n生成的效果如下：\n\n其他同类插件： 。我们也可以通过 这个网站生成代码图片\n有人可能会说：直接用 QQ 截图不行吗？可以是可以，但不够美观、不够干净。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Image Preview 【荐】"},{"role":"assistant","content":"图片预览。鼠标移动到图片 url 上的时候，会自动显示图片的预览和图片尺寸。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"CSS Peek"},{"role":"assistant","content":"增强 HTML 和 CSS 之间的关联，快速查看该元素上的 CSS 样式。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Vue CSS Peek"},{"role":"assistant","content":"CSS Peek 对 Vue 没有支持，该插件提供了对 Vue 文件的支持。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Color Info"},{"role":"assistant","content":"这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Markdown Preview Github Styling 【荐】"},{"role":"assistant","content":"以 GitHub 风格预览 Markdown 样式，十分简洁优雅。就像下面这样，左侧书写 Markdown 文本，右侧预览 Markdown 的渲染效果："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Markdown Preview Enhanced"},{"role":"assistant","content":"预览 Markdown 样式。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Markdown All in One"},{"role":"assistant","content":"这个插件将帮助你更高效地在 Markdown 中编写文档。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"sftp：文件传输 【荐】"},{"role":"assistant","content":"如果你需要将本地文件通过 ftp 的形式上传到局域网的服务器，可以安装 这个插件，很好用。在公司会经常用到。\n详细配置已经在上面讲过。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Live Server 【荐】"},{"role":"assistant","content":"在本地启动一个服务器，代码写完后可以实现「热更新」，实时地在网页中看到运行效果。就不需要每次都得手动刷新页面了。\n使用方式：安装插件后，开始写代码；代码写完后，右键选择「Open with Live Server」。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"open in browser"},{"role":"assistant","content":"安装 插件后，在 HTML 文件中「右键选择 --> Open in Default Browser」，即可在浏览器中预览网页。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Project Manager"},{"role":"assistant","content":"工作中，我们经常会来回切换多个项目，每次都要找到对应项目的目录再打开，比较麻烦。Project Manager 插件可以解决这样的烦恼，它提供了专门的视图来展示你的项目，我们可以把常用的项目保存在这里，需要时一键切换，十分方便。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"WakaTime 【荐】"},{"role":"assistant","content":"统计在 VS Code 里写代码的时间。统计效果如下："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Code Time"},{"role":"assistant","content":"插件：记录编程时间，统计代码行数。\n安装该插件后，VS Code 底部的状态栏右下角可以看到时间统计。点击那个位置之后，选择「Code Time Dashboard」，即可查看统计结果。\n备注：团长试了一下这个 code time 插件，发现统计结果不是很准。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"File Tree to Text Generator：快速生成文件的目录树"},{"role":"assistant","content":"如题。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"minapp：小程序支持"},{"role":"assistant","content":"小程序开发必备插件。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Search node_modules"},{"role":"assistant","content":"模块里面的文件夹和模块实在是太多了，根本不好找。好在安装 这个插件后，输入快捷键「Cmd + Shift + P」，然后输入 ，在弹出的选项中选择 ，即可搜索 node_modules 里的模块。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"RemoteHub"},{"role":"assistant","content":"不要惊讶，RemoteHub 和 GitLens 是同一个作者开发出来的。\n插件的作用是：可以在本地查看 GitHub 网站上的代码，而不需要将代码下载到本地。\n\n这个插件目前使用的人还不多，赶紧安装起来尝尝鲜吧。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Live Share：实时编码分享"},{"role":"assistant","content":"这个神奇的插件是由微软官方出品，它的作用是： 。也就是说，它可以实现你和你的同伴一起写代码。这绝对就是 的神器啊。\n安装方式：\n打开插件管理，搜索“live share”，安装。安装后重启 VS Code，在左侧会多出一个按钮：\n\n上图中，点击红框部分，登录后就可以分享你的工作空间了。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"Import Cost"},{"role":"assistant","content":"在项目开发过程中，我们会引入很多 npm 包，有时候可能只用到了某个包里的一个方法，却引入了整个包，导致代码体积增大很多。 插件可以在代码中友好的提示我们，当前引入的包会增加多少体积，这很有助于帮我们优化代码的体积。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"10、主题插件"},{"role":"assistant","content":"给你的 VS Code 换个皮肤吧，免费的那种。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"七、无缝切换：VS Code 配置云同步"},{"role":"assistant","content":"我们可以将配置云同步，这样的话，当我们换个电脑时，即可将配置一键同步到本地，就不需要重新安装插件了，也不需要重新配置软件。\n下面讲的两个同步方法，都可以，看你自己需要。方法1是 VS Code自带的同步功能，操作简单。方法2 需要安装插件，支持更多的自定义配置。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"方法1：使用 VS Code 自带的同步功能"},{"role":"assistant","content":"1、 ：\n（1）在菜单栏选择「 Code --> 首选项 --> 打开设置同步」：\n\n（2）选择需要同步的配置：\n\n（3）通过Microsoft或者GitHub账号登录。 上图中，点击“登录并打开”，然后弹出如下界面：\n\n上图中，使用 微软账号或者 GitHub账号登录：\n\n（4）同步完成后，菜单栏会显示“首先项同步已打开”，最左侧也会多出一个同步图标，如下图所示：\n\n2、 ：\n（1）点击菜单栏「Code --> 首选项 --> 设置同步已打开」，会弹出如下界面，进行相应的同步管理即可：\n\n（2）换另外一个电脑时，登录相同的账号，即可完成同步。\n参考链接："}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"方法2：使用插件 "},{"role":"assistant","content":"使用方法2，我们还可以把配置分享其他用户，也可以把其他用户的配置给自己用。\n1、 ：（将自己本地的配置云同步到 GitHub）\n（1）安装插件 。\n（2）安装完插件后，在插件里使用 GitHub 账号登录。\n（3）登录后在 vscode 的界面中，可以选择一个别人的 gist；也可以忽略掉，然后创建一个属于自己的 gist。\n（4）使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「更新/上传配置」，这样就可以把最新的配置上传到 GitHub。\n2、 ：（换另外一个电脑时，从云端同步配置到本地）\n（1）当我们换另外一台电脑时，可以先在 VS Code 中安装 插件。\n（2）安装完插件后，在插件里使用 GitHub 账号登录。\n（3）登录之后，插件的界面上，会自动出现之前的同步记录：\n\n上图中，我们点击最新的那条记录，就可将云端的最新配置同步到本地：\n\n如果你远程的配置没有成功同步到本地，那可能是网络的问题，此时，可以使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「下载配置」，多试几次。\n：\n如果我们想使用别人的配置，首先需要对方提供给你 gist。具体步骤如下：\n（1）安装插件 。\n（2）使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「下载配置」\n（3）在弹出的界面中，选择「Download Public Gist」，然后输入别人分享给你的 gist。注意，这一步不需要登录 GitHub 账号。"}],"metadata":{},"filePath":"docs/guide/课件/guid/tool/VS Code的使用.md"}
{"messages":[{"role":"user","content":"本文主要内容"},{"role":"assistant","content":"字体标签： 、 、 、 、\n超链接"}],"metadata":{"title":"05-HTML标签：字体标签和超链接","publish":true},"filePath":"docs/guide/guid/html/04-HTML标签：字体标签和超链接.md"}
{"messages":[{"role":"user","content":"特殊字符（转义字符）"},{"role":"assistant","content":"比如说，你想把 作为一个文本在页面上显示，直接写 是肯定不行的，因为这代表的是一个段落标签，所以这里需要用到 。应该这么写：\n```html\n这是一个HTML语言的<p>标签\n```\n正确的效果如下：\n\n错误的效果如下：\n\n其实我们只要记住前三个符号就行了，其他的在需要的时候查一下就行了。而且，EditPlus软件中是可以直接点击这些符号进行选择的：\n\n来一张表格，方便需要的时候查询："}],"metadata":{"title":"05-HTML标签：字体标签和超链接","publish":true},"filePath":"docs/guide/guid/html/04-HTML标签：字体标签和超链接.md"}
{"messages":[{"role":"user","content":"下划线、中划线、斜体"},{"role":"assistant","content":"效果：\n\n上面的这几个标签，常用于做一些小装饰、小图标。比如：\n\n这张图中，我们通过查看京东网站的代码发现，箭头处的小图标都是用的标签 。"}],"metadata":{"title":"05-HTML标签：字体标签和超链接","publish":true},"filePath":"docs/guide/guid/html/04-HTML标签：字体标签和超链接.md"}
{"messages":[{"role":"user","content":"粗体标签 或 （已废弃）"},{"role":"assistant","content":"效果："}],"metadata":{"title":"05-HTML标签：字体标签和超链接","publish":true},"filePath":"docs/guide/guid/html/04-HTML标签：字体标签和超链接.md"}
{"messages":[{"role":"user","content":"字体标签 （已废弃）"},{"role":"assistant","content":"属性：\n举例：\n```html\n<font face=\"微软雅黑\" color=\"#FF0000\" size=\"10\">vae</font>\n```\n效果："}],"metadata":{"title":"05-HTML标签：字体标签和超链接","publish":true},"filePath":"docs/guide/guid/html/04-HTML标签：字体标签和超链接.md"}
{"messages":[{"role":"user","content":"上标    下标 "},{"role":"assistant","content":"上小标这两个标签容易混淆，怎么记呢？这样记： 的意思是 举例：\n```html\nO<sup>2</sup>    5<sub>3</sub>\n```\n效果："}],"metadata":{"title":"05-HTML标签：字体标签和超链接","publish":true},"filePath":"docs/guide/guid/html/04-HTML标签：字体标签和超链接.md"}
{"messages":[{"role":"user","content":"三、超链接"},{"role":"assistant","content":"超链接有三种形式，下面分别讲讲。"}],"metadata":{"title":"05-HTML标签：字体标签和超链接","publish":true},"filePath":"docs/guide/guid/html/04-HTML标签：字体标签和超链接.md"}
{"messages":[{"role":"user","content":"1、外部链接：链接到外部文件"},{"role":"assistant","content":"举例：\n```html\n<a href=\"02页面.html\">点击进入另外一个文件</a>\n```\na是英语 “锚”的意思，就好像这个页面往另一个页面扔出了一个锚。是一个文本级的标签。\nhref（hypertext reference）：超文本地址。读作“喝瑞夫”，不要读作“喝夫”。\n效果：\n\n当然，我们也可以直接点进链接，访问一个网址。代码举例如下：\n```html\n<a href=\"http://www.baidu.com\" target=\"_blank\">点我点我</a>\n```"}],"metadata":{"title":"05-HTML标签：字体标签和超链接","publish":true},"filePath":"docs/guide/guid/html/04-HTML标签：字体标签和超链接.md"}
{"messages":[{"role":"user","content":"2、锚链接"},{"role":"assistant","content":"：给超链接起一个名字，作用是 。比如说，在网页底部有一个向上箭头，点击箭头后回到顶部，这个就可以利用锚链接。\n首先我们要创建一个 ，也就是说，使用 属性或者 属性给那个特定的位置起个名字。效果如下：\n\n上图中解释：\n第11行代码表示，顶部这个锚的名字叫做name1。\n然后在底部设置超链接，点击时将回到顶部（此时，网页中的url的末尾也出现了 ）。注意 ，表示跳到名为name1的特定位置，这是规定。如果少了 号，点击之后，就会跳到name1这个文件或者name1这个文件夹中去。\n如果我们将上图中的第28行代码写成：\n```html\n<a href=\"a.html#name1\">回到顶部</a>\n```\n那就表示，点击之后，跳转到 页面的 中去。\n说明：name属性是HTML4.0以前使用的，id属性是HTML4.0后才开始使用。为了向前兼容，因此，name和id这两个属性都要写上，并且值是一样的。"}],"metadata":{"title":"05-HTML标签：字体标签和超链接","publish":true},"filePath":"docs/guide/guid/html/04-HTML标签：字体标签和超链接.md"}
{"messages":[{"role":"user","content":"3、邮件链接"},{"role":"assistant","content":"代码举例：\n```html\n<a href=\"mailto:xxx@163.com\">点击进入我的邮箱</a>\n```\n效果：点击之后，会弹出outlook，作用不大。"}],"metadata":{"title":"05-HTML标签：字体标签和超链接","publish":true},"filePath":"docs/guide/guid/html/04-HTML标签：字体标签和超链接.md"}
{"messages":[{"role":"user","content":"超链接的属性"},{"role":"assistant","content":"属性举例：\n```html\n<a href=\"09_img.html\" title=\"很好看哦\">结婚照</a>\n```\n效果如下：\n\n属性举例：\n```html\n<a href=\"1.html\" title=\"悬停文本\" target=\"_blank\">链接的内容</a>\n```\nblank就是“空白”的意思，就表示新建一个空白窗口。为啥有一个_ ，就是规定，无需解释。\n也就是说，如果不写 那么就是在相同的标签页打开，如果写了 ，就是在新的空白标签页中打开。"}],"metadata":{"title":"05-HTML标签：字体标签和超链接","publish":true},"filePath":"docs/guide/guid/html/04-HTML标签：字体标签和超链接.md"}
{"messages":[{"role":"user","content":"备注1：分清楚img和a标签的各自的属性"},{"role":"assistant","content":"区别如下：\n```html\n<img src=\"1.jpg\" />\n<a href=\"1.html\"></a>\n```"}],"metadata":{"title":"05-HTML标签：字体标签和超链接","publish":true},"filePath":"docs/guide/guid/html/04-HTML标签：字体标签和超链接.md"}
{"messages":[{"role":"user","content":"备注2：a是一个文本级的标签"},{"role":"assistant","content":"比如一个段落中的所有文字都能够被点击，那么应该是p包裹a：\n```html\n<p>\n\t<a href=\"\">段落段落段落段落段落段落</a>\n</p>\n```\n而不是a包裹p：\n```html\n<a href=\"\">\n\t<p>\n\t\t段落段落段落段落段落段落\n\t</p>\n</a>\n```\na的语义要小于p，a就是可以当做文本来处理，所以p里面相当于放的就是纯文字。"}],"metadata":{"title":"05-HTML标签：字体标签和超链接","publish":true},"filePath":"docs/guide/guid/html/04-HTML标签：字体标签和超链接.md"}
{"messages":[{"role":"user","content":"1、vite 的本质是什么"},{"role":"assistant","content":"这个是仓库地址"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(一).mdx"}
{"messages":[{"role":"user","content":"2、项目的技术选型"},{"role":"assistant","content":"koa+ts+esbuild+fs-extra\n此项目使用 tsx 运行\n为什么选择 koa，无他，因为他足够简单，可以直接上手使用。选择用 typescript 进行开发，因为 ts 的好处就在于，我们可以知道引入的包有哪些方法，更加便于我们书写方法，同时减少代码出 bugger 的可能性。\n使用 koa 搭建这个项目，这个项目只是一个学习项目，并不是一个具备高可用性的项目，优先级是以如何最容易看懂来实现的，所以 koa 搭建的这个服务器并不会进行任何的打包，如果想体验打包后的产物，建议可以使用一下 tsup，俺实力优先，现阶段没法手写 bundle 就不考虑一切打包相关的东西了。\n再次叠甲。这个项目不是那么严谨的，高可用的，这个项目主要目的一是帮助穷哥们叩开工程化的门缝(就这三脚猫功夫，我觉得不能称之为大门🥹)。其次是对自己这段时间的脚手架学习给一个交代，我认为有输入了，还是要有点输出，更能巩固知识点，其次这也是一个备忘录\n以下是 package.json 文件，如果有哥们想实现的话可以复制一下。\n```json\n{\n  \"dependencies\": {\n    \"@types/connect\": \"^3.4.38\",\n    \"@types/debug\": \"^4.1.12\",\n    \"@types/fs-extra\": \"^11.0.4\",\n    \"@types/resolve\": \"^1.20.6\",\n    \"@types/ws\": \"^8.5.13\",\n    \"cac\": \"^6.7.14\",\n    \"chokidar\": \"^4.0.1\",\n    \"connect\": \"^3.7.0\",\n    \"cross-env\": \"^7.0.3\",\n    \"debug\": \"^4.3.7\",\n    \"es-module-lexer\": \"^1.5.4\",\n    \"esbuild\": \"^0.24.0\",\n    \"fs-extra\": \"^11.2.0\",\n    \"koa\": \"^2.15.3\",\n    \"magic-string\": \"^0.30.13\",\n    \"picocolors\": \"^1.1.1\",\n    \"react\": \"^18.3.1\",\n    \"react-dom\": \"^18.3.1\",\n    \"resolve\": \"^1.22.8\",\n    \"rollup\": \"^4.27.3\",\n    \"sirv\": \"^3.0.0\",\n    \"tsup\": \"^8.3.5\",\n    \"ws\": \"^8.18.0\"\n  },\n\n  \"scripts\": {\n    \"dev\": \"cross-env NODE_ENV=dev tsx watch ./src/index.ts  \"\n  },\n  \"devDependencies\": {\n    \"@types/koa\": \"^2.15.0\",\n    \"@types/node\": \"^22.9.1\",\n    \"file-loader\": \"^6.2.0\"\n  }\n}\n```"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(一).mdx"}
{"messages":[{"role":"user","content":"3、使用 koa 搭建一个服务器"},{"role":"assistant","content":"```ts\nimport Koa from \"koa\";\nconst app = new Koa();\n//import { optimize } from \"./node/optimizer\";\n//const root = process.cwd()\napp.use(ctx => {\n  ctx.body = \"hello Koa\";\n});\napp.listen(3000, async () => {\n  //await optimize(root)\n  console.log(\"http://localhost:3000 \");\n});\n```\n嗯....，这是个有手就行的工作，不会有人不会吧，不会吧，不会吧，能看到 hello koa 就算成功"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(一).mdx"}
{"messages":[{"role":"user","content":"4、从zhangsan文件开始，理解何为资源服务器"},{"role":"assistant","content":"我们来看这段代码\n```ts\nimport fs from \"fs-extra\";\nimport path from \"path\";\n\napp.use(async (ctx, next) => {\n  const { req, res } = ctx;\n\n  if (req.url?.endsWith(\".zhangsan\") || (req.url === \"/zhangsan\"&&req.method === \"GET\")) {\n    const realPath = path.join(process.cwd(), req.url + (req.url === \"/zhangsan\" ? \".html\" : \"\"));\n    if (await fs.pathExists(realPath)) {\n      const code = await fs.readFile(realPath, \"utf-8\");\n      res.statusCode = 200;\n      req.url === \"/zhangsan\" ? res.setHeader(\"Content-Type\", \"text/html\") : res.setHeader(\"Content-Type\", \"application/javascript\");\n      \n      res.end(code)\n    }\n  }\n  return next()\n})\n\n```\n这是一个中间件，他的主要功能就是解析后缀为.zhangsan的文件，同时 再路由导航到zhangsan路由的时候，会读取根目录下的zhangsan.html文件，然后我们通过readFile读取文件，将其返回的content-type，改为html，我们的浏览器就可以读取这个页面了\n这里是zhangsan.html 他在根目录下；\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n\n<body>\n  <div id=\"zhangsan\"></div>\n  <script type=\"module\" src=\"src/node/zhangsan/1.zhangsan\"></script>\n</body>\n\n</html>\n\n\n```\n当这段代码被浏览器读取后，他的script标签会向我们的服务器发送请求，这个请求url是 ，我们的服务器能直接拦截到后缀为 的请求 见代码 ,然后我们验证这个地址是否存在，如果存在，就使用utf-8的格式去读取他，返回时将响应头设置为js，我们的浏览器就会去执行他，这是我们的zhangsan文件\n```js\n//src/node/zhangsan/1.zhangsan\nimport a from \"./a.zhangsan\";\ndocument.getElementById(\"zhangsan\").innerHTML = \"zhangsan\";\nconsole.log(a)\n\n```\n甚至他还支持模块化；\n```js\n//src/node/zhangsan/a.zhangsan\nexport default {\n  a:1\n}\n\n```\n你可以看到页面\n<img src=\"/vite/koa_vite/zhangsan.png\" />\n你可以通过network查看我们的请求\n<img src=\"/vite/koa_vite/zhangsannet.png\" />\n你现在应该了解到一点教授架的基础了，接下来开始上车了哦😚；不了解也没关系，可以去隔壁的cyber脚手架，一个中间件，带你过完react或者vue执行的一生，只不过是朋克风，青春版的而已😏\n这里是掘金地址"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(一).mdx"}
{"messages":[{"role":"user","content":"5、进行依赖的预构建"},{"role":"assistant","content":"提问：为什么要进行依赖的预构建。\n当然是对于外部引入的资源进行处理，node_modules 里的包，vite 是不会直接引用的，会先进行依赖扫描，将我们安装的一些包如 vue,react,element 等，这种外部资源包通过 esbuild 进行编译，形成一个.vite 的缓存文件。后续钩子的处理都是从.vite 中提取的资源,按照工地的话讲，这是打灰。😎"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(一).mdx"}
{"messages":[{"role":"user","content":"5-1、为什么要进一步的处理"},{"role":"assistant","content":"如下图：\n<div style=\"[object Object]\" />\n我们可以看到,无论是react还是vue,他们打包后的产物都是通过 进行的,也就是说,我们是无法在浏览器中直接执行的,所以需要做一次 。其原因是它们的生态系统中很多 的。因此，这些库和工具通常会以 发布，以便于在 ,而且，我们需要更快的构建速度，而读取缓存则是常用的方法。** 而且最重要的是，我翻遍了react和react-dom的所有包，它默认没有es模块的包，直接使用 是根本用不了的😒;  **"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(一).mdx"}
{"messages":[{"role":"user","content":"5-2、打开你的 node_modules 包，找到.vite 文件"},{"role":"assistant","content":"有没有发现你的 node_modules 包，vite 项目中有一个.vite 的文件，你删除了你的项目就 G 了 😏，得重新进行 build，这是为什么呢？;让我们来看看.vite 包是由什么构成的\n<img src=\"/vite/koa_vite/.vite.png\" />\n你会发现，包里会存在似曾相识的包的名字，因为在依赖预构建阶段， ， ，  ；\n这是 vite 的双引擎流程图，请关注于左边的开发阶段，当前的工作就是 pre-bundle，使用 esbuild 进行依赖预构建\n<img src=\"/vite/koa_vite/esbuild&esbuild.png\" />\n通俗的讲，将我们要用的依赖包通过 esbuild 转化为缓存，用来提升构建速度，减少性能消耗，这个是有意义的，后续我们对于bare裸引入处理的时候，如import React from \"react\"，我们会直接将路径改写至.vite路径中，直接读取打包好的代码"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(一).mdx"}
{"messages":[{"role":"user","content":"5-3、开始书写 esbuild 构建代码"},{"role":"assistant","content":"这里是入口文件的代码 index.ts，其中的optimizer是进行预构建的函数\n```ts\nimport Koa from \"koa\";\nconst app = new Koa();\nimport { optimize } from \"./node/optimizer\";\nconst root = process.cwd();\napp.use(ctx => {\n  ctx.body = \"hello Koa\";\n});\napp.listen(3000, async () => {\n  await optimize(root);\n  console.log(\"http://localhost:3000 \");\n});\n```\n我们来康康 optimizer 文件是怎么个事\n```ts\nimport path from \"path\";\nimport { build } from \"esbuild\";\nimport { scanPlugin } from \"./scanplugin\";\nimport { preBundlePlugin } from \"./preBundlePlugin\";\nimport { PRE_BUNDLE_DIR } from \"../contants\"; //path.join(\"node_modules\", \".m-vite\")\nexport async function optimize(root: string) {\n  // 1. 确定入口\n  // 2. 从入口处扫描依赖\n  // 3. 预构建依赖;\n  const deps = new Set<string>();\n  const entry = path.resolve(root, \"src/client/main.tsx\");\n  await build({\n    entryPoints: [entry],\n    bundle: true,\n    write: false,\n    plugins: [scanPlugin(deps)],\n  });\n  await build({\n    entryPoints: [...deps],\n    write: true,\n    bundle: true,\n    format: \"esm\",\n    splitting: true,\n    outdir: path.resolve(root, PRE_BUNDLE_DIR), //这个合成路径是 process.cwd() + \"/node_modules/.m-vite\"\n    plugins: [preBundlePlugin(deps)],\n  });\n  console.log(\"需要构建的依赖项\", deps);\n}\n```\n我们开始分析这个代码做了哪些事情 😏\nbuild 是调用 esbuild 的build，里面的选项都解释一下\n预构建为什么是两次build\n1.第一次build不进行打包，快速的将其依赖项过滤出来\n2.第二次build专门对第一次过滤出来的依赖项进行打包，我们就可以得到所有的外部依赖想的包\n通俗的讲就是第一个build就是lol的选择英雄，第二部就是选择天赋 召唤师技能全部带好，准备进入召唤师峡谷大杀四方 😏\n上面两个插件会在下面单独解析，先给大家说说是干嘛的，\n这两个插件跑完后，我们的预构建基本就完成了"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(一).mdx"}
{"messages":[{"role":"user","content":"5-3-1、先来看看 sanPlugin 的代码"},{"role":"assistant","content":"在两个插件中，我们涉及到最基础的两个函数， 和 ，他们是 esbuild 插件的基本钩子\n```ts\n// node/contants.ts\nexport const EXTERNAL_TYPES = [\n  \"css\",\n  \"less\",\n  \"sass\",\n  \"scss\",\n  \"styl\",\n  \"stylus\",\n  \"pcss\",\n  \"postcss\",\n  \"vue\",\n  \"svelte\",\n  \"marko\",\n  \"astro\",\n  \"png\",\n  \"jpe?g\",\n  \"gif\",\n  \"svg\",\n  \"ico\",\n  \"webp\",\n  \"avif\",\n];\nexport const BARE_IMPORT_RE = /^[\\w@][^:]/;\n//optimizer/scanPlugin.ts\nimport { Plugin } from \"esbuild\";\nimport { BARE_IMPORT_RE, EXTERNAL_TYPES } from \"../contants\";\nexport function scanPlugin(deps: Set<string>): Plugin {\n  return {\n    name: \"scan-deps\",\n    setup(build) {\n      build.onResolve({ filter: new RegExp(`\\\\.(${EXTERNAL_TYPES.join(\"|\")})$`) }, resolveInfo => {\n        return {\n          path: resolveInfo.path,\n          // 打上 external 标记\n          external: true,\n        };\n      });\n      build.onResolve(\n        {\n          filter: BARE_IMPORT_RE,\n        },\n        resolveInfo => {\n          deps.add(resolveInfo.path);\n          return {\n            path: resolveInfo.path,\n            external: true,\n          };\n        }\n      );\n    },\n  };\n}\n```\nbuild.onResolve 钩子，在解析路径之前调用，返回一个对象，onResolve 中的 filter 选项是一个过滤器，会根据正则进行过滤\n第一个钩子中 我们过滤掉了无关的资源，他是将 EXTERNAL_TYPES 数组中所有相关的后缀名全部过滤掉， 返回值是一个对象，我们需要返回 path，这个 path 是必传的\n我们在这两个钩子中，第一个钩子的任务是排除不必要资源，便于下面的钩子能够更好的解析生成依赖，第二个钩子是过滤出 条件为 的依赖。 , ，将 全部收集到我们依赖集合中。"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(一).mdx"}
{"messages":[{"role":"user","content":"5-3-2、再来看看 preBundlePlugin 的代码"},{"role":"assistant","content":"这位更是重量级，上强度了哦 🥵,我已经汗流浃背了。\n```ts\n//optimizer/preBundlePlugin.ts\nimport { Loader, Plugin } from \"esbuild\";\nimport { BARE_IMPORT_RE } from \"../contants\";\nimport { init, parse } from \"es-module-lexer\";\nimport path from \"path\";\nimport resolve from \"resolve\";\nimport fs from \"fs-extra\";\nimport { pathToFileURL } from \"url\"\nimport createDebug from \"debug\";\nimport { normalizePath } from \"../utils\";\nconst debug = createDebug(\"dev\");\nexport function preBundlePlugin(deps: Set<string>): Plugin {\n  return {\n    name: \"esbuild:pre-bundle\",\n    setup(build) {\n\n      build.onResolve(\n        {\n          filter: BARE_IMPORT_RE,\n        },\n        (resolveInfo) => {\n\n          const { path: id, importer } = resolveInfo;\n          const isEntry = !importer;\n          // 命中需要预编译的依赖;\n\n          if (deps.has(id)) {\n\n            // console.log(\"id\", id, isEntry, importer)\n            // 若为入口，则标记 dep 的 namespace\n\n            return isEntry\n              ? {\n                path: id,\n                namespace: \"dep\",\n              }\n              : {\n                // 因为走到 onResolve 了，所以这里的 path 就是绝对路径了\n                path: resolve.sync(id, { basedir: process.cwd() }),\n              };\n          }\n        }\n      );\n      build.onLoad({\n        filter: /.*/,\n        namespace: \"dep\"\n      }, async (loadInfo) => {\n        await init;\n        const id = loadInfo.path;\n\n        const root = process.cwd();\n        const entryPath = normalizePath(resolve.sync(id, { basedir: root }));\n\n        const code = await fs.readFile(entryPath, \"utf-8\");\n        // console.log(\"path-------\", entryPath,)\n        const [imports, exports] = await parse(code);\n        // console.log(\"imports, exports\", imports, exports)\n        let proxyModule = [];\n        let relativePath = normalizePath(path.relative(root, entryPath))\n        if (\n          !relativePath.startsWith('./') &&\n          !relativePath.startsWith('../') &&\n          relativePath !== '.'\n        ) {\n          relativePath = `./${relativePath}`\n        }\n\n        //进行词法解析，将所有require的文件方法提取出来转为es虚拟模块暴露 \n        if (!imports.length && !exports.length) {\n          let res = await import(pathToFileURL(entryPath).toString());\n          const specifiers = Object.keys(res);\n          proxyModule.push(\n            `export { ${specifiers.join(\",\")} } from \"${relativePath}\"`,\n            // `export default import(\"${relativePath}\")`\n          );\n        } else {\n          if ((exports as any).includes(\"default\")) {\n            proxyModule.push(`import d from \"${entryPath}\";export default d`);\n          }\n          proxyModule.push(`export * from \"${relativePath}\"`);\n        }\n\n\n        debug(\"代理模块内容: %o\", proxyModule.join(\"\\n\"));\n        const loader = path.extname(entryPath).slice(1);\n        // console.log(\"resolveDir----------\", root, proxyModule)\n        // console.log(\"proxyModule----------\", proxyModule)\n        return {\n          loader: loader as Loader,\n          contents: proxyModule.join(\"\\n\"),\n          resolveDir: root,\n        }\n      })\n      build.onStart(() => {\n        console.log('build started')\n      })\n    }\n  }\n}\n```\n我们将其分成两块来看 🫠\n在 onResolve 中，我们继续沿用上一次进行依赖收集的条件，其实进行依赖收集也是为了能更快的找到依赖， 。让我们来康康，他是如何进行精准命中的\n第一步，确定入口模块 👻\n一般来说，包里面对其没有引用，我们一般就可以 。如果为 false，则返回其路径为绝对路径。\n我们来看看当他为 false 时的情况\n```js\nresolveInfo = {\n  path: \"react\",\n  importer:\n    \"D:\\\\code\\\\study\\\\vite\\\\minivite\\\\koaVite\\\\node_modules\\\\.pnpm\\\\react-dom@18.3.1_react@18.3.1\\\\node_modules\\\\react-dom\\\\cjs\\\\react-dom.development.js\",\n  namespace: \"file\",\n  resolveDir:\n    \"D:\\\\code\\\\study\\\\vite\\\\minivite\\\\koaVite\\\\node_modules\\\\.pnpm\\\\react-dom@18.3.1_react@18.3.1\\\\node_modules\\\\react-dom\\\\cjs\",\n  kind: \"require-call\",\n  pluginData: undefined,\n  with: {},\n};\n```\n这个是他的 resolveInfo，我们可以看到，他是在 react-dom 中使用的 react 包，我们是不需要将其进行处理的，我们原本已经处理好了一个模块了，这里我们 ,使用他的时候会在后续的插件容器中进行处理，我们的插件最终会在.m-vite中去读取bare包\n第二步，对于入口文件进行重写 💀\n上述满足条件的会标记为 dep 命名空间，我们可以直接在 。 这个包是用于对路径依赖进行分析的，我们 ，我们从 loadInfo 中获取当前路径的 id ，然后\n```ts\nexport function normalizePath(id: string): string {\n  return path.posix.normalize(isWindows ? slash(id) : id);\n}\n```\n这个方法只是帮我们适配 windows 系统的路径，resolve.sync 是 ,resolve 是帮助我们从当前根路径下寻找可用的路径。他们会将 id 为 ,转化为 这样的路径\n，解析当前路径是否存在 ， 此数组用来收集 ， 则是将路径转化为 这种相对路径，下面的 if 处理也是用于帮助转换为相对路径的。\n```ts\nawait init;\nconst id = loadInfo.path;\n\nconst root = process.cwd();\nconst entryPath = normalizePath(resolve.sync(id, { basedir: root }));\n\nconst code = await fs.readFile(entryPath, \"utf-8\");\n// console.log(\"path-------\", entryPath,)\nconst [imports, exports] = await parse(code);\n// console.log(\"imports, exports\", imports, exports)\nlet proxyModule = [];\nlet relativePath = normalizePath(path.relative(root, entryPath));\nif (!relativePath.startsWith(\"./\") && !relativePath.startsWith(\"../\") && relativePath !== \".\") {\n  relativePath = `./${relativePath}`;\n}\n```\n我们开始处理是否存在 esmodule 依赖了, 这里的处理是 ，如果不存在，我们需要将 commonjs 的模块转换为 esmodule 的模块，我们 ，我们的入口文件主要功能就是暴露模块，我们只需要关注暴露了哪些模块就好了，最后会 ;\n```ts\n//进行词法解析，将所有require的文件方法提取出来转为es虚拟模块暴露\nif (!imports.length && !exports.length) {\n  const res = require(entryPath);\n\n  const specifiers = Object.keys(res);\n  // console.log(\"res----\", entryPath, res)\n  proxyModule.push(\n    `export { ${specifiers.join(\",\")} } from \"${relativePath}\"`,\n    `export default require(\"${relativePath}\")`\n  );\n} else {\n  if ((exports as any).includes(\"default\")) {\n    proxyModule.push(`import d from \"${entryPath}\";export default d`);\n  }\n  proxyModule.push(`export * from \"${relativePath}\"`);\n}\n```\n我们的 else，则是存在 esmodule 模块时的操作，我们只需要，判断是否有默认暴露，有的话就补上，在分别暴露的情况下也只需要使用通配符就可以暴露所有模块，非常方便\n为什么要这么处理呢\n对于 CommonJS 格式的依赖，单纯用 export default require('入口路径') 是有局限性的，比如对于 React 而言，用这样的方式生成的产物最后只有 default 导出:\n```ts\nexport default react_default;\n```\n那么用户在使用这个依赖的时候，必须这么使用:\n```ts\n// ✅ 正确\nimport React from \"react\";\nconst { useState } = React;\n// ❌ 报错\nimport { useState } from \"react\";\n```\n最后,返回一个对象，loader 这里是'js'，将我们的内容打包为 js， 将收集的依赖数组转化为内容，代替原本的内容进行打包，resolveDir 则是我们当前根目录\n```ts\nconst loader = path.extname(entryPath).slice(1);\n// console.log(\"resolveDir----------\", root, proxyModule)\n// console.log(\"proxyModule----------\", proxyModule)\nreturn {\n  loader: loader as Loader,\n  contents: proxyModule.join(\"\\n\"),\n  resolveDir: root,\n};\n```\n下面则是我们打包的结果\n```js\n// dep:react\nvar import_react = __toESM(require_react());\nvar export_Children = import_react.Children;\nvar export_Component = import_react.Component;\nvar export_Fragment = import_react.Fragment;\nvar export_Profiler = import_react.Profiler;\nvar export_PureComponent = import_react.PureComponent;\nvar export_StrictMode = import_react.StrictMode;\nvar export_Suspense = import_react.Suspense;\nvar export___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = import_react.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\nvar export_act = import_react.act;\nvar export_cloneElement = import_react.cloneElement;\nvar export_createContext = import_react.createContext;\nvar export_createElement = import_react.createElement;\nvar export_createFactory = import_react.createFactory;\nvar export_createRef = import_react.createRef;\nvar export_default = import_react.default;\nvar export_forwardRef = import_react.forwardRef;\nvar export_isValidElement = import_react.isValidElement;\nvar export_lazy = import_react.lazy;\nvar export_memo = import_react.memo;\nvar export_startTransition = import_react.startTransition;\nvar export_unstable_act = import_react.unstable_act;\nvar export_useCallback = import_react.useCallback;\nvar export_useContext = import_react.useContext;\nvar export_useDebugValue = import_react.useDebugValue;\nvar export_useDeferredValue = import_react.useDeferredValue;\nvar export_useEffect = import_react.useEffect;\nvar export_useId = import_react.useId;\nvar export_useImperativeHandle = import_react.useImperativeHandle;\nvar export_useInsertionEffect = import_react.useInsertionEffect;\nvar export_useLayoutEffect = import_react.useLayoutEffect;\nvar export_useMemo = import_react.useMemo;\nvar export_useReducer = import_react.useReducer;\nvar export_useRef = import_react.useRef;\nvar export_useState = import_react.useState;\nvar export_useSyncExternalStore = import_react.useSyncExternalStore;\nvar export_useTransition = import_react.useTransition;\nvar export_version = import_react.version;\nexport {\n  export_Children as Children,\n  export_Component as Component,\n  export_Fragment as Fragment,\n  export_Profiler as Profiler,\n  export_PureComponent as PureComponent,\n  export_StrictMode as StrictMode,\n  export_Suspense as Suspense,\n  export___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED as __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,\n  export_act as act,\n  export_cloneElement as cloneElement,\n  export_createContext as createContext,\n  export_createElement as createElement,\n  export_createFactory as createFactory,\n  export_createRef as createRef,\n  export_default as default,\n  export_forwardRef as forwardRef,\n  export_isValidElement as isValidElement,\n  export_lazy as lazy,\n  export_memo as memo,\n  export_startTransition as startTransition,\n  export_unstable_act as unstable_act,\n  export_useCallback as useCallback,\n  export_useContext as useContext,\n  export_useDebugValue as useDebugValue,\n  export_useDeferredValue as useDeferredValue,\n  export_useEffect as useEffect,\n  export_useId as useId,\n  export_useImperativeHandle as useImperativeHandle,\n  export_useInsertionEffect as useInsertionEffect,\n  export_useLayoutEffect as useLayoutEffect,\n  export_useMemo as useMemo,\n  export_useReducer as useReducer,\n  export_useRef as useRef,\n  export_useState as useState,\n  export_useSyncExternalStore as useSyncExternalStore,\n  export_useTransition as useTransition,\n  export_version as version\n};\n\n```\nexport 代表之前是 commomjs 的模块，现在变成 esmodule 的模块，所以需要加一个_,到这里，我们的依赖预构建终于完成了；\n参考：\n\n大家可以去学一学这个，此项目的灵感来源，也是带我进入了工程化的大门"}],"metadata":{},"filePath":"docs/guide/project/从零开始搭建vite/从koa到mini-vite(一).mdx"}
{"messages":[{"role":"user","content":"介绍"},{"role":"assistant","content":"Git 的三个区域：\n在文件夹的体现如下：\n在代码中的体现如下："}],"metadata":{},"filePath":"docs/guide/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"Git配置"},{"role":"assistant","content":"安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 因为每一个 Git 提交都会使用这些信息\n命令格式如下：\ngit config --global user.name 你的用户名\ngit config --global user.email 你的邮箱地址\n运行命令效果如下：\n\n配置后, 可以运行如下命令查看是否成功\n```bash\ngit config --list\n#如果信息太多，可以输入 q 退出\n```\n运行命令效果如下："}],"metadata":{},"filePath":"docs/guide/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"文件右侧标记"},{"role":"assistant","content":"右侧没有标记的时候为 或 此文件/文件夹，被git忽略不跟踪变化"}],"metadata":{},"filePath":"docs/guide/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"初始化空的Git仓库"},{"role":"assistant","content":"新建一个文件夹或现有的文件夹并不是 git 仓库，因为文件夹内不包含 .git 文件夹，没有被 git 管理\n可以在新文件夹或现有文件夹，运行如下命令得到 .git 文件夹，初始化成功则可让 git 开始准备管理\n```bash\n# 初始化 git 仓库, 产物: .git 文件夹 (所在文件夹\"内\"被管理)\ngit init\n\n```\n例如，在新文件夹中输入git init命令用于初始化空的git版本库\n\n初始化空的 git 仓库成功后，在项目文件夹中，开启显示隐藏文件，即可查看 .git 文件夹"}],"metadata":{},"filePath":"docs/guide/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"记录更新到Git仓库"},{"role":"assistant","content":"每当完成了一个阶段的目标，想要记录下它时，就将它提交到仓库\n核心操作： ---> --->\n```bash\n# 将 index.html 添加到暂存区\ngit add index.html\n\n# 将css目录下一切添加到暂存区\ngit add css\n```\n```bash\ngit add .\n```\n```bash\ngit commit -m '提交的内容说明'\n\n```\n过程图示："}],"metadata":{},"filePath":"docs/guide/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"Git日志及状态查看"},{"role":"assistant","content":"```bash\ngit log\n```\n运行命令效果如下：\n\n```bash\ngit log --oneline\n```\n运行命令效果如下：\n\n```bash\ngit status\n```\n运行命令效果如下：\n\n```bash\ngit status\n\n```\n过程图示："}],"metadata":{},"filePath":"docs/guide/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"Git版本回退"},{"role":"assistant","content":"时光机，回到过去~\n```bash\ngit reset --hard 版本号\n```\n```bash\ngit log --oneline\n```\n\n```bash\ngit reset --hard 477321b\n```\n\n```bash\ngit reflog\n\n```\n运行命令效果如下："}],"metadata":{},"filePath":"docs/guide/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"Git忽略文件"},{"role":"assistant","content":"有的时候，我们某些文件或文件夹不想让 git 进行跟踪管理。这时候可以在 .git 文件夹同级目录下新增 的忽略文件并写入忽略规则（此处的文件名就是 .gitignore ，不是后缀）\n项目文件夹结构如下：\n\n```bash\n# .gitignore内容：\npassword.txt\n\n其余用法：\n# 忽略文件夹\ncss\n# 忽略文件夹下的某个文件\ncss/index.js\n# 忽略文件夹下某类文件\ncss/*.js\n\n```\n根目录新建 password.txt，查看 git 追踪到了哪些变化\n```bash\ngit status\n```\n运行命令效果如下：\n\n文件在项目中可以根据脚手架自动生成，无需自己编写，当然如果你非要写，以下是Vue官方自动生成的 文件代码，可供复制使用\n```bash\n# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\npnpm-debug.log*\nlerna-debug.log*\n\nnode_modules\ndist\ndist-ssr\n*.local\n\n# Editor directories and files\n.vscode/*\n!.vscode/extensions.json\n.idea\n.DS_Store\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw?\n\n```"}],"metadata":{},"filePath":"docs/guide/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"分支本质"},{"role":"assistant","content":"分支其实就是一个叫 的指针标记，每次代码提交，此 指针都会往后移动一次，保证指向的 (并且工作区里的) 都是最后一次提交\n例如：当我们输入命令： ， 指针会移动，而且 移动后，会影响工作区里的代码"}],"metadata":{},"filePath":"docs/guide/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"创建分支"},{"role":"assistant","content":"```bash\n# 创建分支\ngit branch 分支名\n\n```\n该命令创建分支后不会自动切换分支，我们可以运行命令查看现在这个 .git 版本库里所有分支"}],"metadata":{},"filePath":"docs/guide/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"查看当前版本库所有分支，绿色带*代表现在所处的分支"},{"role":"assistant","content":"git branch\n运行命令效果如下："}],"metadata":{},"filePath":"docs/guide/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"切换分支命令"},{"role":"assistant","content":"git checkout 分支名\n运行命令效果如下：\n\n过程图示："}],"metadata":{},"filePath":"docs/guide/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"分支下开发流程"},{"role":"assistant","content":"我们现在就可以在当前 reg 分支下来编写注册页面的逻辑代码，例如新建 文件，并随便写点内容。随后暂存并提交一次，这次提交的记录会出现在这里，如图\n\n以后在当前 reg 分支下开发，就会在 reg 范围内，每次提交产生一次版本记录，不会影响到别的分支"}],"metadata":{},"filePath":"docs/guide/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"分支合并"},{"role":"assistant","content":"我们可以把分支里写好的代码，合并到主分支或其他分支上，步骤如下："}],"metadata":{},"filePath":"docs/guide/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"切换分支"},{"role":"assistant","content":"git checkout master\n切换分支后， 指针位置如下：\n\n\ngit branch -d 分支名\n这里我们执行命令 ，执行后效果如图：\n\n可见，reg 代码提交记录已经复制到了 master (主分支) 中"}],"metadata":{},"filePath":"docs/guide/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"分支删除"},{"role":"assistant","content":"假如注册功能开发完毕，代码已经合并到 master 分支上，我们已经不需要 reg 分支\n```bash\ngit branch -d 分支名\n\n```\n如果分支的修改没有被合并到其他分支上，Git 会提示一个类似以下的错误信息：\n\n在这种情况下，Git 建议你确认是否要删除这个分支。如果你确定要删除该分支并且不在乎丢失该分支的修改，你可以使用 命令来 该分支。但请注意，这样会丢失掉分支上的未合并修改"}],"metadata":{},"filePath":"docs/guide/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"分支合并时的冲突问题"},{"role":"assistant","content":"在两个分支修改了同一个文件并提交过，在合并的时候，就会产生冲突\n这里模拟一次简单的冲突：\n\n\n\n发生冲突后，VSCode界面\n\n选择保留方式后，需要再次暂存提交一次"}],"metadata":{},"filePath":"docs/guide/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"介绍"},{"role":"assistant","content":"远程仓库是指托管在因特网或其他网络上的 Git 仓库，可以存储我们版本库的所有记录和存档记录\n远程仓库在团队协作中发挥着重要的作用。它不仅可以充当备份存储，保护你的代码免受数据丢失的风险，还可以让团队成员之间轻松地共享代码、查看代码变更、进行代码审查等\n\n主流的远程仓库有 GitHub (gay hub)全球最大的同行交友社区，以及服务器在国内的 gitee（码云）。由于 GitHub 服务器在国外，需要科学上网或者使用其他加速工具，方便起见，这里以码云为例，供初学者参考，GitHub 流程与 gitee 类似"}],"metadata":{},"filePath":"docs/guide/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"注册"},{"role":"assistant","content":"注册登录 gitee.com 网站以后，添加主邮箱为自己本地 git 仓库设置的邮箱，注意一定要相同，否则无法正确提交\n如果忘记了本地设置的邮箱地址："}],"metadata":{},"filePath":"docs/guide/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"仓库新建"},{"role":"assistant","content":"可以选择创建一个远程仓库的项目 (可以多个)，创建界面如下\n\n勾选完成后选择创建，创建后, 会得到一个远程仓库的地址链接, 一般是以 结尾的地址\n地址分为两种最常用的两种传输协议：\n选择SSH路径，界面如下"}],"metadata":{},"filePath":"docs/guide/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"SSH配置"},{"role":"assistant","content":"我们可以在本机一次性配置 SSH 以后免密登录，SSH 密钥组成和作用如下：\nSSH 密钥创建与使用步骤："}],"metadata":{},"filePath":"docs/guide/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"初始化空仓库"},{"role":"assistant","content":"先给本地仓库配置个远程仓库的地址, 建立仓库之间的链接\n由于每次 push 操作都需要带上远程仓库的地址，十分麻烦，我们可以给仓库设置一个别名\n```bash\n# 给远程仓库设置一个别名\ngit remote add 仓库别名 仓库地址\ngit remote add origin git@gitee.com:(username)/repository.git\n\n# 删除 origin 这个别名\ngit remote remove origin\n\n# 使用 -u 记录 push 到远端分支的默认值，将来直接 git push 即可\ngit push -u 仓库别名 分支名\n\n\n```\n\n下面为实际操作举例：\n空仓库创建成功后可以在管理页面将仓库开源，当然也可以不设置开源（默认私有）"}],"metadata":{},"filePath":"docs/guide/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"克隆项目"},{"role":"assistant","content":"如果你想要从远程仓库克隆一份项目代码到本地进行开发，可以使用 命令\n```bash\ngit clone [options] <repository-url> [directory]\n# directory（可选）克隆后的本地仓库所处的目录名称（默认创建与远程仓库名字相同的目录）\n\n```\n\n如果项目只有一个分支，那么以上代码执行完毕就已经克隆结束了（git clone 默认拉取 master 分支），\n```bash\ngit checkout -b 对应远程分支名\n```\n```bash\n# 每次拉取都需要指定远程仓库名和分支名\ngit pull 远程仓库名 分支名\n\n```\n```bash\ngit checkout -b 分支名 origin/分支名\n\n```\n```bash\ngit branch --set-upstream-to=origin/远程分支名 本地分支名\n\n```"}],"metadata":{},"filePath":"docs/guide/guid/tool/git的使用.md"}
{"messages":[{"role":"user","content":"介绍"},{"role":"assistant","content":"img: 英文全称 image（图像），代表的是一张图片。\n如果要想在网页中显示图像，就可以使用img 标签，它是一个单标签。语法如下：\n```html\n<img src=\"图片的URL\" />\n```"}],"metadata":{"title":"06-HTML标签：图片标签","publish":true},"filePath":"docs/guide/guid/html/05-HTML标签：图片标签.md"}
{"messages":[{"role":"user","content":"能插入的图片类型"},{"role":"assistant","content":"HTML页面不是直接插入图片，而是插入图片的引用地址，所以要先把图片上传到服务器上。"}],"metadata":{"title":"06-HTML标签：图片标签","publish":true},"filePath":"docs/guide/guid/html/05-HTML标签：图片标签.md"}
{"messages":[{"role":"user","content":"img标签的 属性"},{"role":"assistant","content":"这里涉及到图片的一个属性：\n在写 时，有两种写法：相对路径、绝对路径"}],"metadata":{"title":"06-HTML标签：图片标签","publish":true},"filePath":"docs/guide/guid/html/05-HTML标签：图片标签.md"}
{"messages":[{"role":"user","content":"写法一：图片的相对路径"},{"role":"assistant","content":"相对当前页面所在的路径。两个标记 和 分表代表当前目录和上一层目录。\n举例1：\n```html\n<!-- 当前目录中的图片 -->\n<img src=\"2.jpg\" />\n<img src=\"./2.jpg\" />\n\n<!-- 上一级目录中的图片 -->\n<img src=\"../2.jpg\" />\n```\n相对路径不会出现这种情况：\n```html\naaa/../bbb/1.jpg\n```\n要么不写，要么就写在开头。\n举例2：\n```html\n<img src=\"images/1.jpg\" />\n```\n上方代码的意思是说，当前html页面有一个并列的文件夹 ，在文件夹 中存放了一张图片 效果：\n\n相对路径的面试题。现有如下文件层级图：\n\n问题：如果想在index.html中插入1.png，那么对应的img语句是？\n分析：\n现在document是最大的文件夹，里面有两个文件夹work和photo。work中又有一个文件夹叫做myweb。myweb文件夹里面有index.html。 所以index.html在myweb文件夹里面，上一级就是work文件夹，上两级就是document文件夹。通过document文件夹当做一个中转站，进入photo文件夹，看到了1.png。\n答案：\n```html\n<img src=\"../../photo/1.png\" />\n```"}],"metadata":{"title":"06-HTML标签：图片标签","publish":true},"filePath":"docs/guide/guid/html/05-HTML标签：图片标签.md"}
{"messages":[{"role":"user","content":"写法二：图片的绝对路径"},{"role":"assistant","content":"绝对路径包括以下两种：\n（1）以盘符开始的绝对路径。举例：\n```html\n<img src=\"C:\\Users\\qianguyihao\\Desktop\\html\\images\\1.jpg\" />\n```\n（2）网络路径。举例：\n```html\n<img src=\"http://img.smyhvae.com/20200122_200901.png\" />\n```\n大家打开上面的img中的链接，可能有彩蛋哦。"}],"metadata":{"title":"06-HTML标签：图片标签","publish":true},"filePath":"docs/guide/guid/html/05-HTML标签：图片标签.md"}
{"messages":[{"role":"user","content":"相对路径和绝对路径的总结"},{"role":"assistant","content":"相对路径的好处：站点不管拷贝到哪里，文件和图片的相对路径关系都是不变的。相对路径使用有一个前提，就是网页文件和你的图片，必须在一个服务器上。\n：\n无论是在 a 标签还是 img 标签上，如果要用路径。只有两种路径能用，就是相对路径和绝对路径："}],"metadata":{"title":"06-HTML标签：图片标签","publish":true},"filePath":"docs/guide/guid/html/05-HTML标签：图片标签.md"}
{"messages":[{"role":"user","content":"width、height 属性"},{"role":"assistant","content":"width和height，在 HTML5 中的单位是 CSS 像素，在 HTML 4 中既可以是像素，也可以是百分比。可以只指定 width 和 height 中的一个值，浏览器会根据原始图像进行缩放。\n：如果要想保证图片等比例缩放，请只设置width和height中其中一个。"}],"metadata":{"title":"06-HTML标签：图片标签","publish":true},"filePath":"docs/guide/guid/html/05-HTML标签：图片标签.md"}
{"messages":[{"role":"user","content":"Alt 属性"},{"role":"assistant","content":"属性效果演示：\n\n如上图所示：当图片 src 不可用的时候，显示文字。这样做，至少能让用户知道，这个图片大概是什么内容。"}],"metadata":{"title":"06-HTML标签：图片标签","publish":true},"filePath":"docs/guide/guid/html/05-HTML标签：图片标签.md"}
{"messages":[{"role":"user","content":"title 属性"},{"role":"assistant","content":"title 属性不该被用作一幅图片在 alt 之外的补充说明信息。如果一幅图片需要小标题，使用 figure 或 figcaption 元素。\ntitle 元素的值一般作为提示条(tooltip)呈现给用户，在光标于图片上停下后显示出来。尽管这确实能给用户提供更多的信息，您不该假定用户真的能看到：用户可能只有键盘或触摸屏。如果要把特别重要的信息提供给用户，可以选择上面提供的一种方法将其内联显示，而不是使用 title。\n举例：\n```html\n<img src=\"images/1.jpg\" width=\"300\" height=\"`188\" title=\"这是美女\" />\n```\n效果："}],"metadata":{"title":"06-HTML标签：图片标签","publish":true},"filePath":"docs/guide/guid/html/05-HTML标签：图片标签.md"}
{"messages":[{"role":"user","content":"align 属性"},{"role":"assistant","content":"如果想实现图文混排的效果，请使用align属性，取值为left或right。\n我们来分别看一下这 属性的这几个属性值的区别。\n1、 ，图片和文字底端对齐。即默认情况下的显示效果：\n\n2、 ：图片和文字水平方向上居中对齐。显示效果：\n\n3、 ：图片与文字顶端对齐。显示效果：\n\n4、 ：图片在文字的左边。显示效果：\n\n5、 ：图片在文字的右边。显示效果："}],"metadata":{"title":"06-HTML标签：图片标签","publish":true},"filePath":"docs/guide/guid/html/05-HTML标签：图片标签.md"}
{"messages":[{"role":"user","content":"HI"},{"role":"assistant","content":"欢迎来到我的 ，我是一个 ，这里是用来记录、学习、分享的 😏。\n目前点亮 , , , , , ， ， 等一些技能树。（爱你 ~~😘）；\n前端技术\n服务端\n\n从 搭建 之后，整体的风格会更加偏向随笔\n🔥/💦"}],"metadata":{},"filePath":"docs/guide/index.mdx"}
{"messages":[{"role":"user","content":"计划列表"},{"role":"assistant","content":"这里是我的 github 地址"}],"metadata":{},"filePath":"docs/guide/index.mdx"}
{"messages":[{"role":"user","content":"可视化实例"},{"role":"assistant","content":"import Btn from \"@page/css/instance/btn\";\n<Btn  />"}],"metadata":{},"filePath":"docs/guide/vr/instance.mdx"}
